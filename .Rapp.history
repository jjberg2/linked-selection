cia<-read.table("~/Downloads/rawdata_2147.txt",as.is=TRUE)
cia
cia<-read.table("~/Downloads/rawdata_2147.txt",as.is=TRUE)
cia<-read.table("~/Downloads/rawdata_2147.txt",as.is=TRUE,sep="\t")
cia
cia<-read.table("~/Downloads/rawdata_2147.txt",as.is=TRUE,fill=TRUE)
cia<-read.table("~/Dropbox/postdocs/Peter/Spatial_adaptation/cia_factbook_areas",as.is=TRUE,fill="TRUE")
cia<-read.table("~/Dropbox/postdocs/Peter/Spatial_adaptation/cia_factbook_areas",as.is=TRUE)
cia<-read.table("~/Dropbox/postdocs/Peter/Spatial_adaptation/cia_factbook_areas",as.is=TRUE,sep=" ")
cia<-read.table("~/Downloads/rawdata_2147_new.txt",as.is=TRUE,fill=TRUE)
cia<-read.table("~/Downloads/rawdata_2147_new.txt",as.is=TRUE)
cia<-read.table("~/Downloads/rawdata_2147_new.txt",as.is=TRUE,sep="\t")
cia
cia<-read.csv("~/Downloads/rawdata_2147_new.csv",as.is=TRUE)
cia
cia<-read.csv("~/Downloads/rawdata_2147_new.csv",as.is=TRUE,head=FALSE)
cia
malaria
malaria[1,]
malaria$V1
malaria<-read.csv("~/Dropbox/postdocs/Peter/Spatial_adaptation/malaria_present.csv",as.is=TRUE)
malaria
malaria<-read.csv("~/Dropbox/postdocs/Peter/Spatial_adaptation/malaria_present.csv",as.is=TRUE,head=FALSE)
malaria
malaria<-malaria[-1,]
malaria
malaria$V1
cia
mean(cia$V2 %in% malaria$V1)
malaria<-read.csv("~/Dropbox/postdocs/Peter/Spatial_adaptation/malaria_present.csv",as.is=TRUE,head=FALSE)
mean(cia$V2 %in% malaria$V1)
mean(malaria$V1 %in% cia$V2)
malaria[1,]
malaria<-malaria[-1,]
malaria[1,]
unique(malaria$V2)
malaria.eurasia<-malaria[malariaV2 %in% c("Middle-East","SoutheastAsia","Euroasia","EasternAsia","CentralAsia","CentralAsia","Transcaucasia")]
malaria.eurasia<-malaria[malaria$V2 %in% c("Middle-East","SoutheastAsia","Euroasia","EasternAsia","CentralAsia","CentralAsia","Transcaucasia")]
malaria.eurasia<-malaria[malaria$V2 %in% c("Middle-East","SoutheastAsia","Euroasia","EasternAsia","CentralAsia","CentralAsia","Transcaucasia"),]
malaria[malaria$V2 =="Pacific",]
mean(malaria.eurasia$V1 %in% cia$V2)
malaria.eurasia[!(malaria.eurasia$V1 %in% cia$V2),]
malaria.eurasia
malaria.eurasia[!(malaria.eurasia$V1 %in% cia$V2),]
cia[1,]
sum(cia$V2 == "Korea North")
sum(cia$V2 == "Korea South")
sum(cia$V2 == "Burma")
sum(cia$V2 == "Syria")
sum(cia$V2 == "Korea South")
sum(cia$V2 == "Viet Nam")
sum(cia$V2 == "Viet nam")
sum(cia$V2 == "Vietnam")
sum(cia$V2 == "Saudi Arabia")
missing.these<-c("Laos","Korea North", "Korea South","Burma","Syria","Vietnam","Saudi Arabia")#
#
cia$V2[ cia$V2 %in% malaria.eurasia$V1 |   cia$V2 %in% missing.these]
missing.these<-c("Laos","Korea North", "Korea South","Burma","Syria","Vietnam","Saudi Arabia")#
#
cia$V3[ cia$V2 %in% malaria.eurasia$V1 |   cia$V2 %in% missing.these]
sum(missing.these<-c("Laos","Korea North", "Korea South","Burma","Syria","Vietnam","Saudi Arabia")#
#
cia$V3[ cia$V2 %in% malaria.eurasia$V1 |   cia$V2 %in% missing.these])
missing.these<-c("Laos","Korea North", "Korea South","Burma","Syria","Vietnam","Saudi Arabia")#
#
sum(cia$V3[ cia$V2 %in% malaria.eurasia$V1 |   cia$V2 %in% missing.these])
22529939/1e6
sqrt(22529939/15)
(22529939-9596960)/1e6
sqrt((22529939-9596960)/15)
sqrt((22529939-9596960-2149690)/15)
sqrt((22529939-2149690)/15)
515*1e-8
(22529939-9596960-2149690)/1e6
charLength <- function (mu, rho, sb, sd, sigma) {#
    # the characteristic length, which is#
    #   the positive solution to#
    #   lambda0 x^2 + lambda x^3 / v = 1/pi#
    if (sd==1) {#
        return( list( value=(sigma/(rho*mu*pi*sqrt(2*sb)))^(1/3), roots=NA) )#
    } else if (sd==0) {#
        return( list( value=0, roots=NA) )#
    } else {#
        roots <-  polyroot( c(-1/pi, 0, 2*mu*rho*sb/log(1/(1-sd)), sqrt(2*sb)*mu*rho / sigma ) )#
        ii <- which.max(Re(roots[Im(roots)<10*.Machine$double.eps]))#
        # sanity check#
        if (length(ii)==0) { stop("No real roots for characteristic length?") }#
        return( list(value=Re(roots[ii]), roots=roots) )#
    }#
}
charLength(mu=5e-6, rho=2, sb=0.2, sd=0.4, sigma=50)
charLength(mu=5e-6, rho=2, sb=0.2, sd=0.4, sigma=100)
charLength(mu=5e-6, rho=2, sb=0.2, sd=0.8, sigma=100)
charLength(mu=5e-6, rho=0.2, sb=0.2, sd=0.8, sigma=100)
charLength(mu=1.5e-6, rho=2, sb=0.2, sd=0.4, sigma=100)
charLength(mu=1.5e-6, rho=2, sb=0.04, sd=0.1, sigma=50)
charLength(mu=5e-6, rho=2, sb=0.25, sd=0.5, sigma=50)
charLength(mu=5e-6, rho=2, sb=0.25, sd=0.5, sigma=10)
charLength(mu=5e-6, rho=2, sb=0.25, sd=0.5, sigma=200)
charLength(mu=5e-6, rho=2, sb=0.25, sd=0.1, sigma=200)
charLength(mu=5e-6, rho=2, sb=0.05, sd=0.1, sigma=200)
charLength(mu=5e-6, rho=2, sb=0.05, sd=0.2, sigma=200)
charLength(mu=5e-6, rho=2, sb=0.05, sd=0.3, sigma=200)
sqrt((22529939-2149690)/40)
sqrt((22529939-9596960-2149690)/40)
charLength(mu=5e-6, rho=2, sb=0.05, sd=0.3, sigma=20)
charLength(mu=5e-6, rho=2, sb=0.05, sd=0.3, sigma=20)$value
mu=5e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.3,length=50); sigma=20; charlength.sd<-sapply(sd, function (sigma) { charLength(mu,rho,sb,sd,sigma)$value } )
mu=5e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.3,length=50); sigma=20; charlength.sd<-sapply(sdvals, function (sigma) { charLength(mu,rho,sb,sd,sigma)$value } )
mu=5e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.3,length=50); sigma=20; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )
plot(sdvals,charlength.sd)
mu=5e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=20; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )
plot(sdvals,charlength.sd)
mu=5e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )
plot(sdvals,charlength.sd)
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )
plot(sdvals,charlength.sd)
plot(sdvals,charlength.sd,tyle="l")
plot(sdvals,charlength.sd,type="l")
charLength(mu,rho,sb,sd=1,sigma)$value
charLength(mu,rho,sb,sd=100,sigma)$value
charLength(mu,rho,sb,sd=0.99,sigma)$value
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )
plot(sdvals,charlength.sd,type="l")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )
lines(sdvals,charlength.sd,type="l")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=10; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )
lines(sdvals,charlength.sd,type="l",col="red")
require(devtools)#
devtools::install_github("wesanderson","karthik")
install.packages("devtools")
require(devtools)#
devtools::install_github("wesanderson","karthik")
plot(sdvals,charlength.sd,type="l")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,500))#
#
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l")#
#
 mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=10; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd)
plot(sdvals,charlength.sd)
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,500),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.5,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")
newCharLength <- function (mu, rho, sb, sd, sigma) {#
    # the characteristic length *if only looking at new mutations*, which is#
    #     x = ( v/(pi lambda) )^(1/3)#
    return( list( value=(sigma/(rho*mu*pi*sqrt(2*sb)))^(1/3), roots=NA) )#
}
charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)})
newCharLength <- function (mu, rho, sb, sd, sigma) {#
    # the characteristic length *if only looking at new mutations*, which is#
    #     x = ( v/(pi lambda) )^(1/3)#
    return( list( value=(sigma/(rho*mu*pi*sqrt(2*sb)))^(1/3), roots=NA) )#
}#
#
oldCharLength <-  function (mu, rho, sb, sd, sigma) {#
    # the characteristic length *if only looking at standing variation*, which is#
    #     x = ( 1/(pi lambda0) )^(1/2)#
    if (sd==0) {#
        return( list( value=0, roots=NA) )#
    } else {#
        return( list( value=(2*mu*rho*sb/log(1/(1-sd)))^(-1/2), roots=NA) )#
    }#
}
charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)})
lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
length(charlength.standing.only)
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,1000),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,1500),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd, sigma)$value,col="black")#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd, sigma)$value,col="red")#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd, sigma)$value,col="orange")#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black")#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red")#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="orange")#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="purple")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black")#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red")#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="purple")#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black",lwd=2,lty=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red",lwd=2,lty=2)#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="purple",lwd=2,lty=2)#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black",lwd=2,lty=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red",lwd=2,lty=2)#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="purple",lwd=2,lty=2)#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.0001,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black",lwd=2,lty=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red",lwd=2,lty=2)#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="purple",lwd=2,lty=2)#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.0001,0.3,length=500); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black",lwd=2,lty=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red",lwd=2,lty=2)#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="purple",lwd=2,lty=2)#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.0001,0.3,length=500); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black",lwd=2,lty=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red",lwd=2,lty=2)#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="purple",lwd=2,lty=2)#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange",lty=3)
70*1e-8
140*1e-8
mu=1e-6; rho=2; sb=0.2; sdvals=seq(0.0001,0.3,length=500); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black",lwd=2,lty=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red",lwd=2,lty=2)#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="purple",lwd=2,lty=2)#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange",lty=3)
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.0001,0.3,length=500); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black",lwd=2,lty=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red",lwd=2,lty=2)#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="purple",lwd=2,lty=2)#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange",lty=3)
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.0001,0.3,length=500); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2,col=my.col[1])#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col=my.col[1],lwd=2,lty=2)  ##new mut. only#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col=my.col[2])#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col=my.col[2],lwd=2,lty=2)  ##new mut. only#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col=my.col[3])#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col=my.col[3],lwd=2,lty=2) ##new mut. only#
 ##contribution of standing var only#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
 lines(sdvals,charlength.standing.only ,lwd=2,col=my.col[4],lty=3)#
 legend("topleft",)
expected.freq.times.standing<-function(n,N,r,distance,f){#
#
my.StirlingNumbers<-StirlingNumbers(n) #
ESF.prob.k<-EwensDist( n=n , N =N, r=r , distance=distance , f=f ,stirling.numbers=my.StirlingNumbers)    ### is of form [n,k]#
#
#my.StirlingNumbers<-StirlingNumbers(n)    ##Usigned Stirling numbers of 1st kind. ma#
expected.t.l<-rep(NA,n)#
for(l in 1:(n-1)){#
#
	freq.specs<-sapply(1:n,function(k){#
		freq.spec<-rep(NA,n)#
		freq.spec[1:k]<-(1/(1:k))#
		return(freq.spec)#
	})#
	freq.specs<-t(freq.specs)#
	recover()#
	terms.in.sum<-rep(0,n)#
	for(k in 2:n){   ##runs from 2 otherwise there are no polymorphism#
			for(j in 1:(k-1)){#
			stirling.bit<-	my.StirlingNumbers[l,j] * my.StirlingNumbers[n-l,k-j]  / my.StirlingNumbers[n,k]#
			p_l_given_k<-stirling.bit*choose(n,l)/choose(k,l)#
			if(!is.finite(p_l_given_k)){ p_l_given_k<-0 }  ##cat("problem",l,k,j," "); ##is this right?#
			terms.in.sum[k]<-terms.in.sum[k]+ESF.prob.k[n,k] *p_l_given_k*freq.specs[k,j]#
			stopifnot(is.finite(terms.in.sum[k])) #
		}		#
	}#
#
	expected.t.l[l]<-sum(terms.in.sum)#
}#
#
return(expected.t.l)#
}
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.0001,0.3,length=500); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2,col=my.col[1])#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col=my.col[1],lwd=2,lty=2)  ##new mut. only#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col=my.col[2])#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col=my.col[2],lwd=2,lty=2)  ##new mut. only#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col=my.col[3])#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col=my.col[3],lwd=2,lty=2) ##new mut. only#
 ##contribution of standing var only#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
 lines(sdvals,charlength.standing.only ,lwd=2,col=my.col[4],lty=3)#
 legend("topleft",)
source ("SweepFromStandingSim.R")#
run.ms.f<-function(f.index,n.sam=2, get.site.density=TRUE,recom=FALSE){#
#
	my.file<-paste("mssel_f",n.sam,f.index,".out",sep="")#
#
	system(paste("rm ",my.file))#
	for(run in 1:5){#
		load(paste("run_cond_lost_",run,".Robj",sep=""))#
		for(i in 1:100){#
			my.freqs<-my.runs[[f.index]]$trees[[i]]$freqs#
			my.times<-0:length(my.freqs)#
			my.freqs<-c(my.freqs,0)#
			my.times<-my.times / (4*10e3)#
	#		recover()#
			header.material<-c("1","1",paste("n:",length(my.times) ))#
			write(file=paste("my.standing",f.index,".traj",sep=""),header.material)#
			write.table(file=paste("my.standing",f.index,".traj",sep=""),cbind(my.times,my.freqs), append=TRUE, sep="\t",quot=FALSE,col.nam=FALSE,row.name=FALSE)#
			cat(i," ")#
			if(get.site.density){ #
				system(paste("msseldir/mssel ",n.sam," 20 0 ",n.sam," my.standing",f.index,".traj 0 -t 200. -r 200. 20000 | grep pos | cut -f 2 -d : >> ",my.file,sep=""))#
				}else{   ##setup for the mo. to do freq. spectrum#
				system(paste("msseldir/mssel ",n.sam," ",20," 0 ",n.sam," my.standing",f.index,".traj 0 -t 200. -r ",recom, " 2 > myseqdata",sep="")) #
				spec<-get.freq.spec(n.sam,num.sims=20)#
				recover()#
			}#
		}#
	}#
}#
#
real.fs <- c ( 0.001 , seq ( 0.01 , 0.1 , length = 10 ) )#
my.runs <- lapply ( real.fs , function ( x ) SweepFromStandingSim ( N = 10000 , s = 0.01 , f = x , reps = 100 , no.sweep = FALSE , cond.on.loss = TRUE , cond.on.fix = TRUE , time.factor = 4 ) )#
get.mut.density<-function(file){#
	myres = scan(file)#
	##myres*theta, note range of smoothing#
	myres<-myres*200#
	mydens = density(myres,from=3,to=190,bw=2.0,na.rm=T)#
	mydens$y<-mydens$y*length(myres)#
	return(mydens)#
}#
pdf(file="pi_density.pdf")#
	plot(c(0,200),c(0,1),type="n",xlab="4NR",ylab=expression(pi[R]/pi[0]),cex.lab=1.5)#
	pi.over.f<-list()#
	for(f.index in 1:5){#
	#run.ms.f(f.index)#
	mut.density<-get.mut.density(file=paste("mssel_f",f.index,".out",sep=""))#
	pi.over.f[[f.index]]<-mut.density#
	lines(mut.density$x,mut.density$y/(5*100*20),col=f.index)#
	}#
	fs<-1:5/100#
	rho=seq(0,200,length=1000)#
	for(i in 1:5){#
	f=fs[i]#
	s=0.01#
	lines(rho,1-1/(1+rho*f*(1-f)),col=i,lwd=2,lty=2)#
	# lines(r,1-1/(1+4*N*r*f*(1-f))*exp(-2*r/s*log(1/f)),col=i,lwd=2)#
	# lines(r,1-exp(-2*r*(1/s*log(1/f)+2*N*f*(1-f))),col=i,lty=2)#
	}#
	legend("bottomright",legend= paste("f=",fs),col=1:5,lty=1,lwd=2,cex=1.5)#
dev.off()#
 for(f.index in 1:5){#
 run.ms.f(f.index=f.index,n.sam=10)#
 }#
N=1e4#
 r = 10^-8 ; interval.width = 1000; sim.distance = 0.05 #
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
 pdf(file="segsite_density.pdf")#
plot(c(0,200),c(0,2.5),type="n",xlab="4NR",ylab="Num. seg. sites",cex.lab=1.5)#
pi.over.f<-list()#
 fs<-1:5/100#
for(f.index in 1:5){#
#run.ms.f(f.index)#
	mut.density<-get.mut.density(file=paste("mssel_f10",f.index,".out",sep=""))#
	pi.over.f[[f.index]]<-mut.density#
	lines(mut.density$x,mut.density$y/(5*100*20),col=f.index,lty=1,lwd=2)#
#
	f<-fs[f.index]#
	ESF.prob.k<-sapply(intervals,function(distance){EwensDist( n=n , N =N, r=r , distance=distance , f=f )[n,]})#
	num.seg.sites.cond.i<-c(0,sapply(1:9,function(i){ sum(1/(1:i)) }))#
	num.seg.sites.r<-colSums(apply(ESF.prob.k,2,function(x){x*num.seg.sites.cond.i}))#
#
	lines(4*N*intervals*r,num.seg.sites.r,col=f.index,lty=2,lwd=2) 	#
 }#
 legend("bottomright",legend= paste("f=",fs),col=1:5,lty=1,lwd=2,cex=1.5)#
dev.off()
##install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE) {#
	options ( error = NULL )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- rep ( temp[[2]] , nrow ( frequencies ) )#
			sweep.start.forward <- ncol ( frequencies ) - sweep.start[1] #
			# if ( nrow ( frequencies ) > 1 ) {#
			fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			entry <- numeric()#
			for ( i in 1 : length ( zeros ) ){#
				if ( length ( zeros [[ i ]] ) != 0 ) {#
					entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				} else {#
					entry [ i ] <- 1#
				}#
			}#
			transit.time <- fixation.time - entry#
			new.freqs <- matrix ( 0 , nrow = reps , ncol = max ( transit.time + 1 ) )#
			for ( i in 1 : nrow ( frequencies ) ) {#
				new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			}#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
	}#
	#recover()#
	temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
	trees <- temp [[ 1 ]]#
	T.total <- temp [[ 2 ]]#
#
	#recover()#
	trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f , fixation.time = fixation.time )#
#
	hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N )#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , fixation.time = fixation.time , T.total = T.total ) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , time.factor ,  reps , no.sweep, cond.on.loss) {#
	delta.T <- 1 / ( 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
			sel <- mu.S * delta.T#
			sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
			plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
			drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
			update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 0#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			 cond.mean <- ifelse(cond.on.loss,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * 1 / ( 2 * N ),#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * 1 / ( 2 * N ) ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
if(turn.on.recovers)	recover()#
	# if ( constant.freq == FALSE ) {#
		# # if ( reps == 1 ) {#
			# # freq.trajectories <- c ( neutral.freq.matrix [ length ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ 1 : length ( sweep.freq.matrix ) ] )#
			# # #plot ( freq.trajectories , type = "l" )#
			# # freq.trajectories <- matrix ( freq.trajectories , nrow = 1 )#
			# # if ( freq.trajectories [ , ncol ( freq.trajectories ) ] == 1 ) {#
				# # conditional.freq.trajectories <- freq.trajectories#
				# # #generations <- seq ( 1 , ncol ( conditional.freq.trajectories ) , time.factor )#
				# # #conditional.freq.trajectories <- conditional.freq.trajectories [ , generations ]#
			# # } else {#
				# # cat ( "Allele lost from population.\n")#
				# # return ( )#
			# # }#
		# # } else {#
	if ( no.sweep == FALSE ) {#
		freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , 1 : ncol ( neutral.freq.matrix ) ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
		# }#
	# } else {#
		# freq.trajectories <- sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ]#
	# }#
	#recover()#
	keep.these <- freq.trajectories [ , ncol ( freq.trajectories ) ] == 1		#
	conditional.freq.trajectories <- freq.trajectories [ keep.these , ]#
	sweep.start <- ncol ( sweep.freq.matrix ) #/ time.factor#
	return ( list ( conditional.freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
# BuildTrees <- function ( coal.times , n.tips ){#
	# #recover()#
	# library(ape)#
	# trees <- list ( )#
	# for ( j in 1 : nrow ( coal.times ) ) {#
		# edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		# edge.length <- numeric ( 2 * n.tips - 2 )#
		# edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		# nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		# node.depth <- numeric ( 2 * n.tips - 1 )#
		# Nnode <- n.tips - 1#
		# tip.label <- character ( n.tips )#
		# for ( l in 1 : length ( tip.label ) ){#
			# tip.label [ l ] <- paste ( "t" , l , sep = "")#
		# }#
		# k = 1#
		# for ( i in nodes ) {#
			# extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			# coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			# coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			# edge [ coal.index , 1 ] <- i#
			# if ( i != tail ( nodes , 1 ) ) {#
				# edge [ i - 1 , 2 ] <- i#
			# }#
			# node.depth [ i ] <- coal.times [ j , k ] #
			# edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			# k = k + 1#
		# }#
		# a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		# class ( a.tree ) <- "phylo"#
		# my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		# trees [[ j ]] <- my.tree#
	# }#
	# ## note; the frequency path gets added on as trees [[ j ]] [[ 3 ]] in the top level function call immediately after returning from this function; bad writing that I should fix some day.#
	# return ( trees )#
# }#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- rev ( trees [[ j ]] [[ 3 ]] ) [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N ) {#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.right.off.background$sequence.location < k ) )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.left.off.background$sequence.location < k ) )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	# cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )#
# #	par ( mfrow = c ( 2 , 1 ) )#
	# #matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	# ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
	# stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f , stirling.numbers = stirling.numbers )#
		# }#
	# }#
	# #recover()#
	# ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )#
	# matplot ( #
		# t ( ewens.cum.probs ) , #
		# type = "n" , #
		# lty = 1 , #
		# lwd = 0.7 , #
		# col = "black" , #
		# ylab = "Cumulative Probability" , #
		# xlab = "kb" , #
		# #main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		# bty = "n"#
	# )#
	# #recover()#
	# col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	# for ( i in 1 : ( nrow ( cum.probs ) - 1 ) ) {#
			# #i = i + 1#
			# X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
			# Y.ax1 <- cum.probs [ i , X.ax ]#
			# Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			# polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	# }#
	# ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
	# apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	# #recover()#
	# expected.num.haps <- colSums ( apply ( hap.counts.by.interval , 2 , function ( x ) x * 1 : n.tips ) / (2 * length ( input ) ) , 2 )#
	# #plot ( expected.num.haps , type = "l" , lty = 1 , lwd = 1.5 , xlab = "kb" , ylab = "Expected Number of Haplotypes" , bty = "n")#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- nrow ( hap.count.freqs.by.interval )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f , stirling.numbers = stirling.numbers )#
		}#
	}#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n"#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f , stirling.numbers ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- prod ( param + 0 : ( n - 1 ) )#
	#stirling.numbers <- StirlingNumbers ( n ) [ n , ]#
	ewens.dist <- param^(1:n) * stirling.numbers / denom#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
#
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.5 , f = 0.01 , reps = 200 , n.tips = 10 , r = 10^-8 , sim.distance = 0.02 , interval.width = 1000 , no.sweep = TRUE , constant.freq = FALSE , cond.on.loss = TRUE)#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
}#
# # #
# # Let's think about inference#
# my.seqs <- temp[["trees"]][[1]][["sequence.structure"]]$right.seq#
#
# # InferenceFunction <- function ( seqs ) {#
# # if(turn.on.recovers)	recover()#
	# # hap.partitions <- apply ( seqs , 2 , function ( x ) table ( factor ( x , levels = 0 : ( nrow ( seqs ) - 1 ) ) ) )#
	# # tree <- BuildTrees ( 1 : ( nrow ( seqs ) - 1 ) )#
# # }#
#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
N=1e4#
 r = 10^-8 ; interval.width = 1000; sim.distance = 0.05 #
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )
fs<-1:5/100
f.index
f<-fs[f.index]
ESF.prob.k<-sapply(intervals,function(distance){EwensDist( n=n , N =N, r=r , distance=distance , f=f )[n,]})
n=10
ESF.prob.k<-sapply(intervals,function(distance){EwensDist( n=n , N =N, r=r , distance=distance , f=f )[n,]})
stirling.numbers<-StirlingNumbers( 10 )
stirling.numbers
ESF.prob.k<-sapply(intervals,function(distance){EwensDist( n=n , N =N, r=r , distance=distance , f=f )[n,]})
ESF.prob.k<-sapply(intervals,function(distance){EwensDist( n=n , N =N, r=r , distance=distance , f=f ,stirling.numbers=stirling.numbers)[n,]})
dim(EESF.prob.k)
dim(ESF.prob.k)
ESF.prob.k[1,]
ESF.prob.k[,1]
ESF.prob.k[,2]
ESF.prob.k[,3]
ESF.prob.k[,10000]
ESF.prob.k[,1000]
ESF.prob.k[,10]
stirling.numbers\
stirling.numbers
EwensDist( n=n , N =N, r=r , distance=intervals[1000] , f=f ,stirling.numbers=stirling.numbers)[n,]
EwensDist( n=n , N =N, r=r , distance=intervals[1000] , f=f ,stirling.numbers=stirling.numbers)
rowSums(EwensDist( n=n , N =N, r=r , distance=intervals[1000] , f=f ,stirling.numbers=stirling.numbers))
N
n
dim(stirling.numbers)
EwensDist <- function ( n , N , r , distance , f , stirling.numbers ) {#
	recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- prod ( param + 0 : ( n - 1 ) )#
	#stirling.numbers <- StirlingNumbers ( n ) [ n , ]#
	ewens.dist <- param^(1:n) * stirling.numbers / denom#
	return ( ewens.dist ) #
#
}
EwensDist( n=n , N =N, r=r , distance=intervals[1000] , f=f ,stirling.numbers=stirling.numbers)
param <- 4 * N * r * distance * f * ( 1- f )
param
N
r
distance
f
1-f
denom  <- prod ( param + 0 : ( n - 1 ) )
denom
param
param + 0 : ( n - 1 )
param^(1:n)
stirling.numbers
ewens.dist <- param^(1:n) * stirling.numbers [ n , ] / denom
ewens.dist
sum(ewens.dist)
Q
EwensDist <- function ( n , N , r , distance , f , stirling.numbers ) {#
#	recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- prod ( param + 0 : ( n - 1 ) )#
	#stirling.numbers <- StirlingNumbers ( n ) [ n , ]#
	ewens.dist <- param^(1:n) * stirling.numbers [ n , ] / denom#
	return ( ewens.dist ) #
#
}
EwensDist( n=n , N =N, r=r , distance=intervals[1000] , f=f ,stirling.numbers=stirling.numbers)
8/38
get.freq.spec<-function(n,num.sims, path){#
	#recover()#
	a<-system(paste("grep segsites ","Sims/myseqdata",sep=""),intern=TRUE)#
	seg.sites<-sapply(a,function(b){as.numeric(strsplit(b,":")[[1]][2])})#
	polymorph<- seg.sites>0#
	seq.lines<-c(0,cumsum(polymorph*n)[-length(polymorph)])	#
	freq.specs<-sapply(0:(num.sims-1),function(iter){		#
		if(!polymorph[1+iter]) {freq.spec<-rep(0,n);return(freq.spec)}#
		positions<-read.table(paste(path, "Sims/myseqdata",sep=""),skip=5+4*iter+seq.lines[iter+1],nrow=1)#
#		print(positions[1])#
#		if(length(positions)==1){freq.spec<-rep(0,n);return(freq.spec)}		#
		seqs.raw<-scan(paste(path, "Sims/myseqdata",sep=""),skip=6+4*iter+seq.lines[iter+1],nline=n,what=character(),quiet=TRUE)#
		seqs<-sapply(seqs.raw,function(seq){as.numeric(strsplit(seq,"")[[1]])})#
		colnames(seqs)<-NULL#
		seqs<-t(seqs)#
		these.pos<-positions[-1]>0.5   ###why the -1 here? oh because positions has label#
		if(sum(these.pos)==0){freq.spec<-rep(0,n);return(freq.spec)}#
		seqs<-seqs[,these.pos] ##throw out first 1/2 of seq.#
		if(sum(these.pos)==1){freq.spec<-(1:n==sum(seqs)); return(freq.spec)}#
		mut.freq<-colSums(seqs)#
		freq.spec<- sapply(1:n,function(i){sum(mut.freq==i)})#
		return(freq.spec)#
	})#
return(freq.specs)#
}
path = "~/Dropbox/Linked_selection_models/Soft_sweeps_coal/LinkedSelection/"
temp<-get.freq.specfunction(n=10,num.sims=10, path=path)
temp<-get.freq.spec(n=10,num.sims=10, path=path)
setwd(path)
temp<-get.freq.spec(n=10,num.sims=10, path=path)
temp<-get.freq.spec(n=10,num.sims=1000, path=path)
dim(temp)
rowSums(temp)
rowSums(temp)/sum(temp)
1/(1:9)/sum(1/(1:9))
temp<-get.freq.spec(n=10,num.sims=1000, path=path)
system ( paste ( "mssel " , 10 , " " , 1000 , " 0 " , 10 , " Sims/my.standing" , "." , f.lab , "." , s.lab , "." , N, "." ,ext, ".traj 0 -t 200. -r " , recom , " 2 >",path, "Sims/myseqdata" , sep = "" ) )
getwd()
setwd("Scripts/msseldir/")
system ( paste ( "./mssel " , 10 , " " , 500 , " 0 " , 10 , " my.standing5.traj 0 -t 200. -r " , 300 , " 2 >",path, "Sims/myseqdata" , sep = "" ) )
temp.2<-get.freq.spec(n=10,num.sims=500, path=path)
setwd("../../")
temp.2<-get.freq.spec(n=10,num.sims=500, path=path)
rowSums(temp.2)/sum(temp.2)
1/(1:9)/sum(1/(1:9))
system ( paste ( "./mssel " , 10 , " " , 500 , " 0 " , 10 , " my.standing5.traj 0 -t 200. -r " , 400 , " 2 >",path, "Sims/myseqdata" , sep = "" ) )
setwd("Scripts/msseldir/")
system ( paste ( "./mssel " , 10 , " " , 500 , " 0 " , 10 , " my.standing5.traj 0 -t 200. -r " , 400 , " 2 >",path, "Sims/myseqdata" , sep = "" ) )
setwd("../../")
temp.3<-get.freq.spec(n=10,num.sims=500, path=path)
rowSums(temp.3)/sum(temp.3)
selfing.rate=0.05#
#
	D<-matrix(1/2,nrow=2,ncol=3,dimnames=list(c("1 or 2","3"),c("12","13","23"))) ##entries are drive coeff of the 2nd allele listed against the 1st.#
	d.range<-seq(0.5,1,length=200)#
	s3.range<-seq(0,1,length=200)#
	invasion.grid<-sapply(s3.range,function(s3){#
		sapply(d.range,function(d){#
			test.invasion.self.prop(d=d,s.het=0,s.hom=s3,selfing.rate=selfing.rate)#
		})#
	})#
	invasion.lines.s3.cutoff<-s3.range[apply(invasion.grid,1,function(x){max(which(x))})]#
	simple.fixation.grid<-sapply(s3.range,function(s3){#
		sapply(d.range,function(d){#
			test.fixation.of.simple.driver(d=d,s.het=0,s.hom=s3,selfing.rate=selfing.rate)#
		})#
	})#
	fixation.lines.s3<-s3.range[apply(simple.fixation.grid,1,function(x){max(which(x))})]#
#
	simple.invasion.grid<-sapply(s3.range,function(s3){#
		sapply(d.range,function(d){#
			test.fixation.of.simple.driver(d=d,s.het=0,s.hom=s3,x=0.01,selfing.rate=selfing.rate)#
		})#
	})#
	simple.invasion.lines.s3<-s3.range[apply(simple.invasion.grid,1,function(x){max(which(x))})]
###BASIC FUNCTIONS TO SETUP AND ITERATE DRIVE MODEL#
#
iterate.1.locus.drive<-function(s.array,num.iterations,female.transmission.probs,my.geno.freqs,initialize.allele.freqs=c(0.999,0.001,0),selfing.rate=0){#
	geno.freqs<-rep(NA,6)#
	names(geno.freqs)<-geno.names#
#
	my.freqs<-numeric()#
	if(missing(my.geno.freqs)){#
       #     print("running 2 allele system to stablity")#
		allele.freqs<-initialize.allele.freqs	#
		names(allele.freqs)<-c("1","2","3")	#
		geno.freqs["11"]<-allele.freqs["1"]^2#
		geno.freqs["22"]<-allele.freqs["2"]^2#
		geno.freqs["33"]<-allele.freqs["3"]^2#
#
		geno.freqs["12"]<-2*allele.freqs["1"]*allele.freqs["2"]#
		geno.freqs["13"]<-2*allele.freqs["1"]*allele.freqs["3"]#
		geno.freqs["23"]<-2*allele.freqs["3"]*allele.freqs["2"]#
		stopifnot(sum(geno.freqs)>0.9999999999 & sum(geno.freqs)< 1.0000000001)#
#
	}else{#
		print("initiating from my.geno.freqs")#
		geno.freqs[c("11","12","22")]<-my.geno.freqs[["geno.freqs"]][nrow(my.geno.freqs[["geno.freqs"]]),c("11","12","22")]*.99#
		geno.freqs[c("13","23")]<-my.geno.freqs[["allele.freqs"]][nrow(my.geno.freqs[["geno.freqs"]]),1:2]*.99*.01#
		geno.freqs["33"]<-.01^2#
		}#
#
	my.freqs<-rbind(my.freqs,geno.freqs)#
#
	for(i in 1:num.iterations){#
	#selection#
		geno.freqs["11"]<-geno.freqs["11"] * (1-s.array["11"])#
		geno.freqs["12"]<-geno.freqs["12"] * (1-s.array["12"])#
		geno.freqs["13"]<-geno.freqs["13"] * (1-s.array["13"])#
#
		geno.freqs["22"]<-geno.freqs["22"] * (1-s.array["22"])#
		geno.freqs["23"]<-geno.freqs["23"] * (1-s.array["23"])#
#
		geno.freqs["33"]<-geno.freqs["33"] * (1-s.array["33"])#
		geno.freqs<-geno.freqs/sum(geno.freqs)	#
#
		geno.freqs.array<-outer(rep(geno.freqs,each=2),rep(geno.freqs,each=2),"*")  ##one for each allele#
#
	geno.freqs.array<-(1-selfing.rate) * geno.freqs.array  ##selfing  (1-s) * pi *pj#
	diag(geno.freqs.array)<-diag(geno.freqs.array) +  selfing.rate * rep(geno.freqs,each=2)  #selfing  (1-s) * pi *pj + delta_{ij} s pi#
#
	##transmission#
		tot.trans<-geno.freqs.array*female.transmission.probs*0.5#
#
		new.geno.freqs<-rep(NA,6)	#
		names(new.geno.freqs)<-geno.names#
		new.geno.freqs["11"]<-sum(tot.trans[transmitted.allele==1,transmitted.allele==1])#
		new.geno.freqs["22"]<-sum(tot.trans[transmitted.allele==2,transmitted.allele==2])#
		new.geno.freqs["33"]<-sum(tot.trans[transmitted.allele==3,transmitted.allele==3])#
#
		new.geno.freqs["12"]<-sum(tot.trans[transmitted.allele==1,transmitted.allele==2])+sum(tot.trans[transmitted.allele==2,transmitted.allele==1])#
		new.geno.freqs["13"]<-sum(tot.trans[transmitted.allele==1,transmitted.allele==3])+sum(tot.trans[transmitted.allele==3,transmitted.allele==1])#
		new.geno.freqs["23"]<-sum(tot.trans[transmitted.allele==2,transmitted.allele==3])+sum(tot.trans[transmitted.allele==3,transmitted.allele==2])#
#
		geno.freqs<-new.geno.freqs#
		my.freqs<-rbind(my.freqs,geno.freqs)#
#
	}#
#
	freq.1<-my.freqs[,"11"]+0.5*rowSums(my.freqs[,c("12","13")])#
	freq.2<-my.freqs[,"22"]+0.5*rowSums(my.freqs[,c("12","23")])#
	freq.3<-my.freqs[,"33"]+0.5*rowSums(my.freqs[,c("13","23")])#
	geno.and.allele.freqs<-list()#
	geno.and.allele.freqs[["geno.freqs"]]<-my.freqs#
	geno.and.allele.freqs[["allele.freqs"]]<-cbind(freq.1,freq.2,freq.3)#
#
	return(geno.and.allele.freqs) #
 }#
  make.sperm.dep.female.transmission.prob<-function(D){#
 	geno.names<-c("11", "12","13", "22", "23", "33")#
	transmission.probs<-matrix(0.5,nrow=12,ncol=12)#
	rownames(transmission.probs)<-rep(geno.names,each=2)#
	colnames(transmission.probs)<-rep(geno.names,each=2)#
	transmitted.allele<-c(1,1,1,2,1,3,2,2,2,3,3,3)#
	##sperm alleles 1 and 2 allow: 2 and 3 female hets 12 to drive at D1#
	transmission.probs[transmitted.allele %in% 1:2,colnames(transmission.probs) =="12" & transmitted.allele == 1] <- 1-D["1 or 2","12"]#
	transmission.probs[transmitted.allele %in% 1:2,colnames(transmission.probs) =="12" & transmitted.allele == 2] <- D["1 or 2","12"]#
	##sperm alleles 1 and 2 allow: 2 and 3 female hets 12 to drive at D13#
	transmission.probs[transmitted.allele %in% 1:2,colnames(transmission.probs) =="13" & transmitted.allele == 1] <- 1-D["1 or 2","13"]#
	transmission.probs[transmitted.allele %in% 1:2,colnames(transmission.probs) =="13" & transmitted.allele == 3] <- D["1 or 2","13"]#
	##sperm allele 3 allow: 2 and 3 hets 12 and 13 to drive at D2#
	transmission.probs[transmitted.allele %in% 3,colnames(transmission.probs) == "13" & transmitted.allele == 1] <- 1-D["3","13"]#
	transmission.probs[transmitted.allele %in% 3,colnames(transmission.probs) =="13" & transmitted.allele == 3] <- D["3","13"]#
	transmission.probs[transmitted.allele %in% 3,colnames(transmission.probs) == "12" & transmitted.allele == 1] <- 1-D["3","12"]#
	transmission.probs[transmitted.allele %in% 3,colnames(transmission.probs) =="12" & transmitted.allele == 2] <- D["3","12"]#
	transmission.probs[transmitted.allele %in% 1:2,colnames(transmission.probs) == "23" & transmitted.allele == 2] <- 1-D["1 or 2","23"]#
	transmission.probs[transmitted.allele %in% 1:2,colnames(transmission.probs) =="23" & transmitted.allele == 3] <- D["1 or 2","23"]#
	transmission.probs[transmitted.allele %in% 3,colnames(transmission.probs) == "23" & transmitted.allele == 2] <- 1-D["3","23"]#
	transmission.probs[transmitted.allele %in% 3,colnames(transmission.probs) =="23" & transmitted.allele == 3] <- D["3","23"]#
transmission.probs#
}#
make.male.geno.dep.female.transmission.prob<-function(D){#
 	geno.names<-c("11", "12","13", "22", "23", "33")#
	transmission.probs<-matrix(0.5,nrow=12,ncol=12)#
	rownames(transmission.probs)<-rep(geno.names,each=2)#
	colnames(transmission.probs)<-rep(geno.names,each=2)#
	transmitted.allele<-c(1,1,1,2,1,3,2,2,2,3,3,3)#
	transmission.probs[,colnames(transmission.probs) =="12" & transmitted.allele == 1] <- 1-D["1 or 2","12"]#
	transmission.probs[,colnames(transmission.probs) =="12" & transmitted.allele == 2] <- D["1 or 2","12"]#
#
	transmission.probs[,colnames(transmission.probs) =="13" & transmitted.allele == 1] <- 1-D["1 or 2","13"]#
	transmission.probs[,colnames(transmission.probs) =="13" & transmitted.allele == 3] <- D["1 or 2","13"]#
#
	transmission.probs[,colnames(transmission.probs) == "23" & transmitted.allele == 2] <- 1-D["1 or 2","23"]#
	transmission.probs[,colnames(transmission.probs) =="23" & transmitted.allele == 3] <- D["1 or 2","23"]#
	##males carrying allele 3 alter rate of female drive in dominant fashion. #
	male.geno.3<-grep("3",rownames(transmission.probs))#
	transmission.probs[male.geno.3,colnames(transmission.probs) == "13" & transmitted.allele == 1] <- 1-D["3","13"]#
	transmission.probs[male.geno.3,colnames(transmission.probs) =="13" & transmitted.allele == 3] <- D["3","13"]#
#
	transmission.probs[male.geno.3,colnames(transmission.probs) == "12" & transmitted.allele == 1] <- 1-D["3","12"]#
	transmission.probs[male.geno.3,colnames(transmission.probs) =="12" & transmitted.allele == 2] <- D["3","12"]#
#
	transmission.probs[male.geno.3,colnames(transmission.probs) == "23" & transmitted.allele == 2] <- 1-D["3","23"]#
	transmission.probs[male.geno.3,colnames(transmission.probs) =="23" & transmitted.allele == 3] <- D["3","23"]#
	recover()#
transmission.probs#
}#
make.male.geno.dep.female.transmission.prob.w.dom<-function(D){#
 	geno.names<-c("11", "12","13", "22", "23", "33")#
	transmission.probs<-matrix(0.5,nrow=12,ncol=12)#
	rownames(transmission.probs)<-rep(geno.names,each=2)#
	colnames(transmission.probs)<-rep(geno.names,each=2)#
	transmitted.allele<-c(1,1,1,2,1,3,2,2,2,3,3,3)#
	transmission.probs[,colnames(transmission.probs) =="12" & transmitted.allele == 1] <- 1-D["1 or 2","12"]#
	transmission.probs[,colnames(transmission.probs) =="12" & transmitted.allele == 2] <- D["1 or 2","12"]#
#
	transmission.probs[,colnames(transmission.probs) =="13" & transmitted.allele == 1] <- 1-D["1 or 2","13"]#
	transmission.probs[,colnames(transmission.probs) =="13" & transmitted.allele == 3] <- D["1 or 2","13"]#
#
	transmission.probs[,colnames(transmission.probs) == "23" & transmitted.allele == 2] <- 1-D["1 or 2","23"]#
	transmission.probs[,colnames(transmission.probs) =="23" & transmitted.allele == 3] <- D["1 or 2","23"]#
	##males carrying allele 3 alter rate of female drive in dominant fashion. #
	male.heterozy<-rownames(transmission.probs) %in%  c("13","23")#
	male.homozy<-rownames(transmission.probs) =="33"#
	transmission.probs[male.heterozy,colnames(transmission.probs) == "13" & transmitted.allele == 1] <- 1-D["3.het","13"]#
	transmission.probs[male.heterozy,colnames(transmission.probs) =="13" & transmitted.allele == 3] <- D["3.het","13"]#
#
	transmission.probs[male.heterozy,colnames(transmission.probs) == "12" & transmitted.allele == 1] <- 1-D["3.het","12"]#
	transmission.probs[male.heterozy,colnames(transmission.probs) =="12" & transmitted.allele == 2] <- D["3.het","12"]#
#
	transmission.probs[male.heterozy,colnames(transmission.probs) == "23" & transmitted.allele == 2] <- 1-D["3.het","23"]#
	transmission.probs[male.heterozy,colnames(transmission.probs) =="23" & transmitted.allele == 3] <- D["3.het","23"]#
#
##homozy. male effect#
	transmission.probs[male.homozy,colnames(transmission.probs) == "13" & transmitted.allele == 1] <- 1-D["3","13"]#
	transmission.probs[male.homozy,colnames(transmission.probs) =="13" & transmitted.allele == 3] <- D["3","13"]#
#
	transmission.probs[male.homozy,colnames(transmission.probs) == "12" & transmitted.allele == 1] <- 1-D["3","12"]#
	transmission.probs[male.homozy,colnames(transmission.probs) =="12" & transmitted.allele == 2] <- D["3","12"]#
#
	transmission.probs[male.homozy,colnames(transmission.probs) == "23" & transmitted.allele == 2] <- 1-D["3","23"]#
	transmission.probs[male.homozy,colnames(transmission.probs) =="23" & transmitted.allele == 3] <- D["3","23"]#
#
#	recover()#
transmission.probs#
}#
run.iterations<-function(D,s.array,sperm.or.geno.dependent,num.iter=4000,plot.initial.rise=FALSE){#
	if(sperm.or.geno.dependent=="sperm"){ female.transmission.probs<-make.sperm.dep.female.transmission.prob(D)}#
	if(sperm.or.geno.dependent=="geno"){ female.transmission.probs<-make.male.geno.dep.female.transmission.prob(D)}#
	old.geno.freqs<-iterate.1.locus.drive(s.array,num.iterations=num.iter,female.transmission.probs=female.transmission.probs)#
	new.geno.freqs<-iterate.1.locus.drive(s.array=s.array,num.iterations=num.iter,female.transmission.probs=female.transmission.probs,my.geno.freqs=old.geno.freqs)#
	if(plot.initial.rise) new.geno.freqs[["allele.freqs"]]<-rbind(old.geno.freqs[["allele.freqs"]],new.geno.freqs[["allele.freqs"]])#
	plot.freqs(new.geno.freqs)#
}#
directory<-"~/Dropbox/Ideas/Om/scripts/"#
geno.names<-c("11", "12","13", "22", "23", "33")#
transmitted.allele<-c(1,1,1,2,1,3,2,2,2,3,3,3)#
####FUNCTIONS TO TEST WHETHER DRIVER SPREADS#
#### test.invasion.self.prop used to construct invasion diagrams, allele intro'd at freq. x#
#### checks whether it increases in frequency#
test.invasion.self.prop<-function(d,s.het,s.hom,x=.001,steps=10,sperm.or.male="sperm",selfing.rate=0){#
	s.array<-rep(0,6)#
	names(s.array)<-c("11","12","13","23","22","33")#
	s.array["13"]<- s.het#
	s.array["33"]<- s.hom#
	D<-matrix(1/2,nrow=2,ncol=3,dimnames=list(c("1 or 2","3"),c("12","13","23"))) ##entries are drive coeff of the 2nd #
	D["1 or 2","12"]<-0.5#
	D["1 or 2","13"]<-0.5#
	D["3","12"]<-.5#
	D["3","13"]<-d#
	D["1 or 2","23"]<- 1-0.5#
	D["3","23"]<-0.5#
	stopifnot(sperm.or.male=="sperm" | sperm.or.male=="male")#
	if(sperm.or.male=="sperm"){ female.transmission.probs<-make.sperm.dep.female.transmission.prob(D)}#
	if(sperm.or.male=="male"){ female.transmission.probs<-make.male.geno.dep.female.transmission.prob(D) }#
	old.geno.freqs<-iterate.1.locus.drive(s.array,num.iterations=steps,female.transmission.probs=female.transmission.probs,initialize.allele.freqs =c(1-x, 0,x),selfing.rate=selfing.rate)#
#recover()#
	invading<-old.geno.freqs[["allele.freqs"]][steps,3]>old.geno.freqs[["allele.freqs"]][1,3]#
	return(invading)#
}#
#
test.fixation.of.simple.driver<-function(d,s.het,s.hom,x=.999,steps=10,selfing.rate=0){#
	s.array<-rep(0,6)#
	names(s.array)<-c("11","12","13","23","22","33")#
	s.array["12"]<- s.het#
	s.array["22"]<- s.hom#
	D<-matrix(1/2,nrow=2,ncol=3,dimnames=list(c("1 or 2","3"),c("12","13","23"))) ##entries are drive coeff of the 2nd #
	D["1 or 2","12"]<- d#
	D["1 or 2","13"]<-0.5#
	D["3","12"]<- 0.5#
	D["3","13"]<- 0.5#
	D["1 or 2","23"]<- 1-0.5#
	D["3","23"]<-0.5#
	female.transmission.probs<-make.sperm.dep.female.transmission.prob(D)#
	old.geno.freqs<-iterate.1.locus.drive(s.array=s.array,num.iterations=steps,female.transmission.probs=female.transmission.probs,initialize.allele.freqs =c(1-x, x,0),selfing.rate=selfing.rate)#
	fixing<-old.geno.freqs[["allele.freqs"]][steps,2]>old.geno.freqs[["allele.freqs"]][1,2]#
	return(fixing)#
}
selfing.rate=0.05#
#
	D<-matrix(1/2,nrow=2,ncol=3,dimnames=list(c("1 or 2","3"),c("12","13","23"))) ##entries are drive coeff of the 2nd allele listed against the 1st.#
	d.range<-seq(0.5,1,length=200)#
	s3.range<-seq(0,1,length=200)#
	invasion.grid<-sapply(s3.range,function(s3){#
		sapply(d.range,function(d){#
			test.invasion.self.prop(d=d,s.het=0,s.hom=s3,selfing.rate=selfing.rate)#
		})#
	})#
	invasion.lines.s3.cutoff<-s3.range[apply(invasion.grid,1,function(x){max(which(x))})]#
	simple.fixation.grid<-sapply(s3.range,function(s3){#
		sapply(d.range,function(d){#
			test.fixation.of.simple.driver(d=d,s.het=0,s.hom=s3,selfing.rate=selfing.rate)#
		})#
	})#
	fixation.lines.s3<-s3.range[apply(simple.fixation.grid,1,function(x){max(which(x))})]#
#
	simple.invasion.grid<-sapply(s3.range,function(s3){#
		sapply(d.range,function(d){#
			test.fixation.of.simple.driver(d=d,s.het=0,s.hom=s3,x=0.01,selfing.rate=selfing.rate)#
		})#
	})#
	simple.invasion.lines.s3<-s3.range[apply(simple.invasion.grid,1,function(x){max(which(x))})]
plot(d.range,simple.invasion.lines.s3)
plot(d.range,simple.invasion.lines.s3,type="l")
lines(d.range,invasion.lines.s3.cutoff,type="l",col="red")
lines(d.range,fixation.lines.s3,type="l",col="green")
fixation.lines.s3
test.fixation.of.simple.driver(d=0.7,s.het=0,s.hom=0.01,selfing.rate=selfing.rate)
lines(d.range,(2*d.range- 1)/(4*d.range),col="green",lwd=3,lty=2) ##self prom. fixes below this line
plot(d.range,simple.invasion.lines.s3,type="l")
lines(d.range,fixation.lines.s3,type="l",col="green")
lines(d.range,invasion.lines.s3.cutoff,type="l",col="red")
lines(d.range,(2*d.range- 1)/(4*d.range),col="green",lwd=3,lty=2) ##self prom. fixes below this line
fixation.grid<-sapply(s3.range,function(s3){#
		sapply(d.range,function(d){#
			test.invasion.self.prop(d=d,s.het=0,s.hom=s3,x=0.999,selfing.rate=selfing.rate)#
		})#
	})#
	sp.fixation.lines.s3.cutoff<-s3.range[apply(fixation.grid,1,function(x){max(which(x))})]   ##below these s values self promotor can invade.
sp.fixation.lines.s3.cutoff
plot(d.range,simple.invasion.lines.s3,type="l")#
lines(d.range,invasion.lines.s3.cutoff,type="l",col="red")	#
lines(d.range,(2*d.range- 1)/(4*d.range),col="green",lwd=3,lty=2) ##self prom. fixes below this line
plot(d.range,simple.invasion.lines.s3,type="l",xlab="Drive, d",ylab="Homozyg. selection coeff")#
lines(d.range,invasion.lines.s3.cutoff,type="l",col="red")	#
lines(d.range,(2*d.range- 1)/(4*d.range),col="green",lwd=3,lty=2) ##self prom. fixes below this line
dev.copy2pdf(file-"~/Downloads/fig_for_Yaniv.pdf")
dev.copy2pdf(file="~/Downloads/fig_for_Yaniv.pdf")
700e3/4.8e6
10
.25/10
SQRT(.25/10)
sqrt(.25/10)
sqrt(.1/10)
library(devtools)#
install_github("fmichonneau/rncl")#
install_github("fmichonneau/rotl")
install.packages(devtools)
install.packages("devtools")
library(devtools)#
install_github("fmichonneau/rncl")#
install_github("fmichonneau/rotl")
