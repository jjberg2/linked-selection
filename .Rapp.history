<<<<<<< HEAD
cia<-read.table("~/Downloads/rawdata_2147.txt",as.is=TRUE)
cia
cia<-read.table("~/Downloads/rawdata_2147.txt",as.is=TRUE)
cia<-read.table("~/Downloads/rawdata_2147.txt",as.is=TRUE,sep="\t")
cia
cia<-read.table("~/Downloads/rawdata_2147.txt",as.is=TRUE,fill=TRUE)
cia<-read.table("~/Dropbox/postdocs/Peter/Spatial_adaptation/cia_factbook_areas",as.is=TRUE,fill="TRUE")
cia<-read.table("~/Dropbox/postdocs/Peter/Spatial_adaptation/cia_factbook_areas",as.is=TRUE)
cia<-read.table("~/Dropbox/postdocs/Peter/Spatial_adaptation/cia_factbook_areas",as.is=TRUE,sep=" ")
cia<-read.table("~/Downloads/rawdata_2147_new.txt",as.is=TRUE,fill=TRUE)
cia<-read.table("~/Downloads/rawdata_2147_new.txt",as.is=TRUE)
cia<-read.table("~/Downloads/rawdata_2147_new.txt",as.is=TRUE,sep="\t")
cia
cia<-read.csv("~/Downloads/rawdata_2147_new.csv",as.is=TRUE)
cia
cia<-read.csv("~/Downloads/rawdata_2147_new.csv",as.is=TRUE,head=FALSE)
cia
malaria
malaria[1,]
malaria$V1
malaria<-read.csv("~/Dropbox/postdocs/Peter/Spatial_adaptation/malaria_present.csv",as.is=TRUE)
malaria
malaria<-read.csv("~/Dropbox/postdocs/Peter/Spatial_adaptation/malaria_present.csv",as.is=TRUE,head=FALSE)
malaria
malaria<-malaria[-1,]
malaria
malaria$V1
cia
mean(cia$V2 %in% malaria$V1)
malaria<-read.csv("~/Dropbox/postdocs/Peter/Spatial_adaptation/malaria_present.csv",as.is=TRUE,head=FALSE)
mean(cia$V2 %in% malaria$V1)
mean(malaria$V1 %in% cia$V2)
malaria[1,]
malaria<-malaria[-1,]
malaria[1,]
unique(malaria$V2)
malaria.eurasia<-malaria[malariaV2 %in% c("Middle-East","SoutheastAsia","Euroasia","EasternAsia","CentralAsia","CentralAsia","Transcaucasia")]
malaria.eurasia<-malaria[malaria$V2 %in% c("Middle-East","SoutheastAsia","Euroasia","EasternAsia","CentralAsia","CentralAsia","Transcaucasia")]
malaria.eurasia<-malaria[malaria$V2 %in% c("Middle-East","SoutheastAsia","Euroasia","EasternAsia","CentralAsia","CentralAsia","Transcaucasia"),]
malaria[malaria$V2 =="Pacific",]
mean(malaria.eurasia$V1 %in% cia$V2)
malaria.eurasia[!(malaria.eurasia$V1 %in% cia$V2),]
malaria.eurasia
malaria.eurasia[!(malaria.eurasia$V1 %in% cia$V2),]
cia[1,]
sum(cia$V2 == "Korea North")
sum(cia$V2 == "Korea South")
sum(cia$V2 == "Burma")
sum(cia$V2 == "Syria")
sum(cia$V2 == "Korea South")
sum(cia$V2 == "Viet Nam")
sum(cia$V2 == "Viet nam")
sum(cia$V2 == "Vietnam")
sum(cia$V2 == "Saudi Arabia")
missing.these<-c("Laos","Korea North", "Korea South","Burma","Syria","Vietnam","Saudi Arabia")#
#
cia$V2[ cia$V2 %in% malaria.eurasia$V1 |   cia$V2 %in% missing.these]
missing.these<-c("Laos","Korea North", "Korea South","Burma","Syria","Vietnam","Saudi Arabia")#
#
cia$V3[ cia$V2 %in% malaria.eurasia$V1 |   cia$V2 %in% missing.these]
sum(missing.these<-c("Laos","Korea North", "Korea South","Burma","Syria","Vietnam","Saudi Arabia")#
#
cia$V3[ cia$V2 %in% malaria.eurasia$V1 |   cia$V2 %in% missing.these])
missing.these<-c("Laos","Korea North", "Korea South","Burma","Syria","Vietnam","Saudi Arabia")#
#
sum(cia$V3[ cia$V2 %in% malaria.eurasia$V1 |   cia$V2 %in% missing.these])
22529939/1e6
sqrt(22529939/15)
(22529939-9596960)/1e6
sqrt((22529939-9596960)/15)
sqrt((22529939-9596960-2149690)/15)
sqrt((22529939-2149690)/15)
515*1e-8
(22529939-9596960-2149690)/1e6
charLength <- function (mu, rho, sb, sd, sigma) {#
    # the characteristic length, which is#
    #   the positive solution to#
    #   lambda0 x^2 + lambda x^3 / v = 1/pi#
    if (sd==1) {#
        return( list( value=(sigma/(rho*mu*pi*sqrt(2*sb)))^(1/3), roots=NA) )#
    } else if (sd==0) {#
        return( list( value=0, roots=NA) )#
    } else {#
        roots <-  polyroot( c(-1/pi, 0, 2*mu*rho*sb/log(1/(1-sd)), sqrt(2*sb)*mu*rho / sigma ) )#
        ii <- which.max(Re(roots[Im(roots)<10*.Machine$double.eps]))#
        # sanity check#
        if (length(ii)==0) { stop("No real roots for characteristic length?") }#
        return( list(value=Re(roots[ii]), roots=roots) )#
    }#
}
charLength(mu=5e-6, rho=2, sb=0.2, sd=0.4, sigma=50)
charLength(mu=5e-6, rho=2, sb=0.2, sd=0.4, sigma=100)
charLength(mu=5e-6, rho=2, sb=0.2, sd=0.8, sigma=100)
charLength(mu=5e-6, rho=0.2, sb=0.2, sd=0.8, sigma=100)
charLength(mu=1.5e-6, rho=2, sb=0.2, sd=0.4, sigma=100)
charLength(mu=1.5e-6, rho=2, sb=0.04, sd=0.1, sigma=50)
charLength(mu=5e-6, rho=2, sb=0.25, sd=0.5, sigma=50)
charLength(mu=5e-6, rho=2, sb=0.25, sd=0.5, sigma=10)
charLength(mu=5e-6, rho=2, sb=0.25, sd=0.5, sigma=200)
charLength(mu=5e-6, rho=2, sb=0.25, sd=0.1, sigma=200)
charLength(mu=5e-6, rho=2, sb=0.05, sd=0.1, sigma=200)
charLength(mu=5e-6, rho=2, sb=0.05, sd=0.2, sigma=200)
charLength(mu=5e-6, rho=2, sb=0.05, sd=0.3, sigma=200)
sqrt((22529939-2149690)/40)
sqrt((22529939-9596960-2149690)/40)
charLength(mu=5e-6, rho=2, sb=0.05, sd=0.3, sigma=20)
charLength(mu=5e-6, rho=2, sb=0.05, sd=0.3, sigma=20)$value
mu=5e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.3,length=50); sigma=20; charlength.sd<-sapply(sd, function (sigma) { charLength(mu,rho,sb,sd,sigma)$value } )
mu=5e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.3,length=50); sigma=20; charlength.sd<-sapply(sdvals, function (sigma) { charLength(mu,rho,sb,sd,sigma)$value } )
mu=5e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.3,length=50); sigma=20; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )
plot(sdvals,charlength.sd)
mu=5e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=20; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )
plot(sdvals,charlength.sd)
mu=5e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )
plot(sdvals,charlength.sd)
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )
plot(sdvals,charlength.sd)
plot(sdvals,charlength.sd,tyle="l")
plot(sdvals,charlength.sd,type="l")
charLength(mu,rho,sb,sd=1,sigma)$value
charLength(mu,rho,sb,sd=100,sigma)$value
charLength(mu,rho,sb,sd=0.99,sigma)$value
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )
plot(sdvals,charlength.sd,type="l")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )
lines(sdvals,charlength.sd,type="l")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=10; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )
lines(sdvals,charlength.sd,type="l",col="red")
require(devtools)#
devtools::install_github("wesanderson","karthik")
install.packages("devtools")
require(devtools)#
devtools::install_github("wesanderson","karthik")
plot(sdvals,charlength.sd,type="l")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,500))#
#
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l")#
#
 mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); sigma=10; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd)
plot(sdvals,charlength.sd)
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,500),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.05,0.5,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.5,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")
newCharLength <- function (mu, rho, sb, sd, sigma) {#
    # the characteristic length *if only looking at new mutations*, which is#
    #     x = ( v/(pi lambda) )^(1/3)#
    return( list( value=(sigma/(rho*mu*pi*sqrt(2*sb)))^(1/3), roots=NA) )#
}
charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)})
newCharLength <- function (mu, rho, sb, sd, sigma) {#
    # the characteristic length *if only looking at new mutations*, which is#
    #     x = ( v/(pi lambda) )^(1/3)#
    return( list( value=(sigma/(rho*mu*pi*sqrt(2*sb)))^(1/3), roots=NA) )#
}#
#
oldCharLength <-  function (mu, rho, sb, sd, sigma) {#
    # the characteristic length *if only looking at standing variation*, which is#
    #     x = ( 1/(pi lambda0) )^(1/2)#
    if (sd==0) {#
        return( list( value=0, roots=NA) )#
    } else {#
        return( list( value=(2*mu*rho*sb/log(1/(1-sd)))^(-1/2), roots=NA) )#
    }#
}
charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)})
lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
length(charlength.standing.only)
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,1000),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,1500),lwd=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd, sigma)$value,col="black")#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd, sigma)$value,col="red")#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd, sigma)$value,col="orange")#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black")#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red")#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="orange")#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="purple")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black")#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red")#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="purple")#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,400),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black",lwd=2,lty=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red",lwd=2,lty=2)#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="purple",lwd=2,lty=2)#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.01,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black",lwd=2,lty=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red",lwd=2,lty=2)#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="purple",lwd=2,lty=2)#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.0001,0.3,length=50); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black",lwd=2,lty=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red",lwd=2,lty=2)#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="purple",lwd=2,lty=2)#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.0001,0.3,length=500); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black",lwd=2,lty=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red",lwd=2,lty=2)#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="purple",lwd=2,lty=2)#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange")
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.0001,0.3,length=500); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black",lwd=2,lty=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red",lwd=2,lty=2)#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="purple",lwd=2,lty=2)#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange",lty=3)
70*1e-8
140*1e-8
mu=1e-6; rho=2; sb=0.2; sdvals=seq(0.0001,0.3,length=500); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black",lwd=2,lty=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red",lwd=2,lty=2)#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="purple",lwd=2,lty=2)#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange",lty=3)
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.0001,0.3,length=500); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2)#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="black",lwd=2,lty=2)#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col="red")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="red",lwd=2,lty=2)#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col="purple")#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col="purple",lwd=2,lty=2)#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
#
 lines(sdvals,charlength.standing.only ,lwd=2,col="orange",lty=3)
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.0001,0.3,length=500); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2,col=my.col[1])#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col=my.col[1],lwd=2,lty=2)  ##new mut. only#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col=my.col[2])#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col=my.col[2],lwd=2,lty=2)  ##new mut. only#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col=my.col[3])#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col=my.col[3],lwd=2,lty=2) ##new mut. only#
 ##contribution of standing var only#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
 lines(sdvals,charlength.standing.only ,lwd=2,col=my.col[4],lty=3)#
 legend("topleft",)
expected.freq.times.standing<-function(n,N,r,distance,f){#
#
my.StirlingNumbers<-StirlingNumbers(n) #
ESF.prob.k<-EwensDist( n=n , N =N, r=r , distance=distance , f=f ,stirling.numbers=my.StirlingNumbers)    ### is of form [n,k]#
#
#my.StirlingNumbers<-StirlingNumbers(n)    ##Usigned Stirling numbers of 1st kind. ma#
expected.t.l<-rep(NA,n)#
for(l in 1:(n-1)){#
#
	freq.specs<-sapply(1:n,function(k){#
		freq.spec<-rep(NA,n)#
		freq.spec[1:k]<-(1/(1:k))#
		return(freq.spec)#
	})#
	freq.specs<-t(freq.specs)#
	recover()#
	terms.in.sum<-rep(0,n)#
	for(k in 2:n){   ##runs from 2 otherwise there are no polymorphism#
			for(j in 1:(k-1)){#
			stirling.bit<-	my.StirlingNumbers[l,j] * my.StirlingNumbers[n-l,k-j]  / my.StirlingNumbers[n,k]#
			p_l_given_k<-stirling.bit*choose(n,l)/choose(k,l)#
			if(!is.finite(p_l_given_k)){ p_l_given_k<-0 }  ##cat("problem",l,k,j," "); ##is this right?#
			terms.in.sum[k]<-terms.in.sum[k]+ESF.prob.k[n,k] *p_l_given_k*freq.specs[k,j]#
			stopifnot(is.finite(terms.in.sum[k])) #
		}		#
	}#
#
	expected.t.l[l]<-sum(terms.in.sum)#
}#
#
return(expected.t.l)#
}
mu=1e-6; rho=2; sb=0.05; sdvals=seq(0.0001,0.3,length=500); #
#
sigma=100; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
plot(sdvals,charlength.sd,type="l",ylim=c(100,800),lwd=2,col=my.col[1])#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col=my.col[1],lwd=2,lty=2)  ##new mut. only#
#
 sigma=50; charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
lines(sdvals,charlength.sd,type="l",lwd=2,col=my.col[2])#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col=my.col[2],lwd=2,lty=2)  ##new mut. only#
sigma=10; #
 charlength.sd<-sapply(sdvals, function (sd) { charLength(mu,rho,sb,sd,sigma)$value } )#
 lines(sdvals,charlength.sd,lwd=2,col=my.col[3])#
 abline(h= newCharLength(mu, rho, sb, sd=NA, sigma)$value,col=my.col[3],lwd=2,lty=2) ##new mut. only#
 ##contribution of standing var only#
 charlength.standing.only<-sapply(sdvals, function (sd) {  oldCharLength(mu, rho, sb, sd, sigma)$value})#
 lines(sdvals,charlength.standing.only ,lwd=2,col=my.col[4],lty=3)#
 legend("topleft",)
source ("SweepFromStandingSim.R")#
run.ms.f<-function(f.index,n.sam=2, get.site.density=TRUE,recom=FALSE){#
#
	my.file<-paste("mssel_f",n.sam,f.index,".out",sep="")#
#
	system(paste("rm ",my.file))#
	for(run in 1:5){#
		load(paste("run_cond_lost_",run,".Robj",sep=""))#
		for(i in 1:100){#
			my.freqs<-my.runs[[f.index]]$trees[[i]]$freqs#
			my.times<-0:length(my.freqs)#
			my.freqs<-c(my.freqs,0)#
			my.times<-my.times / (4*10e3)#
	#		recover()#
			header.material<-c("1","1",paste("n:",length(my.times) ))#
			write(file=paste("my.standing",f.index,".traj",sep=""),header.material)#
			write.table(file=paste("my.standing",f.index,".traj",sep=""),cbind(my.times,my.freqs), append=TRUE, sep="\t",quot=FALSE,col.nam=FALSE,row.name=FALSE)#
			cat(i," ")#
			if(get.site.density){ #
				system(paste("msseldir/mssel ",n.sam," 20 0 ",n.sam," my.standing",f.index,".traj 0 -t 200. -r 200. 20000 | grep pos | cut -f 2 -d : >> ",my.file,sep=""))#
				}else{   ##setup for the mo. to do freq. spectrum#
				system(paste("msseldir/mssel ",n.sam," ",20," 0 ",n.sam," my.standing",f.index,".traj 0 -t 200. -r ",recom, " 2 > myseqdata",sep="")) #
				spec<-get.freq.spec(n.sam,num.sims=20)#
				recover()#
			}#
		}#
	}#
}#
#
real.fs <- c ( 0.001 , seq ( 0.01 , 0.1 , length = 10 ) )#
my.runs <- lapply ( real.fs , function ( x ) SweepFromStandingSim ( N = 10000 , s = 0.01 , f = x , reps = 100 , no.sweep = FALSE , cond.on.loss = TRUE , cond.on.fix = TRUE , time.factor = 4 ) )#
get.mut.density<-function(file){#
	myres = scan(file)#
	##myres*theta, note range of smoothing#
	myres<-myres*200#
	mydens = density(myres,from=3,to=190,bw=2.0,na.rm=T)#
	mydens$y<-mydens$y*length(myres)#
	return(mydens)#
}#
pdf(file="pi_density.pdf")#
	plot(c(0,200),c(0,1),type="n",xlab="4NR",ylab=expression(pi[R]/pi[0]),cex.lab=1.5)#
	pi.over.f<-list()#
	for(f.index in 1:5){#
	#run.ms.f(f.index)#
	mut.density<-get.mut.density(file=paste("mssel_f",f.index,".out",sep=""))#
	pi.over.f[[f.index]]<-mut.density#
	lines(mut.density$x,mut.density$y/(5*100*20),col=f.index)#
	}#
	fs<-1:5/100#
	rho=seq(0,200,length=1000)#
	for(i in 1:5){#
	f=fs[i]#
	s=0.01#
	lines(rho,1-1/(1+rho*f*(1-f)),col=i,lwd=2,lty=2)#
	# lines(r,1-1/(1+4*N*r*f*(1-f))*exp(-2*r/s*log(1/f)),col=i,lwd=2)#
	# lines(r,1-exp(-2*r*(1/s*log(1/f)+2*N*f*(1-f))),col=i,lty=2)#
	}#
	legend("bottomright",legend= paste("f=",fs),col=1:5,lty=1,lwd=2,cex=1.5)#
dev.off()#
 for(f.index in 1:5){#
 run.ms.f(f.index=f.index,n.sam=10)#
 }#
N=1e4#
 r = 10^-8 ; interval.width = 1000; sim.distance = 0.05 #
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
 pdf(file="segsite_density.pdf")#
plot(c(0,200),c(0,2.5),type="n",xlab="4NR",ylab="Num. seg. sites",cex.lab=1.5)#
pi.over.f<-list()#
 fs<-1:5/100#
for(f.index in 1:5){#
#run.ms.f(f.index)#
	mut.density<-get.mut.density(file=paste("mssel_f10",f.index,".out",sep=""))#
	pi.over.f[[f.index]]<-mut.density#
	lines(mut.density$x,mut.density$y/(5*100*20),col=f.index,lty=1,lwd=2)#
#
	f<-fs[f.index]#
	ESF.prob.k<-sapply(intervals,function(distance){EwensDist( n=n , N =N, r=r , distance=distance , f=f )[n,]})#
	num.seg.sites.cond.i<-c(0,sapply(1:9,function(i){ sum(1/(1:i)) }))#
	num.seg.sites.r<-colSums(apply(ESF.prob.k,2,function(x){x*num.seg.sites.cond.i}))#
#
	lines(4*N*intervals*r,num.seg.sites.r,col=f.index,lty=2,lwd=2) 	#
 }#
 legend("bottomright",legend= paste("f=",fs),col=1:5,lty=1,lwd=2,cex=1.5)#
dev.off()
=======
my.rec.events$rec.right.off.background$sequence.location
my.rec.events$rec.right.off.background$sequence.location < k
sum ( my.rec.events$rec.right.off.background$sequence.location < k )
my.rec.events$rec.right.off.background$sequence.location < k
sum ( my.rec.events$rec.right.off.background$sequence.location < k )
my.rec.events$rec.right.off.background$sequence.location < k
sum ( my.rec.events$rec.right.off.background$sequence.location < k )
my.seqs$right.seq [ , last.rec.event + 1 ]
last.rec.event <- sum ( my.rec.events$rec.right.off.background$sequence.location < k )
my.seqs$right.seq [ , last.rec.event + 1 ]
table(my.seqs$right.seq [ , last.rec.event + 1 ])
table(my.seqs$right.seq [ , last.rec.event + 1 ])>1
sum(table(my.seqs$right.seq [ , last.rec.event + 1 ])>1)
sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )
n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )
sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )
n.haps <- rbind ( n.haps.right , n.haps.left )#
	no.sing.haps <- rbind ( no.sing.haps.right , no.sing.haps.left )
cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
			no.sing.haps.right [ , i ] <- no.sing.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.right [ j , i ] <- sum ( table ( my.seqs$right.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
					no.sing.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.left [ j , i ] <- sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
					no.sing.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)
n.haps <- rbind ( n.haps.right , n.haps.left )
no.sing.haps <- rbind ( no.sing.haps.right , no.sing.haps.left )
no.sing.haps
hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )
hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )
no.sing.hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )
hap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )
hap.count.freqs.by.interval
no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )
no.singhap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )
hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )
hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )
no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )
no.singhap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )
no.singhap.count.freqs.by.interval
no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )
no.singhap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )
no.singhap.count.freqs.by.interval
no.sing.hap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )
no.sing.haps
Q
##install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , display.rep.count = TRUE , time.factor = 1 ) {#
	options ( error = recover )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix , display.rep.count )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- temp [[ 2 ]]#
			# sweep.start.forward <- ncol ( frequencies ) - sweep.start #
			# # if ( nrow ( frequencies ) > 1 ) {#
			# fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			# zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			# entry <- numeric()#
			# for ( i in 1 : length ( zeros ) ){#
				# if ( length ( zeros [[ i ]] ) != 0 ) {#
					# entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				# } else {#
					# entry [ i ] <- 1#
				# }#
			# }#
			# transit.time <- fixation.time - entry#
			new.freqs <- temp [[ 1 ]]#
			# for ( i in 1 : nrow ( frequencies ) ) {#
				# new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			# }#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
		trees [[ i ]] [[ "sweep.start"]] <- sweep.start [ i ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f  )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
		#recover()#
		if ( FALSE ) {#
		standing.hap.dist <- StandingHapCountDist ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
		}#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , standing.hap.dist = standing.hap.dist , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , display.rep.count , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 & display.rep.count) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	sweep.start <- apply ( sweep.freq.matrix , 1 , function ( x ) which.max ( x ) / time.factor )#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
	if ( no.sweep == FALSE ) {#
		freq.traj.list <- mapply ( 	function ( X , Y ) {#
											#recover()#
											fixation <- which.max ( Y )#
											mutation <- sum ( X > 0 )#
											freq <- c ( rev ( Y [ 2 : fixation ] ) , X [ 1 : mutation ] )#
											return ( freq )#
										} ,#
										X = split ( neutral.freq.matrix , 1 : nrow ( neutral.freq.matrix ) ) , #
										Y = split ( sweep.freq.matrix , 1 : nrow ( sweep.freq.matrix ) )#
							)#
		freq.trajectories <- matrix ( 0 , ncol = max ( unlist ( lapply ( freq.traj.list , length ) ) ) , nrow = reps )#
		for ( i in seq_len ( nrow ( freq.trajectories ) ) ) {#
			freq.trajectories [ i , 1 : length ( freq.traj.list [[ i ]] ) ] <- freq.traj.list [[ i ]]#
		}#
		#freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	# temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	# add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	# temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	# freq.trajectories <- do.call ( rbind , temp2 )#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	#library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	no.sing.haps.right <- no.sing.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
			no.sing.haps.right [ , i ] <- no.sing.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.right [ j , i ] <- sum ( table ( my.seqs$right.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
					no.sing.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.left [ j , i ] <- sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
					no.sing.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	no.sing.haps <- rbind ( no.sing.haps.right , no.sing.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	no.sing.hap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , no.sing.hap.count.freqs.by.interval = no.sing.hap.count.freqs.by.interval , n.haps = n.haps , no.sing.haps = no.sing.haps ) )#
}#
StandingHapCountDist <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events#
				my.rec.events.off <- input [[ j ]] $ rec.events.off.background#
				# right side#
				sweep.recs <- my.rec.events$rec.right$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.right$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.right$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- extract.clade ( input [[ j ]]$tree , i )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				sweep.recs <- my.rec.events$rec.left$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.left$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.left$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- GetTips ( i , n.tips , input[[j]]$tree$edge )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	recover()#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		}#
	}#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n"#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
#
GetTips <- function ( branch , n.tips , edges ) {#
	#recover()#
	if ( branch <= n.tips ) {#
		return ( branch )#
	}#
	subtend <- edges [ edges [  , 1 ] == branch , 2 ]#
	if ( all ( subtend <= n.tips ) ) {#
		return ( subtend )#
	} else {#
		sapply ( subtend , function ( x ) GetTips ( x , n.tips , edges ) )#
	}#
}#
#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = FALSE ,  time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
#
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.05 , f = 0.01 , reps = 100 , n.tips = 12 , r = 10^-8 , sim.distance = 0.015 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)#
#
SequenceIBDPlots <- function ( trees ) {#
	#recover()#
	seq.structure <- trees$sequence.structure#
	seq.resort <- do.call(what = order, as.data.frame(seq.structure))#
	seq.structure <- lapply ( seq.structure , function ( x ) x [ seq.resort , ] )#
	rec.points <- trees$rec.events.off.background#
	scaled.rec.points <- list ()#
	scaled.rec.points$right <- c ( 0 , rec.points$rec.right.off.background$sequence.location / trees$sim.distance , 1 )#
	scaled.rec.points$left <- - c ( 0 , rec.points$rec.left.off.background$sequence.location / trees$sim.distance , 1 )#
	#my.cols <- rainbow ( max ( unlist ( seq.structure ) ) + 1 , alpha = 0.7 )#
	my.cols.right <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Paired" )#
	my.cols.left <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Set3" )#
	plot ( NA , bty = "n" , xlim = c ( -1 , 1 ) , ylim = c ( 0 , 12 ) , xaxt = "n" , yaxt = "n" , ylab = "" , xlab = "" )#
#
	### right side#
	for ( row in seq_len ( nrow ( seq.structure$right.seq ) ) ) {#
		my.recs <- unique ( seq.structure$right.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$right.seq[row,] ) , max ( unlist ( seq.structure$right.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.right [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	### left side#
	for ( row in seq_len ( nrow ( seq.structure$left.seq ) ) ) {#
		my.recs <- unique ( seq.structure$left.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$left.seq[row,] ) , max ( unlist ( seq.structure$left.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.left [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	abline ( v = 0 )#
}#
#
if ( FALSE) SequenceIBDPlots ( temp$trees[[1]] )#
par ( mfrow = c ( 3 ,2 ) )#
for ( i in 1 : 6 ) SequenceIBDPlots ( temp$trees[[i]] )#
###########################################
#### Let's think about inference w/ genealogies #####
###########################################
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
for ( i in 1 : length ( coal.times ) ) {#
	log.likes[[i]] <- lapply ( 1:nrow(coal.times[[i]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times[[i]] [ y , ] , x , 20000 ) ) )#
	print ( i )#
}#
#log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(z) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( z [ y , ] , x , 20000 ) ) )  )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.05 , f = 0.05 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )
length(trees)
hap.dist
length(hap.dist)
names(hap.dist)
hap.dist$no.sing.hap.count.freqs.by.interval
MakeHapPlots ( hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)
sim.distance.bp <- sim.distance / r
intervals <- seq ( 0 , sim.distance.bp , interval.width )
n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )
ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )
plot.cumulative
if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}
matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n"#
	)
matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)
col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )
for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}
col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)
col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
Q
>>>>>>> FETCH_HEAD
##install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
<<<<<<< HEAD
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE) {#
	options ( error = NULL )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- rep ( temp[[2]] , nrow ( frequencies ) )#
			sweep.start.forward <- ncol ( frequencies ) - sweep.start[1] #
			# if ( nrow ( frequencies ) > 1 ) {#
			fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			entry <- numeric()#
			for ( i in 1 : length ( zeros ) ){#
				if ( length ( zeros [[ i ]] ) != 0 ) {#
					entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				} else {#
					entry [ i ] <- 1#
				}#
			}#
			transit.time <- fixation.time - entry#
			new.freqs <- matrix ( 0 , nrow = reps , ncol = max ( transit.time + 1 ) )#
			for ( i in 1 : nrow ( frequencies ) ) {#
				new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			}#
=======
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , display.rep.count = TRUE , time.factor = 1 ) {#
	options ( error = recover )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix , display.rep.count )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- temp [[ 2 ]]#
			# sweep.start.forward <- ncol ( frequencies ) - sweep.start #
			# # if ( nrow ( frequencies ) > 1 ) {#
			# fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			# zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			# entry <- numeric()#
			# for ( i in 1 : length ( zeros ) ){#
				# if ( length ( zeros [[ i ]] ) != 0 ) {#
					# entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				# } else {#
					# entry [ i ] <- 1#
				# }#
			# }#
			# transit.time <- fixation.time - entry#
			new.freqs <- temp [[ 1 ]]#
			# for ( i in 1 : nrow ( frequencies ) ) {#
				# new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			# }#
>>>>>>> FETCH_HEAD
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
<<<<<<< HEAD
	}#
	#recover()#
	temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
	trees <- temp [[ 1 ]]#
	T.total <- temp [[ 2 ]]#
#
	#recover()#
	trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f , fixation.time = fixation.time )#
#
	hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N )#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , fixation.time = fixation.time , T.total = T.total ) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , time.factor ,  reps , no.sweep, cond.on.loss) {#
	delta.T <- 1 / ( 2 * N )#
=======
		trees [[ i ]] [[ "sweep.start"]] <- sweep.start [ i ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f  )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
		#recover()#
		if ( FALSE ) {#
		standing.hap.dist <- StandingHapCountDist ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
		}#
		standing.hap.dist <- 0#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , standing.hap.dist = standing.hap.dist , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , display.rep.count , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
>>>>>>> FETCH_HEAD
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
<<<<<<< HEAD
			mu.S <- 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
			sel <- mu.S * delta.T#
			sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
			plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
			drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
			update [ sweep.not.fixed ] <- sel + drift.sweep			#
=======
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
>>>>>>> FETCH_HEAD
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
<<<<<<< HEAD
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 0#
=======
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
>>>>>>> FETCH_HEAD
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
<<<<<<< HEAD
			 cond.mean <- ifelse(cond.on.loss,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * 1 / ( 2 * N ),#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * 1 / ( 2 * N ) ) )#
=======
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
>>>>>>> FETCH_HEAD
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
<<<<<<< HEAD
		if ( i %% 5000 == 0 ) {#
=======
		if ( i %% 5000 == 0 & display.rep.count) {#
>>>>>>> FETCH_HEAD
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
<<<<<<< HEAD
		if ( i == 16 * N ){#
=======
		if ( i == time.factor * 16 * N ){#
>>>>>>> FETCH_HEAD
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
<<<<<<< HEAD
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
if(turn.on.recovers)	recover()#
	# if ( constant.freq == FALSE ) {#
		# # if ( reps == 1 ) {#
			# # freq.trajectories <- c ( neutral.freq.matrix [ length ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ 1 : length ( sweep.freq.matrix ) ] )#
			# # #plot ( freq.trajectories , type = "l" )#
			# # freq.trajectories <- matrix ( freq.trajectories , nrow = 1 )#
			# # if ( freq.trajectories [ , ncol ( freq.trajectories ) ] == 1 ) {#
				# # conditional.freq.trajectories <- freq.trajectories#
				# # #generations <- seq ( 1 , ncol ( conditional.freq.trajectories ) , time.factor )#
				# # #conditional.freq.trajectories <- conditional.freq.trajectories [ , generations ]#
			# # } else {#
				# # cat ( "Allele lost from population.\n")#
				# # return ( )#
			# # }#
		# # } else {#
	if ( no.sweep == FALSE ) {#
		freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , 1 : ncol ( neutral.freq.matrix ) ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
		# }#
	# } else {#
		# freq.trajectories <- sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ]#
	# }#
	#recover()#
	keep.these <- freq.trajectories [ , ncol ( freq.trajectories ) ] == 1		#
	conditional.freq.trajectories <- freq.trajectories [ keep.these , ]#
	sweep.start <- ncol ( sweep.freq.matrix ) #/ time.factor#
	return ( list ( conditional.freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	library ( ape )#
=======
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	sweep.start <- apply ( sweep.freq.matrix , 1 , function ( x ) which.max ( x ) / time.factor )#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
	if ( no.sweep == FALSE ) {#
		freq.traj.list <- mapply ( 	function ( X , Y ) {#
											#recover()#
											fixation <- which.max ( Y )#
											mutation <- sum ( X > 0 )#
											freq <- c ( rev ( Y [ 2 : fixation ] ) , X [ 1 : mutation ] )#
											return ( freq )#
										} ,#
										X = split ( neutral.freq.matrix , 1 : nrow ( neutral.freq.matrix ) ) , #
										Y = split ( sweep.freq.matrix , 1 : nrow ( sweep.freq.matrix ) )#
							)#
		freq.trajectories <- matrix ( 0 , ncol = max ( unlist ( lapply ( freq.traj.list , length ) ) ) , nrow = reps )#
		for ( i in seq_len ( nrow ( freq.trajectories ) ) ) {#
			freq.trajectories [ i , 1 : length ( freq.traj.list [[ i ]] ) ] <- freq.traj.list [[ i ]]#
		}#
		#freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	# temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	# add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	# temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	# freq.trajectories <- do.call ( rbind , temp2 )#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	#library ( ape )#
>>>>>>> FETCH_HEAD
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
<<<<<<< HEAD
# BuildTrees <- function ( coal.times , n.tips ){#
	# #recover()#
	# library(ape)#
	# trees <- list ( )#
	# for ( j in 1 : nrow ( coal.times ) ) {#
		# edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		# edge.length <- numeric ( 2 * n.tips - 2 )#
		# edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		# nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		# node.depth <- numeric ( 2 * n.tips - 1 )#
		# Nnode <- n.tips - 1#
		# tip.label <- character ( n.tips )#
		# for ( l in 1 : length ( tip.label ) ){#
			# tip.label [ l ] <- paste ( "t" , l , sep = "")#
		# }#
		# k = 1#
		# for ( i in nodes ) {#
			# extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			# coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			# coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			# edge [ coal.index , 1 ] <- i#
			# if ( i != tail ( nodes , 1 ) ) {#
				# edge [ i - 1 , 2 ] <- i#
			# }#
			# node.depth [ i ] <- coal.times [ j , k ] #
			# edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			# k = k + 1#
		# }#
		# a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		# class ( a.tree ) <- "phylo"#
		# my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		# trees [[ j ]] <- my.tree#
	# }#
	# ## note; the frequency path gets added on as trees [[ j ]] [[ 3 ]] in the top level function call immediately after returning from this function; bad writing that I should fix some day.#
	# return ( trees )#
# }#
=======
>>>>>>> FETCH_HEAD
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
<<<<<<< HEAD
					my.freq <- rev ( trees [[ j ]] [[ 3 ]] ) [ this.event$rec.depth ]#
=======
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
>>>>>>> FETCH_HEAD
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
<<<<<<< HEAD
=======
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
>>>>>>> FETCH_HEAD
	}#
	close ( pb )#
	return ( trees )#
}#
<<<<<<< HEAD
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N ) {#
=======
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
>>>>>>> FETCH_HEAD
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
<<<<<<< HEAD
=======
	no.sing.haps.right <- no.sing.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
>>>>>>> FETCH_HEAD
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
<<<<<<< HEAD
=======
			no.sing.haps.right [ , i ] <- no.sing.haps.left [ , i ] <- 1#
>>>>>>> FETCH_HEAD
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
<<<<<<< HEAD
					last.rec.event <- max ( which ( my.rec.events$rec.right.off.background$sequence.location < k ) )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.left.off.background$sequence.location < k ) )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.left [ j , i ] <- 1#
=======
					last.rec.event <- sum ( my.rec.events$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.right [ j , i ] <- sum ( table ( my.seqs$right.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
					no.sing.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.left [ j , i ] <- sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
					no.sing.haps.left [ j , i ] <- 1#
>>>>>>> FETCH_HEAD
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
<<<<<<< HEAD
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	# cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )#
# #	par ( mfrow = c ( 2 , 1 ) )#
	# #matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	# ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
	# stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f , stirling.numbers = stirling.numbers )#
		# }#
	# }#
	# #recover()#
	# ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )#
	# matplot ( #
		# t ( ewens.cum.probs ) , #
		# type = "n" , #
		# lty = 1 , #
		# lwd = 0.7 , #
		# col = "black" , #
		# ylab = "Cumulative Probability" , #
		# xlab = "kb" , #
		# #main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		# bty = "n"#
	# )#
	# #recover()#
	# col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	# for ( i in 1 : ( nrow ( cum.probs ) - 1 ) ) {#
			# #i = i + 1#
			# X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
			# Y.ax1 <- cum.probs [ i , X.ax ]#
			# Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			# polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	# }#
	# ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
	# apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	# #recover()#
	# expected.num.haps <- colSums ( apply ( hap.counts.by.interval , 2 , function ( x ) x * 1 : n.tips ) / (2 * length ( input ) ) , 2 )#
	# #plot ( expected.num.haps , type = "l" , lty = 1 , lwd = 1.5 , xlab = "kb" , ylab = "Expected Number of Haplotypes" , bty = "n")#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
=======
	no.sing.haps <- rbind ( no.sing.haps.right , no.sing.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	no.sing.hap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , no.sing.hap.count.freqs.by.interval = no.sing.hap.count.freqs.by.interval , n.haps = n.haps , no.sing.haps = no.sing.haps ) )#
}#
StandingHapCountDist <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events#
				my.rec.events.off <- input [[ j ]] $ rec.events.off.background#
				# right side#
				sweep.recs <- my.rec.events$rec.right$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.right$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.right$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- extract.clade ( input [[ j ]]$tree , i )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				sweep.recs <- my.rec.events$rec.left$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.left$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.left$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- GetTips ( i , n.tips , input[[j]]$tree$edge )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	recover()#
>>>>>>> FETCH_HEAD
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
<<<<<<< HEAD
	n.tips <- nrow ( hap.count.freqs.by.interval )#
=======
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
>>>>>>> FETCH_HEAD
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
<<<<<<< HEAD
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f , stirling.numbers = stirling.numbers )#
=======
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
>>>>>>> FETCH_HEAD
		}#
	}#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
<<<<<<< HEAD
		bty = "n"#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
#
=======
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
>>>>>>> FETCH_HEAD
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
<<<<<<< HEAD
=======
#
GetTips <- function ( branch , n.tips , edges ) {#
	#recover()#
	if ( branch <= n.tips ) {#
		return ( branch )#
	}#
	subtend <- edges [ edges [  , 1 ] == branch , 2 ]#
	if ( all ( subtend <= n.tips ) ) {#
		return ( subtend )#
	} else {#
		sapply ( subtend , function ( x ) GetTips ( x , n.tips , edges ) )#
	}#
}#
#
>>>>>>> FETCH_HEAD
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
<<<<<<< HEAD
EwensDist <- function ( n , N , r , distance , f , stirling.numbers ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- prod ( param + 0 : ( n - 1 ) )#
	#stirling.numbers <- StirlingNumbers ( n ) [ n , ]#
	ewens.dist <- param^(1:n) * stirling.numbers / denom#
=======
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
>>>>>>> FETCH_HEAD
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
<<<<<<< HEAD
=======
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
>>>>>>> FETCH_HEAD
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
<<<<<<< HEAD
#
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.5 , f = 0.01 , reps = 200 , n.tips = 10 , r = 10^-8 , sim.distance = 0.02 , interval.width = 1000 , no.sweep = TRUE , constant.freq = FALSE , cond.on.loss = TRUE)#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
}#
# # #
# # Let's think about inference#
# my.seqs <- temp[["trees"]][[1]][["sequence.structure"]]$right.seq#
#
# # InferenceFunction <- function ( seqs ) {#
# # if(turn.on.recovers)	recover()#
	# # hap.partitions <- apply ( seqs , 2 , function ( x ) table ( factor ( x , levels = 0 : ( nrow ( seqs ) - 1 ) ) ) )#
	# # tree <- BuildTrees ( 1 : ( nrow ( seqs ) - 1 ) )#
# # }#
#
=======
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = FALSE ,  time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
#
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.05 , f = 0.01 , reps = 100 , n.tips = 12 , r = 10^-8 , sim.distance = 0.015 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)#
#
SequenceIBDPlots <- function ( trees ) {#
	#recover()#
	seq.structure <- trees$sequence.structure#
	seq.resort <- do.call(what = order, as.data.frame(seq.structure))#
	seq.structure <- lapply ( seq.structure , function ( x ) x [ seq.resort , ] )#
	rec.points <- trees$rec.events.off.background#
	scaled.rec.points <- list ()#
	scaled.rec.points$right <- c ( 0 , rec.points$rec.right.off.background$sequence.location / trees$sim.distance , 1 )#
	scaled.rec.points$left <- - c ( 0 , rec.points$rec.left.off.background$sequence.location / trees$sim.distance , 1 )#
	#my.cols <- rainbow ( max ( unlist ( seq.structure ) ) + 1 , alpha = 0.7 )#
	my.cols.right <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Paired" )#
	my.cols.left <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Set3" )#
	plot ( NA , bty = "n" , xlim = c ( -1 , 1 ) , ylim = c ( 0 , 12 ) , xaxt = "n" , yaxt = "n" , ylab = "" , xlab = "" )#
#
	### right side#
	for ( row in seq_len ( nrow ( seq.structure$right.seq ) ) ) {#
		my.recs <- unique ( seq.structure$right.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$right.seq[row,] ) , max ( unlist ( seq.structure$right.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.right [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	### left side#
	for ( row in seq_len ( nrow ( seq.structure$left.seq ) ) ) {#
		my.recs <- unique ( seq.structure$left.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$left.seq[row,] ) , max ( unlist ( seq.structure$left.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.left [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	abline ( v = 0 )#
}#
#
if ( FALSE) SequenceIBDPlots ( temp$trees[[1]] )#
par ( mfrow = c ( 3 ,2 ) )#
for ( i in 1 : 6 ) SequenceIBDPlots ( temp$trees[[i]] )#
###########################################
#### Let's think about inference w/ genealogies #####
###########################################
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
for ( i in 1 : length ( coal.times ) ) {#
	log.likes[[i]] <- lapply ( 1:nrow(coal.times[[i]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times[[i]] [ y , ] , x , 20000 ) ) )#
	print ( i )#
}#
#log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(z) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( z [ y , ] , x , 20000 ) ) )  )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
>>>>>>> FETCH_HEAD
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
<<<<<<< HEAD
N=1e4#
 r = 10^-8 ; interval.width = 1000; sim.distance = 0.05 #
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )
fs<-1:5/100
f.index
f<-fs[f.index]
ESF.prob.k<-sapply(intervals,function(distance){EwensDist( n=n , N =N, r=r , distance=distance , f=f )[n,]})
n=10
ESF.prob.k<-sapply(intervals,function(distance){EwensDist( n=n , N =N, r=r , distance=distance , f=f )[n,]})
stirling.numbers<-StirlingNumbers( 10 )
stirling.numbers
ESF.prob.k<-sapply(intervals,function(distance){EwensDist( n=n , N =N, r=r , distance=distance , f=f )[n,]})
ESF.prob.k<-sapply(intervals,function(distance){EwensDist( n=n , N =N, r=r , distance=distance , f=f ,stirling.numbers=stirling.numbers)[n,]})
dim(EESF.prob.k)
dim(ESF.prob.k)
ESF.prob.k[1,]
ESF.prob.k[,1]
ESF.prob.k[,2]
ESF.prob.k[,3]
ESF.prob.k[,10000]
ESF.prob.k[,1000]
ESF.prob.k[,10]
stirling.numbers\
stirling.numbers
EwensDist( n=n , N =N, r=r , distance=intervals[1000] , f=f ,stirling.numbers=stirling.numbers)[n,]
EwensDist( n=n , N =N, r=r , distance=intervals[1000] , f=f ,stirling.numbers=stirling.numbers)
rowSums(EwensDist( n=n , N =N, r=r , distance=intervals[1000] , f=f ,stirling.numbers=stirling.numbers))
N
n
dim(stirling.numbers)
EwensDist <- function ( n , N , r , distance , f , stirling.numbers ) {#
	recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- prod ( param + 0 : ( n - 1 ) )#
	#stirling.numbers <- StirlingNumbers ( n ) [ n , ]#
	ewens.dist <- param^(1:n) * stirling.numbers / denom#
	return ( ewens.dist ) #
#
}
EwensDist( n=n , N =N, r=r , distance=intervals[1000] , f=f ,stirling.numbers=stirling.numbers)
param <- 4 * N * r * distance * f * ( 1- f )
param
N
r
distance
f
1-f
denom  <- prod ( param + 0 : ( n - 1 ) )
denom
param
param + 0 : ( n - 1 )
param^(1:n)
stirling.numbers
ewens.dist <- param^(1:n) * stirling.numbers [ n , ] / denom
ewens.dist
sum(ewens.dist)
Q
EwensDist <- function ( n , N , r , distance , f , stirling.numbers ) {#
#	recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- prod ( param + 0 : ( n - 1 ) )#
	#stirling.numbers <- StirlingNumbers ( n ) [ n , ]#
	ewens.dist <- param^(1:n) * stirling.numbers [ n , ] / denom#
	return ( ewens.dist ) #
#
}
EwensDist( n=n , N =N, r=r , distance=intervals[1000] , f=f ,stirling.numbers=stirling.numbers)
8/38
get.freq.spec<-function(n,num.sims, path){#
	#recover()#
	a<-system(paste("grep segsites ","Sims/myseqdata",sep=""),intern=TRUE)#
	seg.sites<-sapply(a,function(b){as.numeric(strsplit(b,":")[[1]][2])})#
	polymorph<- seg.sites>0#
	seq.lines<-c(0,cumsum(polymorph*n)[-length(polymorph)])	#
	freq.specs<-sapply(0:(num.sims-1),function(iter){		#
		if(!polymorph[1+iter]) {freq.spec<-rep(0,n);return(freq.spec)}#
		positions<-read.table(paste(path, "Sims/myseqdata",sep=""),skip=5+4*iter+seq.lines[iter+1],nrow=1)#
#		print(positions[1])#
#		if(length(positions)==1){freq.spec<-rep(0,n);return(freq.spec)}		#
		seqs.raw<-scan(paste(path, "Sims/myseqdata",sep=""),skip=6+4*iter+seq.lines[iter+1],nline=n,what=character(),quiet=TRUE)#
		seqs<-sapply(seqs.raw,function(seq){as.numeric(strsplit(seq,"")[[1]])})#
		colnames(seqs)<-NULL#
		seqs<-t(seqs)#
		these.pos<-positions[-1]>0.5   ###why the -1 here? oh because positions has label#
		if(sum(these.pos)==0){freq.spec<-rep(0,n);return(freq.spec)}#
		seqs<-seqs[,these.pos] ##throw out first 1/2 of seq.#
		if(sum(these.pos)==1){freq.spec<-(1:n==sum(seqs)); return(freq.spec)}#
		mut.freq<-colSums(seqs)#
		freq.spec<- sapply(1:n,function(i){sum(mut.freq==i)})#
		return(freq.spec)#
	})#
return(freq.specs)#
}
path = "~/Dropbox/Linked_selection_models/Soft_sweeps_coal/LinkedSelection/"
temp<-get.freq.specfunction(n=10,num.sims=10, path=path)
temp<-get.freq.spec(n=10,num.sims=10, path=path)
setwd(path)
temp<-get.freq.spec(n=10,num.sims=10, path=path)
temp<-get.freq.spec(n=10,num.sims=1000, path=path)
dim(temp)
rowSums(temp)
rowSums(temp)/sum(temp)
1/(1:9)/sum(1/(1:9))
temp<-get.freq.spec(n=10,num.sims=1000, path=path)
system ( paste ( "mssel " , 10 , " " , 1000 , " 0 " , 10 , " Sims/my.standing" , "." , f.lab , "." , s.lab , "." , N, "." ,ext, ".traj 0 -t 200. -r " , recom , " 2 >",path, "Sims/myseqdata" , sep = "" ) )
getwd()
setwd("Scripts/msseldir/")
system ( paste ( "./mssel " , 10 , " " , 500 , " 0 " , 10 , " my.standing5.traj 0 -t 200. -r " , 300 , " 2 >",path, "Sims/myseqdata" , sep = "" ) )
temp.2<-get.freq.spec(n=10,num.sims=500, path=path)
setwd("../../")
temp.2<-get.freq.spec(n=10,num.sims=500, path=path)
rowSums(temp.2)/sum(temp.2)
1/(1:9)/sum(1/(1:9))
system ( paste ( "./mssel " , 10 , " " , 500 , " 0 " , 10 , " my.standing5.traj 0 -t 200. -r " , 400 , " 2 >",path, "Sims/myseqdata" , sep = "" ) )
setwd("Scripts/msseldir/")
system ( paste ( "./mssel " , 10 , " " , 500 , " 0 " , 10 , " my.standing5.traj 0 -t 200. -r " , 400 , " 2 >",path, "Sims/myseqdata" , sep = "" ) )
setwd("../../")
temp.3<-get.freq.spec(n=10,num.sims=500, path=path)
rowSums(temp.3)/sum(temp.3)
selfing.rate=0.05#
#
	D<-matrix(1/2,nrow=2,ncol=3,dimnames=list(c("1 or 2","3"),c("12","13","23"))) ##entries are drive coeff of the 2nd allele listed against the 1st.#
	d.range<-seq(0.5,1,length=200)#
	s3.range<-seq(0,1,length=200)#
	invasion.grid<-sapply(s3.range,function(s3){#
		sapply(d.range,function(d){#
			test.invasion.self.prop(d=d,s.het=0,s.hom=s3,selfing.rate=selfing.rate)#
		})#
	})#
	invasion.lines.s3.cutoff<-s3.range[apply(invasion.grid,1,function(x){max(which(x))})]#
	simple.fixation.grid<-sapply(s3.range,function(s3){#
		sapply(d.range,function(d){#
			test.fixation.of.simple.driver(d=d,s.het=0,s.hom=s3,selfing.rate=selfing.rate)#
		})#
	})#
	fixation.lines.s3<-s3.range[apply(simple.fixation.grid,1,function(x){max(which(x))})]#
#
	simple.invasion.grid<-sapply(s3.range,function(s3){#
		sapply(d.range,function(d){#
			test.fixation.of.simple.driver(d=d,s.het=0,s.hom=s3,x=0.01,selfing.rate=selfing.rate)#
		})#
	})#
	simple.invasion.lines.s3<-s3.range[apply(simple.invasion.grid,1,function(x){max(which(x))})]
###BASIC FUNCTIONS TO SETUP AND ITERATE DRIVE MODEL#
#
iterate.1.locus.drive<-function(s.array,num.iterations,female.transmission.probs,my.geno.freqs,initialize.allele.freqs=c(0.999,0.001,0),selfing.rate=0){#
	geno.freqs<-rep(NA,6)#
	names(geno.freqs)<-geno.names#
#
	my.freqs<-numeric()#
	if(missing(my.geno.freqs)){#
       #     print("running 2 allele system to stablity")#
		allele.freqs<-initialize.allele.freqs	#
		names(allele.freqs)<-c("1","2","3")	#
		geno.freqs["11"]<-allele.freqs["1"]^2#
		geno.freqs["22"]<-allele.freqs["2"]^2#
		geno.freqs["33"]<-allele.freqs["3"]^2#
#
		geno.freqs["12"]<-2*allele.freqs["1"]*allele.freqs["2"]#
		geno.freqs["13"]<-2*allele.freqs["1"]*allele.freqs["3"]#
		geno.freqs["23"]<-2*allele.freqs["3"]*allele.freqs["2"]#
		stopifnot(sum(geno.freqs)>0.9999999999 & sum(geno.freqs)< 1.0000000001)#
#
	}else{#
		print("initiating from my.geno.freqs")#
		geno.freqs[c("11","12","22")]<-my.geno.freqs[["geno.freqs"]][nrow(my.geno.freqs[["geno.freqs"]]),c("11","12","22")]*.99#
		geno.freqs[c("13","23")]<-my.geno.freqs[["allele.freqs"]][nrow(my.geno.freqs[["geno.freqs"]]),1:2]*.99*.01#
		geno.freqs["33"]<-.01^2#
		}#
#
	my.freqs<-rbind(my.freqs,geno.freqs)#
#
	for(i in 1:num.iterations){#
	#selection#
		geno.freqs["11"]<-geno.freqs["11"] * (1-s.array["11"])#
		geno.freqs["12"]<-geno.freqs["12"] * (1-s.array["12"])#
		geno.freqs["13"]<-geno.freqs["13"] * (1-s.array["13"])#
#
		geno.freqs["22"]<-geno.freqs["22"] * (1-s.array["22"])#
		geno.freqs["23"]<-geno.freqs["23"] * (1-s.array["23"])#
#
		geno.freqs["33"]<-geno.freqs["33"] * (1-s.array["33"])#
		geno.freqs<-geno.freqs/sum(geno.freqs)	#
#
		geno.freqs.array<-outer(rep(geno.freqs,each=2),rep(geno.freqs,each=2),"*")  ##one for each allele#
#
	geno.freqs.array<-(1-selfing.rate) * geno.freqs.array  ##selfing  (1-s) * pi *pj#
	diag(geno.freqs.array)<-diag(geno.freqs.array) +  selfing.rate * rep(geno.freqs,each=2)  #selfing  (1-s) * pi *pj + delta_{ij} s pi#
#
	##transmission#
		tot.trans<-geno.freqs.array*female.transmission.probs*0.5#
#
		new.geno.freqs<-rep(NA,6)	#
		names(new.geno.freqs)<-geno.names#
		new.geno.freqs["11"]<-sum(tot.trans[transmitted.allele==1,transmitted.allele==1])#
		new.geno.freqs["22"]<-sum(tot.trans[transmitted.allele==2,transmitted.allele==2])#
		new.geno.freqs["33"]<-sum(tot.trans[transmitted.allele==3,transmitted.allele==3])#
#
		new.geno.freqs["12"]<-sum(tot.trans[transmitted.allele==1,transmitted.allele==2])+sum(tot.trans[transmitted.allele==2,transmitted.allele==1])#
		new.geno.freqs["13"]<-sum(tot.trans[transmitted.allele==1,transmitted.allele==3])+sum(tot.trans[transmitted.allele==3,transmitted.allele==1])#
		new.geno.freqs["23"]<-sum(tot.trans[transmitted.allele==2,transmitted.allele==3])+sum(tot.trans[transmitted.allele==3,transmitted.allele==2])#
#
		geno.freqs<-new.geno.freqs#
		my.freqs<-rbind(my.freqs,geno.freqs)#
#
	}#
#
	freq.1<-my.freqs[,"11"]+0.5*rowSums(my.freqs[,c("12","13")])#
	freq.2<-my.freqs[,"22"]+0.5*rowSums(my.freqs[,c("12","23")])#
	freq.3<-my.freqs[,"33"]+0.5*rowSums(my.freqs[,c("13","23")])#
	geno.and.allele.freqs<-list()#
	geno.and.allele.freqs[["geno.freqs"]]<-my.freqs#
	geno.and.allele.freqs[["allele.freqs"]]<-cbind(freq.1,freq.2,freq.3)#
#
	return(geno.and.allele.freqs) #
 }#
  make.sperm.dep.female.transmission.prob<-function(D){#
 	geno.names<-c("11", "12","13", "22", "23", "33")#
	transmission.probs<-matrix(0.5,nrow=12,ncol=12)#
	rownames(transmission.probs)<-rep(geno.names,each=2)#
	colnames(transmission.probs)<-rep(geno.names,each=2)#
	transmitted.allele<-c(1,1,1,2,1,3,2,2,2,3,3,3)#
	##sperm alleles 1 and 2 allow: 2 and 3 female hets 12 to drive at D1#
	transmission.probs[transmitted.allele %in% 1:2,colnames(transmission.probs) =="12" & transmitted.allele == 1] <- 1-D["1 or 2","12"]#
	transmission.probs[transmitted.allele %in% 1:2,colnames(transmission.probs) =="12" & transmitted.allele == 2] <- D["1 or 2","12"]#
	##sperm alleles 1 and 2 allow: 2 and 3 female hets 12 to drive at D13#
	transmission.probs[transmitted.allele %in% 1:2,colnames(transmission.probs) =="13" & transmitted.allele == 1] <- 1-D["1 or 2","13"]#
	transmission.probs[transmitted.allele %in% 1:2,colnames(transmission.probs) =="13" & transmitted.allele == 3] <- D["1 or 2","13"]#
	##sperm allele 3 allow: 2 and 3 hets 12 and 13 to drive at D2#
	transmission.probs[transmitted.allele %in% 3,colnames(transmission.probs) == "13" & transmitted.allele == 1] <- 1-D["3","13"]#
	transmission.probs[transmitted.allele %in% 3,colnames(transmission.probs) =="13" & transmitted.allele == 3] <- D["3","13"]#
	transmission.probs[transmitted.allele %in% 3,colnames(transmission.probs) == "12" & transmitted.allele == 1] <- 1-D["3","12"]#
	transmission.probs[transmitted.allele %in% 3,colnames(transmission.probs) =="12" & transmitted.allele == 2] <- D["3","12"]#
	transmission.probs[transmitted.allele %in% 1:2,colnames(transmission.probs) == "23" & transmitted.allele == 2] <- 1-D["1 or 2","23"]#
	transmission.probs[transmitted.allele %in% 1:2,colnames(transmission.probs) =="23" & transmitted.allele == 3] <- D["1 or 2","23"]#
	transmission.probs[transmitted.allele %in% 3,colnames(transmission.probs) == "23" & transmitted.allele == 2] <- 1-D["3","23"]#
	transmission.probs[transmitted.allele %in% 3,colnames(transmission.probs) =="23" & transmitted.allele == 3] <- D["3","23"]#
transmission.probs#
}#
make.male.geno.dep.female.transmission.prob<-function(D){#
 	geno.names<-c("11", "12","13", "22", "23", "33")#
	transmission.probs<-matrix(0.5,nrow=12,ncol=12)#
	rownames(transmission.probs)<-rep(geno.names,each=2)#
	colnames(transmission.probs)<-rep(geno.names,each=2)#
	transmitted.allele<-c(1,1,1,2,1,3,2,2,2,3,3,3)#
	transmission.probs[,colnames(transmission.probs) =="12" & transmitted.allele == 1] <- 1-D["1 or 2","12"]#
	transmission.probs[,colnames(transmission.probs) =="12" & transmitted.allele == 2] <- D["1 or 2","12"]#
#
	transmission.probs[,colnames(transmission.probs) =="13" & transmitted.allele == 1] <- 1-D["1 or 2","13"]#
	transmission.probs[,colnames(transmission.probs) =="13" & transmitted.allele == 3] <- D["1 or 2","13"]#
#
	transmission.probs[,colnames(transmission.probs) == "23" & transmitted.allele == 2] <- 1-D["1 or 2","23"]#
	transmission.probs[,colnames(transmission.probs) =="23" & transmitted.allele == 3] <- D["1 or 2","23"]#
	##males carrying allele 3 alter rate of female drive in dominant fashion. #
	male.geno.3<-grep("3",rownames(transmission.probs))#
	transmission.probs[male.geno.3,colnames(transmission.probs) == "13" & transmitted.allele == 1] <- 1-D["3","13"]#
	transmission.probs[male.geno.3,colnames(transmission.probs) =="13" & transmitted.allele == 3] <- D["3","13"]#
#
	transmission.probs[male.geno.3,colnames(transmission.probs) == "12" & transmitted.allele == 1] <- 1-D["3","12"]#
	transmission.probs[male.geno.3,colnames(transmission.probs) =="12" & transmitted.allele == 2] <- D["3","12"]#
#
	transmission.probs[male.geno.3,colnames(transmission.probs) == "23" & transmitted.allele == 2] <- 1-D["3","23"]#
	transmission.probs[male.geno.3,colnames(transmission.probs) =="23" & transmitted.allele == 3] <- D["3","23"]#
	recover()#
transmission.probs#
}#
make.male.geno.dep.female.transmission.prob.w.dom<-function(D){#
 	geno.names<-c("11", "12","13", "22", "23", "33")#
	transmission.probs<-matrix(0.5,nrow=12,ncol=12)#
	rownames(transmission.probs)<-rep(geno.names,each=2)#
	colnames(transmission.probs)<-rep(geno.names,each=2)#
	transmitted.allele<-c(1,1,1,2,1,3,2,2,2,3,3,3)#
	transmission.probs[,colnames(transmission.probs) =="12" & transmitted.allele == 1] <- 1-D["1 or 2","12"]#
	transmission.probs[,colnames(transmission.probs) =="12" & transmitted.allele == 2] <- D["1 or 2","12"]#
#
	transmission.probs[,colnames(transmission.probs) =="13" & transmitted.allele == 1] <- 1-D["1 or 2","13"]#
	transmission.probs[,colnames(transmission.probs) =="13" & transmitted.allele == 3] <- D["1 or 2","13"]#
#
	transmission.probs[,colnames(transmission.probs) == "23" & transmitted.allele == 2] <- 1-D["1 or 2","23"]#
	transmission.probs[,colnames(transmission.probs) =="23" & transmitted.allele == 3] <- D["1 or 2","23"]#
	##males carrying allele 3 alter rate of female drive in dominant fashion. #
	male.heterozy<-rownames(transmission.probs) %in%  c("13","23")#
	male.homozy<-rownames(transmission.probs) =="33"#
	transmission.probs[male.heterozy,colnames(transmission.probs) == "13" & transmitted.allele == 1] <- 1-D["3.het","13"]#
	transmission.probs[male.heterozy,colnames(transmission.probs) =="13" & transmitted.allele == 3] <- D["3.het","13"]#
#
	transmission.probs[male.heterozy,colnames(transmission.probs) == "12" & transmitted.allele == 1] <- 1-D["3.het","12"]#
	transmission.probs[male.heterozy,colnames(transmission.probs) =="12" & transmitted.allele == 2] <- D["3.het","12"]#
#
	transmission.probs[male.heterozy,colnames(transmission.probs) == "23" & transmitted.allele == 2] <- 1-D["3.het","23"]#
	transmission.probs[male.heterozy,colnames(transmission.probs) =="23" & transmitted.allele == 3] <- D["3.het","23"]#
#
##homozy. male effect#
	transmission.probs[male.homozy,colnames(transmission.probs) == "13" & transmitted.allele == 1] <- 1-D["3","13"]#
	transmission.probs[male.homozy,colnames(transmission.probs) =="13" & transmitted.allele == 3] <- D["3","13"]#
#
	transmission.probs[male.homozy,colnames(transmission.probs) == "12" & transmitted.allele == 1] <- 1-D["3","12"]#
	transmission.probs[male.homozy,colnames(transmission.probs) =="12" & transmitted.allele == 2] <- D["3","12"]#
#
	transmission.probs[male.homozy,colnames(transmission.probs) == "23" & transmitted.allele == 2] <- 1-D["3","23"]#
	transmission.probs[male.homozy,colnames(transmission.probs) =="23" & transmitted.allele == 3] <- D["3","23"]#
#
#	recover()#
transmission.probs#
}#
run.iterations<-function(D,s.array,sperm.or.geno.dependent,num.iter=4000,plot.initial.rise=FALSE){#
	if(sperm.or.geno.dependent=="sperm"){ female.transmission.probs<-make.sperm.dep.female.transmission.prob(D)}#
	if(sperm.or.geno.dependent=="geno"){ female.transmission.probs<-make.male.geno.dep.female.transmission.prob(D)}#
	old.geno.freqs<-iterate.1.locus.drive(s.array,num.iterations=num.iter,female.transmission.probs=female.transmission.probs)#
	new.geno.freqs<-iterate.1.locus.drive(s.array=s.array,num.iterations=num.iter,female.transmission.probs=female.transmission.probs,my.geno.freqs=old.geno.freqs)#
	if(plot.initial.rise) new.geno.freqs[["allele.freqs"]]<-rbind(old.geno.freqs[["allele.freqs"]],new.geno.freqs[["allele.freqs"]])#
	plot.freqs(new.geno.freqs)#
}#
directory<-"~/Dropbox/Ideas/Om/scripts/"#
geno.names<-c("11", "12","13", "22", "23", "33")#
transmitted.allele<-c(1,1,1,2,1,3,2,2,2,3,3,3)#
####FUNCTIONS TO TEST WHETHER DRIVER SPREADS#
#### test.invasion.self.prop used to construct invasion diagrams, allele intro'd at freq. x#
#### checks whether it increases in frequency#
test.invasion.self.prop<-function(d,s.het,s.hom,x=.001,steps=10,sperm.or.male="sperm",selfing.rate=0){#
	s.array<-rep(0,6)#
	names(s.array)<-c("11","12","13","23","22","33")#
	s.array["13"]<- s.het#
	s.array["33"]<- s.hom#
	D<-matrix(1/2,nrow=2,ncol=3,dimnames=list(c("1 or 2","3"),c("12","13","23"))) ##entries are drive coeff of the 2nd #
	D["1 or 2","12"]<-0.5#
	D["1 or 2","13"]<-0.5#
	D["3","12"]<-.5#
	D["3","13"]<-d#
	D["1 or 2","23"]<- 1-0.5#
	D["3","23"]<-0.5#
	stopifnot(sperm.or.male=="sperm" | sperm.or.male=="male")#
	if(sperm.or.male=="sperm"){ female.transmission.probs<-make.sperm.dep.female.transmission.prob(D)}#
	if(sperm.or.male=="male"){ female.transmission.probs<-make.male.geno.dep.female.transmission.prob(D) }#
	old.geno.freqs<-iterate.1.locus.drive(s.array,num.iterations=steps,female.transmission.probs=female.transmission.probs,initialize.allele.freqs =c(1-x, 0,x),selfing.rate=selfing.rate)#
#recover()#
	invading<-old.geno.freqs[["allele.freqs"]][steps,3]>old.geno.freqs[["allele.freqs"]][1,3]#
	return(invading)#
}#
#
test.fixation.of.simple.driver<-function(d,s.het,s.hom,x=.999,steps=10,selfing.rate=0){#
	s.array<-rep(0,6)#
	names(s.array)<-c("11","12","13","23","22","33")#
	s.array["12"]<- s.het#
	s.array["22"]<- s.hom#
	D<-matrix(1/2,nrow=2,ncol=3,dimnames=list(c("1 or 2","3"),c("12","13","23"))) ##entries are drive coeff of the 2nd #
	D["1 or 2","12"]<- d#
	D["1 or 2","13"]<-0.5#
	D["3","12"]<- 0.5#
	D["3","13"]<- 0.5#
	D["1 or 2","23"]<- 1-0.5#
	D["3","23"]<-0.5#
	female.transmission.probs<-make.sperm.dep.female.transmission.prob(D)#
	old.geno.freqs<-iterate.1.locus.drive(s.array=s.array,num.iterations=steps,female.transmission.probs=female.transmission.probs,initialize.allele.freqs =c(1-x, x,0),selfing.rate=selfing.rate)#
	fixing<-old.geno.freqs[["allele.freqs"]][steps,2]>old.geno.freqs[["allele.freqs"]][1,2]#
	return(fixing)#
}
selfing.rate=0.05#
#
	D<-matrix(1/2,nrow=2,ncol=3,dimnames=list(c("1 or 2","3"),c("12","13","23"))) ##entries are drive coeff of the 2nd allele listed against the 1st.#
	d.range<-seq(0.5,1,length=200)#
	s3.range<-seq(0,1,length=200)#
	invasion.grid<-sapply(s3.range,function(s3){#
		sapply(d.range,function(d){#
			test.invasion.self.prop(d=d,s.het=0,s.hom=s3,selfing.rate=selfing.rate)#
		})#
	})#
	invasion.lines.s3.cutoff<-s3.range[apply(invasion.grid,1,function(x){max(which(x))})]#
	simple.fixation.grid<-sapply(s3.range,function(s3){#
		sapply(d.range,function(d){#
			test.fixation.of.simple.driver(d=d,s.het=0,s.hom=s3,selfing.rate=selfing.rate)#
		})#
	})#
	fixation.lines.s3<-s3.range[apply(simple.fixation.grid,1,function(x){max(which(x))})]#
#
	simple.invasion.grid<-sapply(s3.range,function(s3){#
		sapply(d.range,function(d){#
			test.fixation.of.simple.driver(d=d,s.het=0,s.hom=s3,x=0.01,selfing.rate=selfing.rate)#
		})#
	})#
	simple.invasion.lines.s3<-s3.range[apply(simple.invasion.grid,1,function(x){max(which(x))})]
plot(d.range,simple.invasion.lines.s3)
plot(d.range,simple.invasion.lines.s3,type="l")
lines(d.range,invasion.lines.s3.cutoff,type="l",col="red")
lines(d.range,fixation.lines.s3,type="l",col="green")
fixation.lines.s3
test.fixation.of.simple.driver(d=0.7,s.het=0,s.hom=0.01,selfing.rate=selfing.rate)
lines(d.range,(2*d.range- 1)/(4*d.range),col="green",lwd=3,lty=2) ##self prom. fixes below this line
plot(d.range,simple.invasion.lines.s3,type="l")
lines(d.range,fixation.lines.s3,type="l",col="green")
lines(d.range,invasion.lines.s3.cutoff,type="l",col="red")
lines(d.range,(2*d.range- 1)/(4*d.range),col="green",lwd=3,lty=2) ##self prom. fixes below this line
fixation.grid<-sapply(s3.range,function(s3){#
		sapply(d.range,function(d){#
			test.invasion.self.prop(d=d,s.het=0,s.hom=s3,x=0.999,selfing.rate=selfing.rate)#
		})#
	})#
	sp.fixation.lines.s3.cutoff<-s3.range[apply(fixation.grid,1,function(x){max(which(x))})]   ##below these s values self promotor can invade.
sp.fixation.lines.s3.cutoff
plot(d.range,simple.invasion.lines.s3,type="l")#
lines(d.range,invasion.lines.s3.cutoff,type="l",col="red")	#
lines(d.range,(2*d.range- 1)/(4*d.range),col="green",lwd=3,lty=2) ##self prom. fixes below this line
plot(d.range,simple.invasion.lines.s3,type="l",xlab="Drive, d",ylab="Homozyg. selection coeff")#
lines(d.range,invasion.lines.s3.cutoff,type="l",col="red")	#
lines(d.range,(2*d.range- 1)/(4*d.range),col="green",lwd=3,lty=2) ##self prom. fixes below this line
dev.copy2pdf(file-"~/Downloads/fig_for_Yaniv.pdf")
dev.copy2pdf(file="~/Downloads/fig_for_Yaniv.pdf")
700e3/4.8e6
10
.25/10
SQRT(.25/10)
sqrt(.25/10)
sqrt(.1/10)
library(devtools)#
install_github("fmichonneau/rncl")#
install_github("fmichonneau/rotl")
install.packages(devtools)
install.packages("devtools")
library(devtools)#
install_github("fmichonneau/rncl")#
install_github("fmichonneau/rotl")
=======
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = 0.01 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )
temp$hap.dist$no.sing.hap.count.freqs.by.interval
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)
sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}
matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)
matplot ( #
		NA , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)
col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )
matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)
col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
c
Q
##install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , display.rep.count = TRUE , time.factor = 1 ) {#
	options ( error = recover )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix , display.rep.count )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- temp [[ 2 ]]#
			# sweep.start.forward <- ncol ( frequencies ) - sweep.start #
			# # if ( nrow ( frequencies ) > 1 ) {#
			# fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			# zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			# entry <- numeric()#
			# for ( i in 1 : length ( zeros ) ){#
				# if ( length ( zeros [[ i ]] ) != 0 ) {#
					# entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				# } else {#
					# entry [ i ] <- 1#
				# }#
			# }#
			# transit.time <- fixation.time - entry#
			new.freqs <- temp [[ 1 ]]#
			# for ( i in 1 : nrow ( frequencies ) ) {#
				# new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			# }#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
		trees [[ i ]] [[ "sweep.start"]] <- sweep.start [ i ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f  )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
		#recover()#
		standing.hap.dist <- StandingHapCountDist ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , standing.hap.dist = standing.hap.dist , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , display.rep.count , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 & display.rep.count) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	sweep.start <- apply ( sweep.freq.matrix , 1 , function ( x ) which.max ( x ) / time.factor )#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
	if ( no.sweep == FALSE ) {#
		freq.traj.list <- mapply ( 	function ( X , Y ) {#
											#recover()#
											fixation <- which.max ( Y )#
											mutation <- sum ( X > 0 )#
											freq <- c ( rev ( Y [ 2 : fixation ] ) , X [ 1 : mutation ] )#
											return ( freq )#
										} ,#
										X = split ( neutral.freq.matrix , 1 : nrow ( neutral.freq.matrix ) ) , #
										Y = split ( sweep.freq.matrix , 1 : nrow ( sweep.freq.matrix ) )#
							)#
		freq.trajectories <- matrix ( 0 , ncol = max ( unlist ( lapply ( freq.traj.list , length ) ) ) , nrow = reps )#
		for ( i in seq_len ( nrow ( freq.trajectories ) ) ) {#
			freq.trajectories [ i , 1 : length ( freq.traj.list [[ i ]] ) ] <- freq.traj.list [[ i ]]#
		}#
		#freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	# temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	# add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	# temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	# freq.trajectories <- do.call ( rbind , temp2 )#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	#library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	no.sing.haps.right <- no.sing.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
			no.sing.haps.right [ , i ] <- no.sing.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.right [ j , i ] <- sum ( table ( my.seqs$right.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
					no.sing.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.left [ j , i ] <- sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
					no.sing.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	no.sing.haps <- rbind ( no.sing.haps.right , no.sing.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	no.sing.hap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , no.sing.hap.count.freqs.by.interval = no.sing.hap.count.freqs.by.interval , n.haps = n.haps , no.sing.haps = no.sing.haps ) )#
}#
StandingHapCountDist <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events#
				my.rec.events.off <- input [[ j ]] $ rec.events.off.background#
				# right side#
				sweep.recs <- my.rec.events$rec.right$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.right$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.right$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- extract.clade ( input [[ j ]]$tree , i )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				sweep.recs <- my.rec.events$rec.left$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.left$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.left$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- GetTips ( i , n.tips , input[[j]]$tree$edge )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	recover()#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		}#
	}#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
#
GetTips <- function ( branch , n.tips , edges ) {#
	#recover()#
	if ( branch <= n.tips ) {#
		return ( branch )#
	}#
	subtend <- edges [ edges [  , 1 ] == branch , 2 ]#
	if ( all ( subtend <= n.tips ) ) {#
		return ( subtend )#
	} else {#
		sapply ( subtend , function ( x ) GetTips ( x , n.tips , edges ) )#
	}#
}#
#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = FALSE ,  time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
#
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.05 , f = 0.01 , reps = 100 , n.tips = 12 , r = 10^-8 , sim.distance = 0.015 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)#
#
SequenceIBDPlots <- function ( trees ) {#
	#recover()#
	seq.structure <- trees$sequence.structure#
	seq.resort <- do.call(what = order, as.data.frame(seq.structure))#
	seq.structure <- lapply ( seq.structure , function ( x ) x [ seq.resort , ] )#
	rec.points <- trees$rec.events.off.background#
	scaled.rec.points <- list ()#
	scaled.rec.points$right <- c ( 0 , rec.points$rec.right.off.background$sequence.location / trees$sim.distance , 1 )#
	scaled.rec.points$left <- - c ( 0 , rec.points$rec.left.off.background$sequence.location / trees$sim.distance , 1 )#
	#my.cols <- rainbow ( max ( unlist ( seq.structure ) ) + 1 , alpha = 0.7 )#
	my.cols.right <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Paired" )#
	my.cols.left <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Set3" )#
	plot ( NA , bty = "n" , xlim = c ( -1 , 1 ) , ylim = c ( 0 , 12 ) , xaxt = "n" , yaxt = "n" , ylab = "" , xlab = "" )#
#
	### right side#
	for ( row in seq_len ( nrow ( seq.structure$right.seq ) ) ) {#
		my.recs <- unique ( seq.structure$right.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$right.seq[row,] ) , max ( unlist ( seq.structure$right.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.right [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	### left side#
	for ( row in seq_len ( nrow ( seq.structure$left.seq ) ) ) {#
		my.recs <- unique ( seq.structure$left.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$left.seq[row,] ) , max ( unlist ( seq.structure$left.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.left [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	abline ( v = 0 )#
}#
#
if ( FALSE) SequenceIBDPlots ( temp$trees[[1]] )#
par ( mfrow = c ( 3 ,2 ) )#
for ( i in 1 : 6 ) SequenceIBDPlots ( temp$trees[[i]] )#
###########################################
#### Let's think about inference w/ genealogies #####
###########################################
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
for ( i in 1 : length ( coal.times ) ) {#
	log.likes[[i]] <- lapply ( 1:nrow(coal.times[[i]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times[[i]] [ y , ] , x , 20000 ) ) )#
	print ( i )#
}#
#log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(z) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( z [ y , ] , x , 20000 ) ) )  )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = 0.01 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )
sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events#
				my.rec.events.off <- input [[ j ]] $ rec.events.off.background#
				# right side#
				sweep.recs <- my.rec.events$rec.right$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.right$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.right$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- extract.clade ( input [[ j ]]$tree , i )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.right.off.background$sequence.location < k )#
					my.tab <- table ( my.seqs$right.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] )#
					n.haps.right [ j , i ] <- sum ( my.tab > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				sweep.recs <- my.rec.events$rec.left$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.left$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.left$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- GetTips ( i , n.tips , input[[j]]$tree$edge )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.left.off.background$sequence.location < k )#
					my.tab <- table ( my.seqs$left.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] )#
					n.haps.left [ j , i ] <-  sum ( my.tab > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)
n.haps <- rbind ( n.haps.right , n.haps.left )
hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )
hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )
hap.count.freqs.by.interval
MakeHapPlots ( hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)
sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}
ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )
matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
##install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , display.rep.count = TRUE , time.factor = 1 ) {#
	options ( error = recover )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix , display.rep.count )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- temp [[ 2 ]]#
			# sweep.start.forward <- ncol ( frequencies ) - sweep.start #
			# # if ( nrow ( frequencies ) > 1 ) {#
			# fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			# zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			# entry <- numeric()#
			# for ( i in 1 : length ( zeros ) ){#
				# if ( length ( zeros [[ i ]] ) != 0 ) {#
					# entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				# } else {#
					# entry [ i ] <- 1#
				# }#
			# }#
			# transit.time <- fixation.time - entry#
			new.freqs <- temp [[ 1 ]]#
			# for ( i in 1 : nrow ( frequencies ) ) {#
				# new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			# }#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
		trees [[ i ]] [[ "sweep.start"]] <- sweep.start [ i ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f  )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
		#recover()#
		standing.hap.dist <- StandingHapCountDist ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , standing.hap.dist = standing.hap.dist , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , display.rep.count , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 & display.rep.count) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	sweep.start <- apply ( sweep.freq.matrix , 1 , function ( x ) which.max ( x ) / time.factor )#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
	if ( no.sweep == FALSE ) {#
		freq.traj.list <- mapply ( 	function ( X , Y ) {#
											#recover()#
											fixation <- which.max ( Y )#
											mutation <- sum ( X > 0 )#
											freq <- c ( rev ( Y [ 2 : fixation ] ) , X [ 1 : mutation ] )#
											return ( freq )#
										} ,#
										X = split ( neutral.freq.matrix , 1 : nrow ( neutral.freq.matrix ) ) , #
										Y = split ( sweep.freq.matrix , 1 : nrow ( sweep.freq.matrix ) )#
							)#
		freq.trajectories <- matrix ( 0 , ncol = max ( unlist ( lapply ( freq.traj.list , length ) ) ) , nrow = reps )#
		for ( i in seq_len ( nrow ( freq.trajectories ) ) ) {#
			freq.trajectories [ i , 1 : length ( freq.traj.list [[ i ]] ) ] <- freq.traj.list [[ i ]]#
		}#
		#freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	# temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	# add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	# temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	# freq.trajectories <- do.call ( rbind , temp2 )#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	#library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	no.sing.haps.right <- no.sing.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
			no.sing.haps.right [ , i ] <- no.sing.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.right [ j , i ] <- sum ( table ( my.seqs$right.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
					no.sing.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.left [ j , i ] <- sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
					no.sing.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	no.sing.haps <- rbind ( no.sing.haps.right , no.sing.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	no.sing.hap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , no.sing.hap.count.freqs.by.interval = no.sing.hap.count.freqs.by.interval , n.haps = n.haps , no.sing.haps = no.sing.haps ) )#
}#
StandingHapCountDist <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events#
				my.rec.events.off <- input [[ j ]] $ rec.events.off.background#
				# right side#
				sweep.recs <- my.rec.events$rec.right$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.right$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.right$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- extract.clade ( input [[ j ]]$tree , i )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.right.off.background$sequence.location < k )#
					my.tab <- table ( my.seqs$right.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] )#
					n.haps.right [ j , i ] <- sum ( my.tab > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				sweep.recs <- my.rec.events$rec.left$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.left$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.left$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- GetTips ( i , n.tips , input[[j]]$tree$edge )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.left.off.background$sequence.location < k )#
					my.tab <- table ( my.seqs$left.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] )#
					n.haps.left [ j , i ] <-  sum ( my.tab > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	recover()#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		}#
	}#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
#
GetTips <- function ( branch , n.tips , edges ) {#
	#recover()#
	if ( branch <= n.tips ) {#
		return ( branch )#
	}#
	subtend <- edges [ edges [  , 1 ] == branch , 2 ]#
	if ( all ( subtend <= n.tips ) ) {#
		return ( subtend )#
	} else {#
		sapply ( subtend , function ( x ) GetTips ( x , n.tips , edges ) )#
	}#
}#
#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = FALSE ,  time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
#
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.05 , f = 0.01 , reps = 100 , n.tips = 12 , r = 10^-8 , sim.distance = 0.015 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)#
#
SequenceIBDPlots <- function ( trees ) {#
	#recover()#
	seq.structure <- trees$sequence.structure#
	seq.resort <- do.call(what = order, as.data.frame(seq.structure))#
	seq.structure <- lapply ( seq.structure , function ( x ) x [ seq.resort , ] )#
	rec.points <- trees$rec.events.off.background#
	scaled.rec.points <- list ()#
	scaled.rec.points$right <- c ( 0 , rec.points$rec.right.off.background$sequence.location / trees$sim.distance , 1 )#
	scaled.rec.points$left <- - c ( 0 , rec.points$rec.left.off.background$sequence.location / trees$sim.distance , 1 )#
	#my.cols <- rainbow ( max ( unlist ( seq.structure ) ) + 1 , alpha = 0.7 )#
	my.cols.right <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Paired" )#
	my.cols.left <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Set3" )#
	plot ( NA , bty = "n" , xlim = c ( -1 , 1 ) , ylim = c ( 0 , 12 ) , xaxt = "n" , yaxt = "n" , ylab = "" , xlab = "" )#
#
	### right side#
	for ( row in seq_len ( nrow ( seq.structure$right.seq ) ) ) {#
		my.recs <- unique ( seq.structure$right.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$right.seq[row,] ) , max ( unlist ( seq.structure$right.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.right [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	### left side#
	for ( row in seq_len ( nrow ( seq.structure$left.seq ) ) ) {#
		my.recs <- unique ( seq.structure$left.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$left.seq[row,] ) , max ( unlist ( seq.structure$left.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.left [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	abline ( v = 0 )#
}#
#
if ( FALSE) SequenceIBDPlots ( temp$trees[[1]] )#
par ( mfrow = c ( 3 ,2 ) )#
for ( i in 1 : 6 ) SequenceIBDPlots ( temp$trees[[i]] )#
###########################################
#### Let's think about inference w/ genealogies #####
###########################################
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
for ( i in 1 : length ( coal.times ) ) {#
	log.likes[[i]] <- lapply ( 1:nrow(coal.times[[i]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times[[i]] [ y , ] , x , 20000 ) ) )#
	print ( i )#
}#
#log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(z) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( z [ y , ] , x , 20000 ) ) )  )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = 0.05 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.02 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.05, sim.distance = 0.02)
sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}
ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )
for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		}#
	}
if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }
matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)
col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
Q
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = 0.02 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.02, sim.distance = 0.05)
##install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , display.rep.count = TRUE , time.factor = 1 ) {#
	options ( error = recover )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix , display.rep.count )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- temp [[ 2 ]]#
			# sweep.start.forward <- ncol ( frequencies ) - sweep.start #
			# # if ( nrow ( frequencies ) > 1 ) {#
			# fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			# zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			# entry <- numeric()#
			# for ( i in 1 : length ( zeros ) ){#
				# if ( length ( zeros [[ i ]] ) != 0 ) {#
					# entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				# } else {#
					# entry [ i ] <- 1#
				# }#
			# }#
			# transit.time <- fixation.time - entry#
			new.freqs <- temp [[ 1 ]]#
			# for ( i in 1 : nrow ( frequencies ) ) {#
				# new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			# }#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
		trees [[ i ]] [[ "sweep.start"]] <- sweep.start [ i ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f  )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
		#recover()#
		standing.hap.dist <- StandingHapCountDist ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , standing.hap.dist = standing.hap.dist , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , display.rep.count , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 & display.rep.count) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	sweep.start <- apply ( sweep.freq.matrix , 1 , function ( x ) which.max ( x ) / time.factor )#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
	if ( no.sweep == FALSE ) {#
		freq.traj.list <- mapply ( 	function ( X , Y ) {#
											#recover()#
											fixation <- which.max ( Y )#
											mutation <- sum ( X > 0 )#
											freq <- c ( rev ( Y [ 2 : fixation ] ) , X [ 1 : mutation ] )#
											return ( freq )#
										} ,#
										X = split ( neutral.freq.matrix , 1 : nrow ( neutral.freq.matrix ) ) , #
										Y = split ( sweep.freq.matrix , 1 : nrow ( sweep.freq.matrix ) )#
							)#
		freq.trajectories <- matrix ( 0 , ncol = max ( unlist ( lapply ( freq.traj.list , length ) ) ) , nrow = reps )#
		for ( i in seq_len ( nrow ( freq.trajectories ) ) ) {#
			freq.trajectories [ i , 1 : length ( freq.traj.list [[ i ]] ) ] <- freq.traj.list [[ i ]]#
		}#
		#freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	# temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	# add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	# temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	# freq.trajectories <- do.call ( rbind , temp2 )#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	#library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	no.sing.haps.right <- no.sing.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
			no.sing.haps.right [ , i ] <- no.sing.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.right [ j , i ] <- sum ( table ( my.seqs$right.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
					no.sing.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.left [ j , i ] <- sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
					no.sing.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	no.sing.haps <- rbind ( no.sing.haps.right , no.sing.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	no.sing.hap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , no.sing.hap.count.freqs.by.interval = no.sing.hap.count.freqs.by.interval , n.haps = n.haps , no.sing.haps = no.sing.haps ) )#
}#
StandingHapCountDist <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events#
				my.rec.events.off <- input [[ j ]] $ rec.events.off.background#
				# right side#
				sweep.recs <- my.rec.events$rec.right$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.right$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.right$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- extract.clade ( input [[ j ]]$tree , i )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.right.off.background$sequence.location < k )#
					my.tab <- table ( my.seqs$right.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] )#
					n.haps.right [ j , i ] <- sum ( my.tab > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				sweep.recs <- my.rec.events$rec.left$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.left$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.left$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- GetTips ( i , n.tips , input[[j]]$tree$edge )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.left.off.background$sequence.location < k )#
					my.tab <- table ( my.seqs$left.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] )#
					n.haps.left [ j , i ] <-  sum ( my.tab > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#recover()#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	#stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		# }#
	# }#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
#
GetTips <- function ( branch , n.tips , edges ) {#
	#recover()#
	if ( branch <= n.tips ) {#
		return ( branch )#
	}#
	subtend <- edges [ edges [  , 1 ] == branch , 2 ]#
	if ( all ( subtend <= n.tips ) ) {#
		return ( subtend )#
	} else {#
		sapply ( subtend , function ( x ) GetTips ( x , n.tips , edges ) )#
	}#
}#
#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = FALSE ,  time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
#
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.05 , f = 0.01 , reps = 100 , n.tips = 12 , r = 10^-8 , sim.distance = 0.015 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)#
#
SequenceIBDPlots <- function ( trees ) {#
	#recover()#
	seq.structure <- trees$sequence.structure#
	seq.resort <- do.call(what = order, as.data.frame(seq.structure))#
	seq.structure <- lapply ( seq.structure , function ( x ) x [ seq.resort , ] )#
	rec.points <- trees$rec.events.off.background#
	scaled.rec.points <- list ()#
	scaled.rec.points$right <- c ( 0 , rec.points$rec.right.off.background$sequence.location / trees$sim.distance , 1 )#
	scaled.rec.points$left <- - c ( 0 , rec.points$rec.left.off.background$sequence.location / trees$sim.distance , 1 )#
	#my.cols <- rainbow ( max ( unlist ( seq.structure ) ) + 1 , alpha = 0.7 )#
	my.cols.right <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Paired" )#
	my.cols.left <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Set3" )#
	plot ( NA , bty = "n" , xlim = c ( -1 , 1 ) , ylim = c ( 0 , 12 ) , xaxt = "n" , yaxt = "n" , ylab = "" , xlab = "" )#
#
	### right side#
	for ( row in seq_len ( nrow ( seq.structure$right.seq ) ) ) {#
		my.recs <- unique ( seq.structure$right.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$right.seq[row,] ) , max ( unlist ( seq.structure$right.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.right [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	### left side#
	for ( row in seq_len ( nrow ( seq.structure$left.seq ) ) ) {#
		my.recs <- unique ( seq.structure$left.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$left.seq[row,] ) , max ( unlist ( seq.structure$left.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.left [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	abline ( v = 0 )#
}#
#
if ( FALSE) SequenceIBDPlots ( temp$trees[[1]] )#
par ( mfrow = c ( 3 ,2 ) )#
for ( i in 1 : 6 ) SequenceIBDPlots ( temp$trees[[i]] )#
###########################################
#### Let's think about inference w/ genealogies #####
###########################################
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
for ( i in 1 : length ( coal.times ) ) {#
	log.likes[[i]] <- lapply ( 1:nrow(coal.times[[i]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times[[i]] [ y , ] , x , 20000 ) ) )#
	print ( i )#
}#
#log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(z) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( z [ y , ] , x , 20000 ) ) )  )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.02, sim.distance = 0.05)
names ( temp)
names ( temp$hap.dist)
names ( temp$standing.hap.dist)
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.02, sim.distance = 0.05)
##install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , display.rep.count = TRUE , time.factor = 1 ) {#
	options ( error = recover )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix , display.rep.count )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- temp [[ 2 ]]#
			# sweep.start.forward <- ncol ( frequencies ) - sweep.start #
			# # if ( nrow ( frequencies ) > 1 ) {#
			# fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			# zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			# entry <- numeric()#
			# for ( i in 1 : length ( zeros ) ){#
				# if ( length ( zeros [[ i ]] ) != 0 ) {#
					# entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				# } else {#
					# entry [ i ] <- 1#
				# }#
			# }#
			# transit.time <- fixation.time - entry#
			new.freqs <- temp [[ 1 ]]#
			# for ( i in 1 : nrow ( frequencies ) ) {#
				# new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			# }#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
		trees [[ i ]] [[ "sweep.start"]] <- sweep.start [ i ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f  )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
		#recover()#
		standing.hap.dist <- StandingHapCountDist ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , standing.hap.dist = standing.hap.dist , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , display.rep.count , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 & display.rep.count) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	sweep.start <- apply ( sweep.freq.matrix , 1 , function ( x ) which.max ( x ) / time.factor )#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
	if ( no.sweep == FALSE ) {#
		freq.traj.list <- mapply ( 	function ( X , Y ) {#
											#recover()#
											fixation <- which.max ( Y )#
											mutation <- sum ( X > 0 )#
											freq <- c ( rev ( Y [ 2 : fixation ] ) , X [ 1 : mutation ] )#
											return ( freq )#
										} ,#
										X = split ( neutral.freq.matrix , 1 : nrow ( neutral.freq.matrix ) ) , #
										Y = split ( sweep.freq.matrix , 1 : nrow ( sweep.freq.matrix ) )#
							)#
		freq.trajectories <- matrix ( 0 , ncol = max ( unlist ( lapply ( freq.traj.list , length ) ) ) , nrow = reps )#
		for ( i in seq_len ( nrow ( freq.trajectories ) ) ) {#
			freq.trajectories [ i , 1 : length ( freq.traj.list [[ i ]] ) ] <- freq.traj.list [[ i ]]#
		}#
		#freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	# temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	# add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	# temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	# freq.trajectories <- do.call ( rbind , temp2 )#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	#library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	no.sing.haps.right <- no.sing.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
			no.sing.haps.right [ , i ] <- no.sing.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.right [ j , i ] <- sum ( table ( my.seqs$right.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
					no.sing.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.left [ j , i ] <- sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
					no.sing.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	no.sing.haps <- rbind ( no.sing.haps.right , no.sing.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	no.sing.hap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , no.sing.hap.count.freqs.by.interval = no.sing.hap.count.freqs.by.interval , n.haps = n.haps , no.sing.haps = no.sing.haps ) )#
}#
StandingHapCountDist <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events#
				my.rec.events.off <- input [[ j ]] $ rec.events.off.background#
				# right side#
				sweep.recs <- my.rec.events$rec.right$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.right$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.right$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- extract.clade ( input [[ j ]]$tree , i )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.right.off.background$sequence.location < k )#
					my.tab <- table ( my.seqs$right.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] )#
					n.haps.right [ j , i ] <- sum ( my.tab > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				sweep.recs <- my.rec.events$rec.left$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.left$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.left$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- GetTips ( i , n.tips , input[[j]]$tree$edge )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.left.off.background$sequence.location < k )#
					my.tab <- table ( my.seqs$left.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] )#
					n.haps.left [ j , i ] <-  sum ( my.tab > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#recover()#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	#stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		# }#
	# }#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
#
GetTips <- function ( branch , n.tips , edges ) {#
	#recover()#
	if ( branch <= n.tips ) {#
		return ( branch )#
	}#
	subtend <- edges [ edges [  , 1 ] == branch , 2 ]#
	if ( all ( subtend <= n.tips ) ) {#
		return ( subtend )#
	} else {#
		sapply ( subtend , function ( x ) GetTips ( x , n.tips , edges ) )#
	}#
}#
#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = FALSE ,  time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
#
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.05 , f = 0.01 , reps = 100 , n.tips = 12 , r = 10^-8 , sim.distance = 0.015 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)#
#
SequenceIBDPlots <- function ( trees ) {#
	#recover()#
	seq.structure <- trees$sequence.structure#
	seq.resort <- do.call(what = order, as.data.frame(seq.structure))#
	seq.structure <- lapply ( seq.structure , function ( x ) x [ seq.resort , ] )#
	rec.points <- trees$rec.events.off.background#
	scaled.rec.points <- list ()#
	scaled.rec.points$right <- c ( 0 , rec.points$rec.right.off.background$sequence.location / trees$sim.distance , 1 )#
	scaled.rec.points$left <- - c ( 0 , rec.points$rec.left.off.background$sequence.location / trees$sim.distance , 1 )#
	#my.cols <- rainbow ( max ( unlist ( seq.structure ) ) + 1 , alpha = 0.7 )#
	my.cols.right <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Paired" )#
	my.cols.left <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Set3" )#
	plot ( NA , bty = "n" , xlim = c ( -1 , 1 ) , ylim = c ( 0 , 12 ) , xaxt = "n" , yaxt = "n" , ylab = "" , xlab = "" )#
#
	### right side#
	for ( row in seq_len ( nrow ( seq.structure$right.seq ) ) ) {#
		my.recs <- unique ( seq.structure$right.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$right.seq[row,] ) , max ( unlist ( seq.structure$right.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.right [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	### left side#
	for ( row in seq_len ( nrow ( seq.structure$left.seq ) ) ) {#
		my.recs <- unique ( seq.structure$left.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$left.seq[row,] ) , max ( unlist ( seq.structure$left.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.left [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	abline ( v = 0 )#
}#
#
if ( FALSE) SequenceIBDPlots ( temp$trees[[1]] )#
par ( mfrow = c ( 3 ,2 ) )#
for ( i in 1 : 6 ) SequenceIBDPlots ( temp$trees[[i]] )#
###########################################
#### Let's think about inference w/ genealogies #####
###########################################
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
for ( i in 1 : length ( coal.times ) ) {#
	log.likes[[i]] <- lapply ( 1:nrow(coal.times[[i]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times[[i]] [ y , ] , x , 20000 ) ) )#
	print ( i )#
}#
#log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(z) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( z [ y , ] , x , 20000 ) ) )  )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = 0.03 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 5000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.03, sim.distance = 0.05)
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.03, sim.distance = 0.05 , interval.width = 5000 )
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = 0.04 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 5000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.04, sim.distance = 0.05 , interval.width = 5000 )
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = 0.05 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.02 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.05, sim.distance = 0.05 , interval.width = 5000 )
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.05, sim.distance = 0.05 , interval.width = 5000 )
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = 0.05 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.05, sim.distance = 0.05 , interval.width = 5000 )
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.05, sim.distance = 0.05 , interval.width = 1000 )
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.03 , f = 0.01 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 10000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05 , interval.width = 10000)
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.03 , f = 0.02 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 10000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.02, sim.distance = 0.05 , interval.width = 10000)
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.03 , f = 0.03 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 10000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.03, sim.distance = 0.05 , interval.width = 10000)
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.03 , f = 0.04 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 10000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.04, sim.distance = 0.05 , interval.width = 10000)
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#recover()#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	#stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		# }#
	# }#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 ) , #
		xaxt = ""#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.03 , f = 0.04 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 10000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.04, sim.distance = 0.05 , interval.width = 10000)
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.04, sim.distance = 0.05 , interval.width = 10000)
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#recover()#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	#stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		# }#
	# }#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 ) , #
		xaxt = "n"#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.04, sim.distance = 0.05 , interval.width = 10000)
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	#stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		# }#
	# }#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	recover()#
<<<<<<< HEAD
#####
	ts_mean <- (n_pop - 1 ) * ( p_bars * ( 1 - p_bars ) - rowMeans ( new_ps * ( 1 - new_ps ) ) ) / ( Fst * p_bars * ( 1 - p_bars ) )#
	hist ( ts_mean , breaks = 50 , freq = F )#
	curve ( dchisq ( x , n_pop - 1  ) , add = T , col = "red")#
	#####
	var_mean <- rowSums ( ( new_ps- p_bars )^2 ) / ( Fst * p_bars * ( 1 - p_bars ) )#
	hist ( var_mean , breaks = 50 , freq = F )#
	curve ( dchisq ( x , n_pop - 1  ) , add = T , col = "red")#
	#####
	ts_true <- (n_pop ) * ( p * ( 1 - p ) - rowMeans ( new_ps * ( 1 - new_ps ) ) )  / ( Fst * ( p * ( 1 - p ) ) )#
	hist ( ts_true , breaks = 50 , freq = F )#
	curve ( dchisq ( x , n_pop  ) , add = T , col = "red")#
	#####
	var_true <- rowSums ( ( new_ps- p )^2 ) / ( Fst * p * ( 1 - p ) )#
	hist ( var_true , breaks = 50 , freq = F )#
	curve ( dchisq ( x , n_pop  ) , add = T , col = "red")#
	hist ( ts_true , breaks = 50 , freq = F , col = rgb ( 1 , 0 , 0 , 0.4 ) )#
	hist ( ts_true , breaks = 50 , freq = F , col = rgb ( 1 , 0 , 0 , 0.4 ) )#
#
}#
MakeVar ( 0.5 , 10000 , 0.01 , 2 , rand = T , n_loc = 10 )
hist ( my.stat , breaks = 50 , freq = F)
curve ( dnorm ( x , mean ( my.stat ), sd ( my.stat )) , add = T , col = "red")
p=0.45
p <- matrix ( p	, nrow = n_loc , ncol = n_rep )#
		new_ps <- apply ( p , 2 , function ( x ) x + rmvnorm ( 1 , sigma = Fst * x * ( 1 - x ) * diag ( n_loc ) ) )#
		new_ps <- ifelse ( new_ps < 0 , 0 , new_ps)#
		new_ps <- ifelse ( new_ps > 1 , 1 , new_ps)#
		vars_t <- colSums ( new_ps * ( 1 - new_ps ) )#
		vars_start <- colSums ( p * ( 1 - p ) )#
		my.stat <- ( vars_start - vars_t ) / ( Fst * vars_start )
hist ( my.stat , breaks = 50 , freq = F)
curve ( dnorm ( x , mean ( my.stat ), sd ( my.stat )) , add = T , col = "red")
p <- numeric ( n_loc * n_rep )
p
tmp <- runif ( )
tmp <- runif ( 1 )
tmp
blah <- integrate( function ( x ) 1/ x  , 0 , 1 )
blah <- integrate( function ( x ) 1/ x  , 0.00001 , 1 )
blah
integrate( function ( x ) 1/ x  , 0.000001 , 1 )
integrate( function ( x ) 1/ x  , 0.0000001 , 1 )
integrate( function ( x ) 1/ x  , 0.00000001 , 1 )
1/20000
integrate( function ( x ) 1/ x  , 1/20000 , 19999/20000 )
tmp <- runif ( 1 )
tmp
denom <- integrate( function ( x ) 1/ x  , 1/20000 , 19999/20000 )
1/tmp
(1/tmp)/denom
denom
names(denom)
denom$value
(1/tmp)/denom$value
n_rep
tmp
p <- numeric ( n_loc * n_rep )
i = 1 #
		while ( i <= n_loc * n_rep ) {#
			tmp <- runif ( 1 )#
			denom <- integrate( function ( x ) 1/ x  , 1/20000 , 19999/20000 )#
			if ( runif ( 1 ) < (1/tmp)/denom$value ) {#
				p [ i ] <- tmp#
				i <- i + 1#
			} else {#
				next#
			}#
		}
p
hist ( p , breaks = 500 , freq = F)
hist ( p , breaks = 50 , freq = F)
tmp =0.0001
denom
denom <- integrate( function ( x ) 1/ x  , 1/20000 , 19999/20000 )
denom
1/tmp
(1/tmp)/denom$value
tmp
tmp = 0.0000001
tmp < 1/20000
p <- numeric ( n_loc * n_rep )#
		i = 1 #
		while ( i <= n_loc * n_rep ) {#
			tmp <- runif ( 1 )#
			if ( tmp < 1/20000 | tmp > ( 1 - 1/20000 ) ) next#
			denom <- integrate( function ( x ) 1/ x  , 1/20000 , 19999/20000 )#
			if ( runif ( 1 ) < (1/tmp)/denom$value ) {#
				p [ i ] <- tmp#
				i <- i + 1#
			} else {#
				next#
			}#
		}
p
hist ( p , breaks = 50)
denom <- integrate( function ( x ) 1/ x  , 0.00000000000000001 , 1 )
denom
p <- numeric ( n_loc * n_rep )#
		i = 1 #
		denom <- integrate( function ( x ) 1/ x  , 0.00000000000000001 , 1 )#
		while ( i <= n_loc * n_rep ) {#
			tmp <- runif ( 1 )#
			if ( tmp < 1/20000 | tmp > ( 1 - 1/20000 ) ) next#
			if ( runif ( 1 ) < (1/tmp)/denom$value ) {#
				p [ i ] <- tmp#
				i <- i + 1#
			} else {#
				next#
			}#
		}
p
SoftSweepSim <- function ( N_A , N_a , s1 , s2 = NULL , h , switch = 0 , mu , gens , mut.index = 1001 , stop.at.fix = TRUE , reuse.mutant.classes = FALSE , suppress.output = FALSE , suppress.plot = FALSE , sort.mutation.time = FALSE ) {#
	options ( error = recover )#
	###########################
	####### Initialize ########
	##########################	#
	num.A.class <- length ( N_A )#
	num.a.class <- length ( N_a )#
	pA.vect <- matrix ( c ( N_A / sum ( N_A , N_a ), rep ( 0, length ( N_A ) ) ) , nrow = num.A.class , ncol = 1 )	#
	pa.vect <- matrix ( c ( N_a / sum ( N_A , N_a ), rep ( 0, length ( N_a ) ) ) , nrow = num.a.class , ncol = 1 )	#
	A.classes <- 1 : num.A.class#
	a.classes <- mut.index : ( mut.index + num.a.class -1 )#
	if ( switch > 0 ){#
		s <- s1#
	} else {#
		s <- s2#
	}#
	allele.classes.all <- c ( A.classes , mut.index : ( mut.index + ( num.a.class - 1 ) ) )#
	pA.presel <- matrix ( N_A / sum ( N_A , N_a ) )#
	pa.presel <- matrix ( N_a / sum ( N_A , N_a ) )#
	###########################
	####### Simulation ########
	###########################
	i <- 1#
	while ( ( sum ( pa.vect [ , i ] ) < 1 | stop.at.fix == FALSE ) & i < gens ) {#
		if ( mu == 0 & sum ( N_a ) == 0 ) {#
			cat ( "Allele lost from population. \n")#
			return()#
		}#
		################
		## selection ###
		################
		pA.vect <- cbind ( pA.vect , 0 )#
		pa.vect <- cbind ( pa.vect , 0 )#
		pA.temp <- rowSums ( pA.presel %*% t ( pA.presel ) ) + rowSums ( pA.presel %*% t ( pa.presel ) ) * ( 1 + s )#
		pa.temp <- colSums ( pa.presel %*% t ( pa.presel ) ) * ( 1 + 2*s ) + colSums ( pA.presel %*% t ( pa.presel ) ) * ( 1 + s )#
		mean.fitness <- sum( pA.presel %*% t ( pA.presel ) ) + 2*sum ( pA.presel %*% t ( pa.presel ) )*( 1 + s ) + sum( pa.presel %*% t ( pa.presel ) ) * ( 1 + 2*s )#
		pA.postsel <- pA.temp / mean.fitness#
		pa.postsel <- pa.temp / mean.fitness#
		pA.vect [ , i + 1 ] <- pA.postsel#
		pa.vect [ , i + 1 ] <- c ( pa.postsel , rep ( 0 , nrow ( pa.vect ) - length ( pa.postsel ) ) )#
		############
		## drift ###
		############
		next.gen <- sample ( c ( A.classes , a.classes ) , size = sum ( N_A , N_a ) , prob = c ( pA.vect [ , i + 1 ] , pa.vect [ , i + 1 ] ) , replace = TRUE )#
		next.gen <- sort ( next.gen )#
		allele.classes.present <- rle ( next.gen )$values#
		allele.classes.absent <- allele.classes.all [ allele.classes.all %in% allele.classes.present == FALSE ]#
		allele.abundance <- c ( rle ( next.gen )$lengths , rep ( 0 , length ( allele.classes.absent ) ) )#
		allele.classes.all <- c ( allele.classes.present , allele.classes.absent )#
		allele.abundance <- allele.abundance [ order ( allele.classes.all ) ]#
		allele.classes.all <- allele.classes.all [ order ( allele.classes.all ) ]#
		A.classes <- allele.classes.all [ allele.classes.all < mut.index ] #
		a.classes <- allele.classes.all [ allele.classes.all >= mut.index ] #
		N_A <- allele.abundance [ allele.classes.all < mut.index ]#
		N_a <- allele.abundance [ allele.classes.all >= mut.index ]#
		pA.premut <- matrix ( N_A / sum ( N_A , N_a ) )#
		pa.premut <- matrix ( N_a / sum ( N_A , N_a ) )		#
		###############
		## mutation ###
		###############
		if ( mu != 0 ) {#
			## roll N_total uniform random numbers; the number that are less than 	#
			mut.probs <- runif ( n = sum ( N_A , N_a ) )#
			new.mutations <- sum ( mut.probs < mu )#
			if ( new.mutations != 0 ) {#
				# let the mutations pick parents in proportion to their frequency#
				mut.from <- sort ( sample ( c ( rep ( A.classes , times = N_A ) , rep ( a.classes , times = N_a ) ) , size = new.mutations , replace = FALSE ) )#
				mutating.alleles <- rle ( mut.from )$values#
				non.mutating.alleles <- allele.classes.all [ allele.classes.all %in% mutating.alleles == FALSE ]#
				mutation.counts.all.alleles <- c ( rle ( mut.from )$lengths , rep ( 0 , length ( non.mutating.alleles ) ) )#
				mutation.id.all.alleles <- c ( mutating.alleles , non.mutating.alleles )#
				mutation.counts.all.alleles <- mutation.counts.all.alleles [ order ( mutation.id.all.alleles ) ]#
				mutation.id.all.alleles <- mutation.id.all.alleles [ order ( mutation.id.all.alleles ) ]#
				mut.from.A <- mutation.counts.all.alleles [ mutation.id.all.alleles < mut.index ]#
				mut.from.a <- mutation.counts.all.alleles [ mutation.id.all.alleles >= mut.index ]#
				if ( reuse.mutant.classes == TRUE ) {#
					idx <- c( a.classes [ N_a == 0 ] , ( max ( mutation.id.all.alleles ) + 1 ) : ( max ( mutation.id.all.alleles ) + new.mutations ) )#
					new.mut.idx <- idx [ 1 : new.mutations ]#
					new.IDs <- new.mut.idx [ new.mut.idx %in% a.classes == FALSE ]#
				} else if ( reuse.mutant.classes == FALSE ) {#
					new.mut.idx <- new.IDs <- ( max ( mutation.id.all.alleles ) + 1 ) : ( max ( mutation.id.all.alleles ) + new.mutations )#
				}#
				a.classes <- c ( a.classes, new.IDs )#
				N_a <- c ( N_a , rep ( 0 , length ( new.IDs ) ) )#
				pa.vect <- rbind ( pa.vect , matrix ( 0 , nrow = length ( new.IDs ) , ncol = ncol ( pa.vect ) ) )#
				N_a [ a.classes %in% new.mut.idx ] <- 1#
				N_A <- N_A - mut.from.A#
				N_a [ a.classes %in% new.IDs == FALSE ] <- N_a [ a.classes %in% new.IDs == FALSE ] - mut.from.a#
				allele.classes.all <- c ( A.classes , a.classes )#
			}#
		}#
		##################
		## bookkeeping ###
		#################		#
		if ( i == switch & is.null ( s2 ) == FALSE ) {#
			s <-  s2 #
		}#
		i <- i + 1#
		pA.presel <- matrix ( N_A / sum ( N_A , N_a ) )#
		pa.presel <- matrix ( N_a / sum ( N_A , N_a ) )#
		if ( i %% 20 == 0 & suppress.output == FALSE ){#
			cat (  i , "p =" , sum ( pa.vect [ , i ] ) , "\n" )#
		}#
	}#
	if ( switch > 100 ) {#
		pre.switch.freqs <- pa.vect [ , 101:switch ]#
	} else {#
		pre.switch.freqs <- NULL#
		mean.coal.prob.sim.mut.sel.drift <- NULL#
		coal.prob.sim.mut.sel.drift <- NULL#
	}#
	###########################
	##### End Point Data ######
	###########################
	pA.order <- order ( pA.vect [ , ncol ( pA.vect ) ] , decreasing = FALSE ) #
	pa.order <- order ( pa.vect [ , ncol ( pa.vect ) ] , decreasing = FALSE )#
	pa.lost <-  which ( pa.vect [ , ncol ( pa.vect ) ] == 0 )#
	pa.fixed <- which ( pa.vect [ , ncol ( pa.vect ) ] != 0 )#
	all.freqs <- rbind ( pa.vect [ pa.order , ] , pA.vect [ pA.order , ] )#
	all.freqs.unsorted <- rbind ( pa.vect , pA.vect )#
	###########################
	######## Plotting #########
	###########################
	if ( suppress.plot == FALSE ) {#
		if ( reuse.mutant.classes == TRUE ) {	#
			#recover()#
			cum.freqs <- rbind ( 0 , apply ( all.freqs , 2 , cumsum ))#
			green.mat <- matrix ( c ( rep ( 0 , length ( pa.order ) + 1 ) , seq ( from = .3 , to = 1 , length.out = length ( pa.order ) + 1 ) , rep ( 0 , length ( pa.order ) +1 ) ) , nrow = length ( pa.order ) + 1 )#
			blue.mat <- matrix ( c ( rep ( 0 , 2 * length ( pA.order ) ) , seq ( from = .7 , to = 1 , length.out = length ( pA.order ) ) ) , nrow = length ( pA.order ) )#
			col.vect <- rgb ( rbind ( green.mat , blue.mat) , alpha = .65 , maxColorValue = 1 )#
		} else if ( sort.mutation.time == FALSE ) {#
			cum.freqs <- rbind ( 0 , apply ( all.freqs , 2 , cumsum ))#
			if ( length ( pa.lost ) != 0 ) {#
				red.mat <- matrix ( c ( seq ( from = .3 , to = 1 , length.out = length ( pa.lost ) ) [ 1 : length ( pa.lost ) ] , rep ( 0 , 2 * length ( pa.lost ) ) ) , nrow = length ( pa.lost ) )#
			} else {#
				red.mat <- matrix ( nrow = 0 , ncol = 3 )#
			}#
			green.mat <- matrix ( c ( rep ( 0 , length ( pa.fixed ) ) , rev ( seq ( from = 1 , to = .4 , length.out = length ( pa.fixed ) ) ) [ 1 : length ( pa.fixed ) ] , rep ( 0 , length ( pa.fixed ) ) ) , nrow = length ( pa.fixed ) )#
			blue.mat <- matrix ( c ( rep ( 0 , 2 * length ( pA.order ) ) , seq ( from = .7 , to = 1 , length.out = length ( pA.order ) ) ) , nrow = length ( pA.order ) )#
			col.vect <- rgb ( rbind ( red.mat , green.mat , blue.mat) , alpha = .65 , maxColorValue = 1 )#
		} else if ( sort.mutation.time == TRUE ) {#
			cum.freqs <-  apply ( all.freqs.unsorted , 2 , cumsum )#
			if ( length ( pa.lost ) != 0 ) {#
				red.mat <- matrix ( c ( seq ( from = .3 , to = 1 , length.out = length ( pa.lost ) ) [ 1 : length ( pa.lost ) ] , rep ( 0 , 2 * length ( pa.lost ) ) ) , nrow = length ( pa.lost ) )#
			} else {#
				red.mat <- matrix ( nrow = 0 , ncol = 3 )#
			}#
			green.mat <- matrix ( c ( rep ( 0 , length ( pa.fixed ) ) , rev ( seq ( from = 1 , to = .4 , length.out = length ( pa.fixed ) ) ) [ 1 : length ( pa.fixed ) ] , rep ( 0 , length ( pa.fixed ) ) ) , nrow = length ( pa.fixed ) )#
			blue.mat <- matrix ( c ( rep ( 0 , 2 * length ( pA.order ) ) , seq ( from = .7 , to = 1 , length.out = length ( pA.order ) ) ) , nrow = length ( pA.order ) )#
			col.vect <- character ( nrow ( cum.freqs ) )#
			col.vect [ pa.lost ] <- rgb ( red.mat , alpha = .65 , maxColorValue = 1 )#
			col.vect [ pa.fixed ] <- rgb ( green.mat , alpha = .65 , maxColorValue = 1 )#
			col.vect [ ( nrow ( pa.vect ) + 1 ) : nrow ( cum.freqs ) ] <- rgb ( blue.mat , alpha = .65 , maxColorValue = 1 )#
		}#
	#	recover()#
		no.lines <- sum ( cum.freqs [ , ncol ( cum.freqs ) ] < 0.01 )#
		line.vector <- c ( rep ( 0 , no.lines ) , rep ( .35 , nrow ( cum.freqs ) - no.lines ) )#
		matplot ( t ( cum.freqs ) , type = "l" , lty = "solid" , lwd = line.vector , col = "black" , xlab = "Generations" , ylab = "Cumulative Frequency" , bty = "n" )#
		for ( i in 1 : ( nrow ( cum.freqs ) - 1 ) ) {#
			#i = i + 1#
			X.ax <- which ( cum.freqs [ i , ] != cum.freqs [ i + 1 , ] )#
			Y.ax1 <- cum.freqs [ i , X.ax ]#
			Y.ax2 <- cum.freqs [ i + 1 , X.ax ]#
			polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
		}#
		if ( switch > 0 ) {#
			segments (x0 = switch , y0 = 0 , y1 = 1.0 , lty = 2 )#
		}#
	}	#
	#mut.sel.max <- max(cum.freqs [ length (pa.lost ), ])#
	#matplot ( t ( cum.freqs [1: length ( c ( pa.lost , pa.fixed ) ) , ] ) , type = "l" , lty = 1 , lwd = 1 , col = "black" , ylim = c ( 0 , mut.sel.max * 1.1 ) )#
	if ( switch > 100 ) {#
		coal.prob.sim.mut.sel.drift <- numeric ( ncol ( pre.switch.freqs ) )#
		for ( i in 1 : ncol ( pre.switch.freqs ) ) {#
				coal.prob.sim.mut.sel.drift [ i ] <- sum ( ( pre.switch.freqs [ , i ] / sum ( pre.switch.freqs [ , i ] ) )^2 )#
		}#
	mean.coal.prob.sim.mut.sel.drift <- mean ( coal.prob.sim.mut.sel.drift )#
	}#
	coal.prob.sim.fix <- sum( (pa.vect [ , ncol(pa.vect) ])^2 )#
	coal.prob.theory.fix <- 1 / ( 1 + 2 * sum ( N_A , N_a ) * mu )#
	if ( s1 < 0 ) {#
		coal.prob.theory.mut.sel.determin <- 1 / ( 1 + 2 * sum ( N_A , N_a ) * mu / (1 + abs ( s1 ) ) )	#
	} else {#
		coal.prob.theory.mut.sel.determin = NULL#
	}#
	if ( suppress.output == FALSE ) {#
		cat ( "Coalescence probability from simulation for lineages sampled at fixation =" , coal.prob.sim.fix , "\n" )#
		cat ( "Coalescence probability from theory for lineages sampled at fixation =" , coal.prob.theory.fix , "\n" )#
		if ( switch > 100 ) {#
			cat ( "Coalescence probability from simulation for lineages sampled at mut-sel-drift balance =" , mean.coal.prob.sim.mut.sel.drift , "\n" )#
		}#
		cat ( "Coalescence probability from theory for lineages sampled at deterministic mut-sel balance =" , coal.prob.theory.mut.sel.determin , "\n" )#
	}#
	return ( list ( pA = pA.vect , pa = pa.vect , coal.prob.sim.fix = coal.prob.sim.fix , coal.prob.theory.fix = coal.prob.theory.fix , pre.switch.freqs = pre.switch.freqs , mean.coal.prob.sim.mut.sel.drift = mean.coal.prob.sim.mut.sel.drift , coal.prob.sim.mut.sel.drift = coal.prob.sim.mut.sel.drift) )#
}#
#
SweepReplicates <- function ( N_A , N_a , s1 , s2 = NULL , h , switch = 0 , shut.mut.off = FALSE , stop.at.fix = TRUE , reuse.mutant.classes = TRUE , mu , gens , mut.index = 1001 , reps , suppress.output = TRUE , suppress.plot = TRUE ){#
#
	recover()#
	#prob.at.fix <- numeric ( reps )#
	#prob.at.balance <- numeric ( reps * ( switch - 100 ) )#
	for ( r in 1 : reps ) {#
		temp <- SoftSweepSim ( N_A = N_A , N_a = N_a , s1 = s1 , s2 = s2 , switch = switch , stop.at.fix = stop.at.fix , reuse.mutant.classes = reuse.mutant.classes , mu = mu , gens = gens , suppress.output = suppress.output , suppress.plot = suppress.plot )#
		prob.at.fix [ r ] <- temp[[1]]#
		prob.at.balance [ ( ( switch - 100 ) * ( r - 1 ) + 1 ) : ( ( r * ( switch - 100 ) - 1 ) + 1 ) ] <- temp[[2]]#
		cat ( "rep =" , r , "\n" )#
		if ( r %% 20 == 0 ) {	#
			mean.prob.at.balance.only.present <- mean ( prob.at.balance [ 1 : r * ( switch - 100 ) ] , na.rm = TRUE )#
			prob.at.balance.zeros <- prob.at.balance#
			prob.at.balance.zeros [ is.nan ( prob.at.balance.zeros ) ] <- 0#
			mean.prob.at.balance.zeros <- mean ( prob.at.balance.zeros [ 1 : r * ( switch - 100 ) ] )#
			prob.hartl.theory <- 1 / ( 1 + 2 * sum ( N_a , N_A ) * mu * 1 / (1 + abs(s1) ) )#
			prob.fix.herm.penn <- 1 / ( 1 + 2 * sum ( N_a , N_A ) * mu )#
			prob.at.fix.sim <- mean ( prob.at.fix [1 : r ] )#
			cat ( "sim prob at balance =" , mean.prob.at.balance.only.present , "\n")#
			cat ( "hartl prob at balance =" , prob.hartl.theory , "\n")#
			cat ( "sim prob at balance w/ zeros =" , mean.prob.at.balance.zeros , "\n")#
			cat ( "herm penn prob at fix =" , prob.fix.herm.penn , "\n")#
			cat ( "sim prob at fix =" , prob.at.fix.sim , "\n")#
		}#
	}	#
	return ( list ( prob.at.fix = prob.at.fix , prob.at.balance = prob.at.balance ) )#
}#
#
DiversityPlot <- function ( N , mu.b , mu.n , l , r , s , threshold ){#
	diversity.hard <- diversity.soft <- coal.prob.soft <- coal.prob.hard <- numeric ()#
	no.mut.prob <- 1 / ( 1 + N * mu.b ) #
	no.rec.prob <- exp ( -0.5 * ( log ( N * s ) / s ) * ( l - 1 ) * r )			#
	coal.prob.soft <- no.rec.prob * no.mut.prob#
	coal.prob.hard <- no.rec.prob#
	diversity.soft <- ( ( 2 * mu.n ) / ( 1 / ( 2 * N ) ) ) * ( 1 - coal.prob.soft [ l ] )#
	diversity.hard <- ( ( 2 * mu.n ) / ( 1 / ( 2 * N ) ) ) * ( 1 - coal.prob.hard [ l ] )#
	plot ( x = c ( - rev ( l ) , l  ) , y = c ( rev ( diversity.soft ) , diversity.soft ) , type = "l" , ylim = c ( 0 , ( ( 2 * mu.n ) / ( 1 / ( 2 * N ) ) ) * 1.1 ) , xlab = "Position" , ylab = "Diversity" )#
	lines ( x = c ( - rev ( l ) , l  ) , y = c ( rev ( diversity.hard ) , diversity.hard ) , type = "l" , col = "red")#
#
	legend ( "bottomright" , legend = c ( "Soft Sweep" , "Hard Sweep" ) , lty = 1 , col = c ( "black" , "red" ) , bty = "n" )#
#
	recover()#
	neutral.diversity <- 2*mu.n/(1/(2*N))#
	min ( which ( diversity.hard > 0.99*neutral.diversity ) )#
}
temp <- SweepReplicates ( N_A = c ( 200000 ) , N_a = c ( 0 ) , s1 = -0.001 , s2 = 0.01 , switch = 0 , shut.mut.off = FALSE , stop.at.fix = TRUE , reuse.mutant.classes = TRUE , mu = 10^-5 , gens = 100000 , suppress.output = FALSE , suppress.plot = TRUE , reps = 500 )
=======
matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 ) , #
		xaxt = "n"#
	)#
	axis ( 1 , )#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.04, sim.distance = 0.05 , interval.width = 10000)
matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 ) , #
		xaxt = "n"#
	)
intervals
intervals/1000
tail ( intervals )
tail ( intervals , 1 )
tail ( intervals , 1 ) / 1000
seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )
tail ( intervals , 1 ) / 1000
tail ( intervals , 1 ) , by = 1000000 )
tail ( intervals , 1 )
seq ( 0 , tail ( intervals , 1 ) , by = 1000000 )
seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )
axis ( 1 , seq ( 0 , tail ( intervals , 1 ) , by = 1000000 ) , seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )  )
axis ( 1 , seq ( 0 , tail ( intervals , 1 ) , by = 1000 ) , seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )  )
axis ( 1 , seq ( 0 , tail ( intervals/1000 , 1 ) , by = 1000 ) , seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )  )
ewens.dist.matrix
10e6
10e6/100000
10e6/interval.width
seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )
axis ( 1 , seq ( 1 , ncol ( ewens.dist.matrix ) , by = 10e6/interval.width ) , seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )  )
seq ( 1 , ncol ( ewens.dist.matrix ) , by = 10e6/interval.width )
10e6/interval.width
seq ( 1 , ncol ( ewens.dist.matrix ) , by = 10e5/interval.width )
axis ( 1 , seq ( 1 , ncol ( ewens.dist.matrix ) , by = 10e5/interval.width ) , seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )  )
matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 ) , #
		xaxt = "n"#
	)#
	axis ( 1 , seq ( 1 , ncol ( ewens.dist.matrix ) , by = 10e5/interval.width ) , seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )  )
col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}
Q
>>>>>>> ee36faaf11c8e4cf6c6ceb1f7cb958b3bb08e5a0
real.fs <- c ( 1 / 20000 , 0.001 , 0.01 , 0.05 , 0.1 )
real.fs
real.fs <- c ( 1 / 20000 , 0.001 , 0.01 , 0.05 , 0.1 )
my.runs <- lapply ( real.fs , function ( x ) SweepFromStandingSim ( N = 10000 , s = 0.05 , f = x , reps = 1000 , no.sweep = FALSE , cond.on.loss = TRUE , cond.on.fix = TRUE , time.factor = 1 , display.rep.count = T ) )#
many.sim.freqs <- list ( my.runs , real.fs )#
save ( many.sim.freqs  ,  file = "~/Documents/Academics/StandingSweeps/Sims/freqs.traj.s05.Rdata"  )#
for ( i in 1 : length ( real.fs ) ) {#
	run.ms.f ( runs = my.runs [[ i ]] [[ 1 ]] , n.sam = 2 , f = real.fs [ i ] , s = 0.05 , N = 10000 , path = "~/Documents/Academics/StandingSweeps/" )#
}
source('~/Documents/Academics/StandingSweeps/Scripts/SweepFromStandingSim.R', chdir = TRUE)#
source ( "~/Documents/Academics/StandingSweeps/Scripts/run.ms.functions.R")
source('~/Documents/Academics/CoopLab/Projects/StandingSweeps/Scripts/SweepFromStandingSim.R', chdir = TRUE)#
source ( "~/Documents/Academics/CoopLab/Projects/StandingSweeps/Scripts/run.ms.functions.R")#
#source('~/Documents/Academics/StandingSweeps/Scripts/SweepFromStandingSim.R', chdir = TRUE)#
#source ( "~/Documents/Academics/StandingSweeps/Scripts/run.ms.functions.R")#
real.fs <- c ( 1 / 20000 , 0.001 , 0.01 , 0.05 , 0.1 )#
my.runs <- lapply ( real.fs , function ( x ) SweepFromStandingSim ( N = 10000 , s = 0.05 , f = x , reps = 1000 , no.sweep = FALSE , cond.on.loss = TRUE , cond.on.fix = TRUE , time.factor = 1 , display.rep.count = T ) )#
many.sim.freqs <- list ( my.runs , real.fs )#
save ( many.sim.freqs  ,  file = "~/Documents/Academics/StandingSweeps/Sims/freqs.traj.s05.Rdata"  )#
for ( i in 1 : length ( real.fs ) ) {#
	run.ms.f ( runs = my.runs [[ i ]] [[ 1 ]] , n.sam = 2 , f = real.fs [ i ] , s = 0.05 , N = 10000 , path = "~/Documents/Academics/StandingSweeps/" )#
}
source('~/Documents/Academics/CoopLab/Projects/StandingSweeps/Scripts/SweepFromStandingSim.R', chdir = TRUE)#
source ( "~/Documents/Academics/CoopLab/Projects/StandingSweeps/Scripts/run.ms.functions.R")
source('~/Documents/Academics/StandingSweeps/Scripts/SweepFromStandingSim.R', chdir = TRUE)
library ( randtoolbox)
library ( "randtoolbox")
expected.freq.times.standing.w.sweep<-function(nsam,N,r,distance,f){#
	recover()#
	#my.StirlingNumbers<-StirlingNumbers(n) #
	ESF.prob.k<-EwensDist( n=nsam , N =N, r=r , distance=1 , f=f) # ,stirling.numbers=my.StirlingNumbers)    ### is of form [n,k]#
	ESF.condprob.k<-EwensCondDist( n=nsam , N =N, r=r , distance=1 , f=f) # ,stirling.numbers=my.StirlingNumbers)    ### is of form [n,k]#
	my.StirlingNumbers<-StirlingNumbers(nsam)    ##Usigned Stirling numbers of 1st kind. ma#
	expected.t.l<-rep(NA,nsam-1)#
	p_l_given_k <- array ( 0 , dim = c ( nsam , nsam , nsam , nsam ) )#
	freq.specs <- matrix ( 0 , nrow = nsam , ncol = nsam )#
	for ( i in 2 : nsam ) {		#
		freq.specs [ 1 : ( i - 1 ) , i ] <- ( 1 / ( 1 : ( i - 1 ) ) ) / ( sum ( 1 / ( 1 : ( i - 1  )  ) ) )#
	}#
	freq.specs <- t ( freq.specs )#
	terms.in.sum <- array ( 0 , dim = c ( nsam , nsam , nsam , nsam ) )#
	H <- array ( 0 , dim = c ( nsam , nsam , nsam , nsam ) )#
	jg.tracker <- array ( NA , dim = c ( nsam , nsam , nsam , nsam , nsam ) )#
	kg.tracker <- array ( NA , dim = c ( nsam , nsam , nsam , nsam , nsam ) ) #
	for(l in 1:(nsam-1)){	#
	#	recover()#
	#	terms.in.sum<-rep(0,nsam)#
		for ( i in 0 : nsam ) {	#
			for(k in 1 : i ) {#
				terms.given.j <- matrix ( 0 , ncol = nsam , nrow = nsam )#
				for(j in 1:(k + nsam - i  - 1 )){#
					for ( g in max ( 0 , ( j - k ) ) : min ( l , nsam - i , j ) ) {#
						if ( FALSE ) {#
						if ( k == 1 ) {#
							if ( nsam - i == l ) 					p_l_given_k [ k , j , l ] <- 1#
							if ( l - g  == 0 & j - g == 0 ) 	p_l_given_k [ k , j , l ] <- 1#
						} else if ( k > 1) {#
						#	if ( k - ( j - g ) < 0 ) next#
							if ( nsam - i - ( l - g ) < 0 ) next#
							stirling.bit <- my.StirlingNumbers[ l - g , j - g ] * my.StirlingNumbers[nsam - i - ( l - g ) , k - ( j - g ) ]  / my.StirlingNumbers[ nsam - i ,k - g ]#
							p_l_given_k [ g , j , k , l ] <- stirling.bit * choose ( nsam - i , l - g ) / choose ( k - g , j - g )#
						}#
						#if(!is.finite(p_l_given_k [ l , k , j ])){ stop ("is infinite") }  ##cat("problem",l,k,j," "); ##is this right?#
						H [ g , j , k , nsam - i ] <- choose ( j , g ) / choose ( k + nsam - i , j )#
						terms.given.j [ j , k ] <- p_l_given_k [ k , j , l ]*freq.specs[ k + nsam - i  , j ] * H [ g , j , k , nsam - i ]#
					#	terms.in.sum[k]<-terms.in.sum[k]+ESF.prob.k[nsam,k] *p_l_given_k [ l , k , j ]*freq.specs[k,j]#
						terms.in.sum [ k , j, l , i  ] <- ESF.prob.k [ nsam , k ] * p_l_given_k [ k , j , l ] * freq.specs [ k , j ]			#
						stopifnot( H <= 1 , H >= 0 )#
						}#
						jg.tracker [ k , j , g , i ,  l ]	 <- j - g#
						kg.tracker [ k , j , g , i , l ]	 <- k - ( j - g )#
					}#
				}		#
			}#
		}#
	#	expected.t.l[l]<-sum(terms.in.sum)#
	}#
	return(terms.in.sum)#
}#
#
expected.freq.times.standing.w.sweep ( nsam = 10 , N = 10000 , r = 0.5 , f = 0.05 )
as.c
setwd ( "~/Documents/Academics/StandingSweeps/" )#
source('~/Documents/Academics/StandingSweeps/Scripts/SweepFromStandingSim.R', chdir = TRUE)#
source('~/Documents/Academics/StandingSweeps/Scripts/run.ms.functions.R', chdir = TRUE)#
options ( scipen = 400)
my.N <- 10000#
my.rs <- c ( 0.0001 , 0.001 , 0.01 , 0.05 , 0.1 , 0.5 ) #
my.fs <- c ( 1/(2*my.N) , 0.001 , 0.01 , 0.025 , 0.05 , 0.075 , 0.1 )#
my.s <- my.fs
as.c ( my.rs [ 1 ] )
r=my.rs [ 1 ]
r
as.c ( r )
strsplit ( as.c ( r ) , "." )
strsplit ( as.c ( r ) , "" )
strsplit ( as.c ( r ) , "." )
as.c ( r )
strsplit ( as.c ( r ) , "/." )
strsplit ( as.c ( r ) , "\\." )
strsplit ( as.c ( r ) , "\\." ) [ 2 ]
as.c ( r )
strsplit ( as.c ( r ) , "\\." )
strsplit ( as.c ( r ) , "\\." ) [[ 1 ]] [ 2 ]
paste ( "Sims/freq.spec" , strsplit ( as.c ( r ) , "\\." ) [[ 1 ]] [ 2 ] , ".05.05.10000.nosweep.n12.Robj" )
paste ( "Sims/freq.spec" , strsplit ( as.c ( r ) , "\\." ) [[ 1 ]] [ 2 ] , ".05.05.10000.nosweep.n12.Robj" , sep = "" )
paste ( "Sims/freq.spec." , strsplit ( as.c ( r ) , "\\." ) [[ 1 ]] [ 2 ] , ".05.05.10000.nosweep.n12.Robj" , sep = "" )
r
f
f=0.01
paste ( "Sims/freq.spec." , strsplit ( as.c ( r ) , "\\." ) [[ 1 ]] [ 2 ] ,  strsplit ( as.c ( f ) , "\\." ) [[ 1 ]] [ 2 ] ,  ".10000.nosweep.n12.Robj" , sep = "" )
paste ( "Sims/freq.spec." , strsplit ( as.c ( r ) , "\\." ) [[ 1 ]] [ 2 ] , "." ,  strsplit ( as.c ( f ) , "\\." ) [[ 1 ]] [ 2 ] ,  ".10000.nosweep.n12.Robj" , sep = "" )
paste ( "Sims/freq.spec." , strsplit ( as.c ( r ) , "\\." ) [[ 1 ]] [ 2 ] , "." ,  strsplit ( as.c ( f ) , "\\." ) [[ 1 ]] [ 2 ] ,  "." , my.N , ".nosweep.n12.Robj" , sep = "" )
paste ( "Sims/freq.spec." , strsplit ( as.c ( r ) , "\\." ) [[ 1 ]] [ 2 ] , "." ,  strsplit ( as.c ( f ) , "\\." ) [[ 1 ]] [ 2 ] ,  "." , my.N , ".nosweep.n" , 12 , ".Robj" , sep = "" )
r
message ( r)
message ( r )#
		message ( f )
>>>>>>> FETCH_HEAD
