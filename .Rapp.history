my.rec.events$rec.right.off.background$sequence.location
my.rec.events$rec.right.off.background$sequence.location < k
sum ( my.rec.events$rec.right.off.background$sequence.location < k )
my.rec.events$rec.right.off.background$sequence.location < k
sum ( my.rec.events$rec.right.off.background$sequence.location < k )
my.rec.events$rec.right.off.background$sequence.location < k
sum ( my.rec.events$rec.right.off.background$sequence.location < k )
my.seqs$right.seq [ , last.rec.event + 1 ]
last.rec.event <- sum ( my.rec.events$rec.right.off.background$sequence.location < k )
my.seqs$right.seq [ , last.rec.event + 1 ]
table(my.seqs$right.seq [ , last.rec.event + 1 ])
table(my.seqs$right.seq [ , last.rec.event + 1 ])>1
sum(table(my.seqs$right.seq [ , last.rec.event + 1 ])>1)
sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )
n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )
sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )
n.haps <- rbind ( n.haps.right , n.haps.left )#
	no.sing.haps <- rbind ( no.sing.haps.right , no.sing.haps.left )
cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
			no.sing.haps.right [ , i ] <- no.sing.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.right [ j , i ] <- sum ( table ( my.seqs$right.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
					no.sing.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.left [ j , i ] <- sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
					no.sing.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)
n.haps <- rbind ( n.haps.right , n.haps.left )
no.sing.haps <- rbind ( no.sing.haps.right , no.sing.haps.left )
no.sing.haps
hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )
hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )
no.sing.hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )
hap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )
hap.count.freqs.by.interval
no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )
no.singhap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )
hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )
hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )
no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )
no.singhap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )
no.singhap.count.freqs.by.interval
no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )
no.singhap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )
no.singhap.count.freqs.by.interval
no.sing.hap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )
no.sing.haps
Q
##install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , display.rep.count = TRUE , time.factor = 1 ) {#
	options ( error = recover )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix , display.rep.count )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- temp [[ 2 ]]#
			# sweep.start.forward <- ncol ( frequencies ) - sweep.start #
			# # if ( nrow ( frequencies ) > 1 ) {#
			# fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			# zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			# entry <- numeric()#
			# for ( i in 1 : length ( zeros ) ){#
				# if ( length ( zeros [[ i ]] ) != 0 ) {#
					# entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				# } else {#
					# entry [ i ] <- 1#
				# }#
			# }#
			# transit.time <- fixation.time - entry#
			new.freqs <- temp [[ 1 ]]#
			# for ( i in 1 : nrow ( frequencies ) ) {#
				# new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			# }#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
		trees [[ i ]] [[ "sweep.start"]] <- sweep.start [ i ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f  )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
		#recover()#
		if ( FALSE ) {#
		standing.hap.dist <- StandingHapCountDist ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
		}#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , standing.hap.dist = standing.hap.dist , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , display.rep.count , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 & display.rep.count) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	sweep.start <- apply ( sweep.freq.matrix , 1 , function ( x ) which.max ( x ) / time.factor )#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
	if ( no.sweep == FALSE ) {#
		freq.traj.list <- mapply ( 	function ( X , Y ) {#
											#recover()#
											fixation <- which.max ( Y )#
											mutation <- sum ( X > 0 )#
											freq <- c ( rev ( Y [ 2 : fixation ] ) , X [ 1 : mutation ] )#
											return ( freq )#
										} ,#
										X = split ( neutral.freq.matrix , 1 : nrow ( neutral.freq.matrix ) ) , #
										Y = split ( sweep.freq.matrix , 1 : nrow ( sweep.freq.matrix ) )#
							)#
		freq.trajectories <- matrix ( 0 , ncol = max ( unlist ( lapply ( freq.traj.list , length ) ) ) , nrow = reps )#
		for ( i in seq_len ( nrow ( freq.trajectories ) ) ) {#
			freq.trajectories [ i , 1 : length ( freq.traj.list [[ i ]] ) ] <- freq.traj.list [[ i ]]#
		}#
		#freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	# temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	# add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	# temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	# freq.trajectories <- do.call ( rbind , temp2 )#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	#library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	no.sing.haps.right <- no.sing.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
			no.sing.haps.right [ , i ] <- no.sing.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.right [ j , i ] <- sum ( table ( my.seqs$right.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
					no.sing.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.left [ j , i ] <- sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
					no.sing.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	no.sing.haps <- rbind ( no.sing.haps.right , no.sing.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	no.sing.hap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , no.sing.hap.count.freqs.by.interval = no.sing.hap.count.freqs.by.interval , n.haps = n.haps , no.sing.haps = no.sing.haps ) )#
}#
StandingHapCountDist <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events#
				my.rec.events.off <- input [[ j ]] $ rec.events.off.background#
				# right side#
				sweep.recs <- my.rec.events$rec.right$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.right$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.right$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- extract.clade ( input [[ j ]]$tree , i )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				sweep.recs <- my.rec.events$rec.left$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.left$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.left$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- GetTips ( i , n.tips , input[[j]]$tree$edge )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	recover()#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		}#
	}#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n"#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
#
GetTips <- function ( branch , n.tips , edges ) {#
	#recover()#
	if ( branch <= n.tips ) {#
		return ( branch )#
	}#
	subtend <- edges [ edges [  , 1 ] == branch , 2 ]#
	if ( all ( subtend <= n.tips ) ) {#
		return ( subtend )#
	} else {#
		sapply ( subtend , function ( x ) GetTips ( x , n.tips , edges ) )#
	}#
}#
#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = FALSE ,  time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
#
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.05 , f = 0.01 , reps = 100 , n.tips = 12 , r = 10^-8 , sim.distance = 0.015 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)#
#
SequenceIBDPlots <- function ( trees ) {#
	#recover()#
	seq.structure <- trees$sequence.structure#
	seq.resort <- do.call(what = order, as.data.frame(seq.structure))#
	seq.structure <- lapply ( seq.structure , function ( x ) x [ seq.resort , ] )#
	rec.points <- trees$rec.events.off.background#
	scaled.rec.points <- list ()#
	scaled.rec.points$right <- c ( 0 , rec.points$rec.right.off.background$sequence.location / trees$sim.distance , 1 )#
	scaled.rec.points$left <- - c ( 0 , rec.points$rec.left.off.background$sequence.location / trees$sim.distance , 1 )#
	#my.cols <- rainbow ( max ( unlist ( seq.structure ) ) + 1 , alpha = 0.7 )#
	my.cols.right <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Paired" )#
	my.cols.left <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Set3" )#
	plot ( NA , bty = "n" , xlim = c ( -1 , 1 ) , ylim = c ( 0 , 12 ) , xaxt = "n" , yaxt = "n" , ylab = "" , xlab = "" )#
#
	### right side#
	for ( row in seq_len ( nrow ( seq.structure$right.seq ) ) ) {#
		my.recs <- unique ( seq.structure$right.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$right.seq[row,] ) , max ( unlist ( seq.structure$right.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.right [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	### left side#
	for ( row in seq_len ( nrow ( seq.structure$left.seq ) ) ) {#
		my.recs <- unique ( seq.structure$left.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$left.seq[row,] ) , max ( unlist ( seq.structure$left.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.left [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	abline ( v = 0 )#
}#
#
if ( FALSE) SequenceIBDPlots ( temp$trees[[1]] )#
par ( mfrow = c ( 3 ,2 ) )#
for ( i in 1 : 6 ) SequenceIBDPlots ( temp$trees[[i]] )#
###########################################
#### Let's think about inference w/ genealogies #####
###########################################
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
for ( i in 1 : length ( coal.times ) ) {#
	log.likes[[i]] <- lapply ( 1:nrow(coal.times[[i]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times[[i]] [ y , ] , x , 20000 ) ) )#
	print ( i )#
}#
#log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(z) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( z [ y , ] , x , 20000 ) ) )  )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.05 , f = 0.05 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )
length(trees)
hap.dist
length(hap.dist)
names(hap.dist)
hap.dist$no.sing.hap.count.freqs.by.interval
MakeHapPlots ( hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)
sim.distance.bp <- sim.distance / r
intervals <- seq ( 0 , sim.distance.bp , interval.width )
n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )
ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )
plot.cumulative
if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}
matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n"#
	)
matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)
col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )
for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}
col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)
col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
Q
##install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , display.rep.count = TRUE , time.factor = 1 ) {#
	options ( error = recover )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix , display.rep.count )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- temp [[ 2 ]]#
			# sweep.start.forward <- ncol ( frequencies ) - sweep.start #
			# # if ( nrow ( frequencies ) > 1 ) {#
			# fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			# zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			# entry <- numeric()#
			# for ( i in 1 : length ( zeros ) ){#
				# if ( length ( zeros [[ i ]] ) != 0 ) {#
					# entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				# } else {#
					# entry [ i ] <- 1#
				# }#
			# }#
			# transit.time <- fixation.time - entry#
			new.freqs <- temp [[ 1 ]]#
			# for ( i in 1 : nrow ( frequencies ) ) {#
				# new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			# }#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
		trees [[ i ]] [[ "sweep.start"]] <- sweep.start [ i ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f  )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
		#recover()#
		if ( FALSE ) {#
		standing.hap.dist <- StandingHapCountDist ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
		}#
		standing.hap.dist <- 0#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , standing.hap.dist = standing.hap.dist , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , display.rep.count , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 & display.rep.count) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	sweep.start <- apply ( sweep.freq.matrix , 1 , function ( x ) which.max ( x ) / time.factor )#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
	if ( no.sweep == FALSE ) {#
		freq.traj.list <- mapply ( 	function ( X , Y ) {#
											#recover()#
											fixation <- which.max ( Y )#
											mutation <- sum ( X > 0 )#
											freq <- c ( rev ( Y [ 2 : fixation ] ) , X [ 1 : mutation ] )#
											return ( freq )#
										} ,#
										X = split ( neutral.freq.matrix , 1 : nrow ( neutral.freq.matrix ) ) , #
										Y = split ( sweep.freq.matrix , 1 : nrow ( sweep.freq.matrix ) )#
							)#
		freq.trajectories <- matrix ( 0 , ncol = max ( unlist ( lapply ( freq.traj.list , length ) ) ) , nrow = reps )#
		for ( i in seq_len ( nrow ( freq.trajectories ) ) ) {#
			freq.trajectories [ i , 1 : length ( freq.traj.list [[ i ]] ) ] <- freq.traj.list [[ i ]]#
		}#
		#freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	# temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	# add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	# temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	# freq.trajectories <- do.call ( rbind , temp2 )#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	#library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	no.sing.haps.right <- no.sing.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
			no.sing.haps.right [ , i ] <- no.sing.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.right [ j , i ] <- sum ( table ( my.seqs$right.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
					no.sing.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.left [ j , i ] <- sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
					no.sing.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	no.sing.haps <- rbind ( no.sing.haps.right , no.sing.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	no.sing.hap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , no.sing.hap.count.freqs.by.interval = no.sing.hap.count.freqs.by.interval , n.haps = n.haps , no.sing.haps = no.sing.haps ) )#
}#
StandingHapCountDist <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events#
				my.rec.events.off <- input [[ j ]] $ rec.events.off.background#
				# right side#
				sweep.recs <- my.rec.events$rec.right$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.right$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.right$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- extract.clade ( input [[ j ]]$tree , i )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				sweep.recs <- my.rec.events$rec.left$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.left$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.left$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- GetTips ( i , n.tips , input[[j]]$tree$edge )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	recover()#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		}#
	}#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
#
GetTips <- function ( branch , n.tips , edges ) {#
	#recover()#
	if ( branch <= n.tips ) {#
		return ( branch )#
	}#
	subtend <- edges [ edges [  , 1 ] == branch , 2 ]#
	if ( all ( subtend <= n.tips ) ) {#
		return ( subtend )#
	} else {#
		sapply ( subtend , function ( x ) GetTips ( x , n.tips , edges ) )#
	}#
}#
#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = FALSE ,  time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
#
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.05 , f = 0.01 , reps = 100 , n.tips = 12 , r = 10^-8 , sim.distance = 0.015 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)#
#
SequenceIBDPlots <- function ( trees ) {#
	#recover()#
	seq.structure <- trees$sequence.structure#
	seq.resort <- do.call(what = order, as.data.frame(seq.structure))#
	seq.structure <- lapply ( seq.structure , function ( x ) x [ seq.resort , ] )#
	rec.points <- trees$rec.events.off.background#
	scaled.rec.points <- list ()#
	scaled.rec.points$right <- c ( 0 , rec.points$rec.right.off.background$sequence.location / trees$sim.distance , 1 )#
	scaled.rec.points$left <- - c ( 0 , rec.points$rec.left.off.background$sequence.location / trees$sim.distance , 1 )#
	#my.cols <- rainbow ( max ( unlist ( seq.structure ) ) + 1 , alpha = 0.7 )#
	my.cols.right <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Paired" )#
	my.cols.left <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Set3" )#
	plot ( NA , bty = "n" , xlim = c ( -1 , 1 ) , ylim = c ( 0 , 12 ) , xaxt = "n" , yaxt = "n" , ylab = "" , xlab = "" )#
#
	### right side#
	for ( row in seq_len ( nrow ( seq.structure$right.seq ) ) ) {#
		my.recs <- unique ( seq.structure$right.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$right.seq[row,] ) , max ( unlist ( seq.structure$right.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.right [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	### left side#
	for ( row in seq_len ( nrow ( seq.structure$left.seq ) ) ) {#
		my.recs <- unique ( seq.structure$left.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$left.seq[row,] ) , max ( unlist ( seq.structure$left.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.left [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	abline ( v = 0 )#
}#
#
if ( FALSE) SequenceIBDPlots ( temp$trees[[1]] )#
par ( mfrow = c ( 3 ,2 ) )#
for ( i in 1 : 6 ) SequenceIBDPlots ( temp$trees[[i]] )#
###########################################
#### Let's think about inference w/ genealogies #####
###########################################
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
for ( i in 1 : length ( coal.times ) ) {#
	log.likes[[i]] <- lapply ( 1:nrow(coal.times[[i]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times[[i]] [ y , ] , x , 20000 ) ) )#
	print ( i )#
}#
#log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(z) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( z [ y , ] , x , 20000 ) ) )  )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = 0.01 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )
temp$hap.dist$no.sing.hap.count.freqs.by.interval
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)
sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}
matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)
matplot ( #
		NA , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)
col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )
matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)
col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
c
Q
##install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , display.rep.count = TRUE , time.factor = 1 ) {#
	options ( error = recover )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix , display.rep.count )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- temp [[ 2 ]]#
			# sweep.start.forward <- ncol ( frequencies ) - sweep.start #
			# # if ( nrow ( frequencies ) > 1 ) {#
			# fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			# zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			# entry <- numeric()#
			# for ( i in 1 : length ( zeros ) ){#
				# if ( length ( zeros [[ i ]] ) != 0 ) {#
					# entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				# } else {#
					# entry [ i ] <- 1#
				# }#
			# }#
			# transit.time <- fixation.time - entry#
			new.freqs <- temp [[ 1 ]]#
			# for ( i in 1 : nrow ( frequencies ) ) {#
				# new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			# }#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
		trees [[ i ]] [[ "sweep.start"]] <- sweep.start [ i ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f  )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
		#recover()#
		standing.hap.dist <- StandingHapCountDist ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , standing.hap.dist = standing.hap.dist , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , display.rep.count , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 & display.rep.count) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	sweep.start <- apply ( sweep.freq.matrix , 1 , function ( x ) which.max ( x ) / time.factor )#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
	if ( no.sweep == FALSE ) {#
		freq.traj.list <- mapply ( 	function ( X , Y ) {#
											#recover()#
											fixation <- which.max ( Y )#
											mutation <- sum ( X > 0 )#
											freq <- c ( rev ( Y [ 2 : fixation ] ) , X [ 1 : mutation ] )#
											return ( freq )#
										} ,#
										X = split ( neutral.freq.matrix , 1 : nrow ( neutral.freq.matrix ) ) , #
										Y = split ( sweep.freq.matrix , 1 : nrow ( sweep.freq.matrix ) )#
							)#
		freq.trajectories <- matrix ( 0 , ncol = max ( unlist ( lapply ( freq.traj.list , length ) ) ) , nrow = reps )#
		for ( i in seq_len ( nrow ( freq.trajectories ) ) ) {#
			freq.trajectories [ i , 1 : length ( freq.traj.list [[ i ]] ) ] <- freq.traj.list [[ i ]]#
		}#
		#freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	# temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	# add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	# temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	# freq.trajectories <- do.call ( rbind , temp2 )#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	#library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	no.sing.haps.right <- no.sing.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
			no.sing.haps.right [ , i ] <- no.sing.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.right [ j , i ] <- sum ( table ( my.seqs$right.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
					no.sing.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.left [ j , i ] <- sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
					no.sing.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	no.sing.haps <- rbind ( no.sing.haps.right , no.sing.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	no.sing.hap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , no.sing.hap.count.freqs.by.interval = no.sing.hap.count.freqs.by.interval , n.haps = n.haps , no.sing.haps = no.sing.haps ) )#
}#
StandingHapCountDist <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events#
				my.rec.events.off <- input [[ j ]] $ rec.events.off.background#
				# right side#
				sweep.recs <- my.rec.events$rec.right$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.right$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.right$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- extract.clade ( input [[ j ]]$tree , i )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				sweep.recs <- my.rec.events$rec.left$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.left$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.left$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- GetTips ( i , n.tips , input[[j]]$tree$edge )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	recover()#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		}#
	}#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
#
GetTips <- function ( branch , n.tips , edges ) {#
	#recover()#
	if ( branch <= n.tips ) {#
		return ( branch )#
	}#
	subtend <- edges [ edges [  , 1 ] == branch , 2 ]#
	if ( all ( subtend <= n.tips ) ) {#
		return ( subtend )#
	} else {#
		sapply ( subtend , function ( x ) GetTips ( x , n.tips , edges ) )#
	}#
}#
#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = FALSE ,  time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
#
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.05 , f = 0.01 , reps = 100 , n.tips = 12 , r = 10^-8 , sim.distance = 0.015 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)#
#
SequenceIBDPlots <- function ( trees ) {#
	#recover()#
	seq.structure <- trees$sequence.structure#
	seq.resort <- do.call(what = order, as.data.frame(seq.structure))#
	seq.structure <- lapply ( seq.structure , function ( x ) x [ seq.resort , ] )#
	rec.points <- trees$rec.events.off.background#
	scaled.rec.points <- list ()#
	scaled.rec.points$right <- c ( 0 , rec.points$rec.right.off.background$sequence.location / trees$sim.distance , 1 )#
	scaled.rec.points$left <- - c ( 0 , rec.points$rec.left.off.background$sequence.location / trees$sim.distance , 1 )#
	#my.cols <- rainbow ( max ( unlist ( seq.structure ) ) + 1 , alpha = 0.7 )#
	my.cols.right <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Paired" )#
	my.cols.left <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Set3" )#
	plot ( NA , bty = "n" , xlim = c ( -1 , 1 ) , ylim = c ( 0 , 12 ) , xaxt = "n" , yaxt = "n" , ylab = "" , xlab = "" )#
#
	### right side#
	for ( row in seq_len ( nrow ( seq.structure$right.seq ) ) ) {#
		my.recs <- unique ( seq.structure$right.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$right.seq[row,] ) , max ( unlist ( seq.structure$right.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.right [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	### left side#
	for ( row in seq_len ( nrow ( seq.structure$left.seq ) ) ) {#
		my.recs <- unique ( seq.structure$left.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$left.seq[row,] ) , max ( unlist ( seq.structure$left.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.left [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	abline ( v = 0 )#
}#
#
if ( FALSE) SequenceIBDPlots ( temp$trees[[1]] )#
par ( mfrow = c ( 3 ,2 ) )#
for ( i in 1 : 6 ) SequenceIBDPlots ( temp$trees[[i]] )#
###########################################
#### Let's think about inference w/ genealogies #####
###########################################
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
for ( i in 1 : length ( coal.times ) ) {#
	log.likes[[i]] <- lapply ( 1:nrow(coal.times[[i]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times[[i]] [ y , ] , x , 20000 ) ) )#
	print ( i )#
}#
#log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(z) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( z [ y , ] , x , 20000 ) ) )  )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = 0.01 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )
sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events#
				my.rec.events.off <- input [[ j ]] $ rec.events.off.background#
				# right side#
				sweep.recs <- my.rec.events$rec.right$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.right$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.right$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- extract.clade ( input [[ j ]]$tree , i )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.right.off.background$sequence.location < k )#
					my.tab <- table ( my.seqs$right.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] )#
					n.haps.right [ j , i ] <- sum ( my.tab > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				sweep.recs <- my.rec.events$rec.left$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.left$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.left$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- GetTips ( i , n.tips , input[[j]]$tree$edge )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.left.off.background$sequence.location < k )#
					my.tab <- table ( my.seqs$left.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] )#
					n.haps.left [ j , i ] <-  sum ( my.tab > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)
n.haps <- rbind ( n.haps.right , n.haps.left )
hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )
hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )
hap.count.freqs.by.interval
MakeHapPlots ( hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)
sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}
ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )
matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
##install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , display.rep.count = TRUE , time.factor = 1 ) {#
	options ( error = recover )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix , display.rep.count )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- temp [[ 2 ]]#
			# sweep.start.forward <- ncol ( frequencies ) - sweep.start #
			# # if ( nrow ( frequencies ) > 1 ) {#
			# fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			# zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			# entry <- numeric()#
			# for ( i in 1 : length ( zeros ) ){#
				# if ( length ( zeros [[ i ]] ) != 0 ) {#
					# entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				# } else {#
					# entry [ i ] <- 1#
				# }#
			# }#
			# transit.time <- fixation.time - entry#
			new.freqs <- temp [[ 1 ]]#
			# for ( i in 1 : nrow ( frequencies ) ) {#
				# new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			# }#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
		trees [[ i ]] [[ "sweep.start"]] <- sweep.start [ i ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f  )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
		#recover()#
		standing.hap.dist <- StandingHapCountDist ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , standing.hap.dist = standing.hap.dist , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , display.rep.count , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 & display.rep.count) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	sweep.start <- apply ( sweep.freq.matrix , 1 , function ( x ) which.max ( x ) / time.factor )#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
	if ( no.sweep == FALSE ) {#
		freq.traj.list <- mapply ( 	function ( X , Y ) {#
											#recover()#
											fixation <- which.max ( Y )#
											mutation <- sum ( X > 0 )#
											freq <- c ( rev ( Y [ 2 : fixation ] ) , X [ 1 : mutation ] )#
											return ( freq )#
										} ,#
										X = split ( neutral.freq.matrix , 1 : nrow ( neutral.freq.matrix ) ) , #
										Y = split ( sweep.freq.matrix , 1 : nrow ( sweep.freq.matrix ) )#
							)#
		freq.trajectories <- matrix ( 0 , ncol = max ( unlist ( lapply ( freq.traj.list , length ) ) ) , nrow = reps )#
		for ( i in seq_len ( nrow ( freq.trajectories ) ) ) {#
			freq.trajectories [ i , 1 : length ( freq.traj.list [[ i ]] ) ] <- freq.traj.list [[ i ]]#
		}#
		#freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	# temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	# add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	# temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	# freq.trajectories <- do.call ( rbind , temp2 )#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	#library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	no.sing.haps.right <- no.sing.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
			no.sing.haps.right [ , i ] <- no.sing.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.right [ j , i ] <- sum ( table ( my.seqs$right.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
					no.sing.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.left [ j , i ] <- sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
					no.sing.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	no.sing.haps <- rbind ( no.sing.haps.right , no.sing.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	no.sing.hap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , no.sing.hap.count.freqs.by.interval = no.sing.hap.count.freqs.by.interval , n.haps = n.haps , no.sing.haps = no.sing.haps ) )#
}#
StandingHapCountDist <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events#
				my.rec.events.off <- input [[ j ]] $ rec.events.off.background#
				# right side#
				sweep.recs <- my.rec.events$rec.right$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.right$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.right$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- extract.clade ( input [[ j ]]$tree , i )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.right.off.background$sequence.location < k )#
					my.tab <- table ( my.seqs$right.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] )#
					n.haps.right [ j , i ] <- sum ( my.tab > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				sweep.recs <- my.rec.events$rec.left$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.left$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.left$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- GetTips ( i , n.tips , input[[j]]$tree$edge )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.left.off.background$sequence.location < k )#
					my.tab <- table ( my.seqs$left.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] )#
					n.haps.left [ j , i ] <-  sum ( my.tab > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	recover()#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		}#
	}#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
#
GetTips <- function ( branch , n.tips , edges ) {#
	#recover()#
	if ( branch <= n.tips ) {#
		return ( branch )#
	}#
	subtend <- edges [ edges [  , 1 ] == branch , 2 ]#
	if ( all ( subtend <= n.tips ) ) {#
		return ( subtend )#
	} else {#
		sapply ( subtend , function ( x ) GetTips ( x , n.tips , edges ) )#
	}#
}#
#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = FALSE ,  time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
#
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.05 , f = 0.01 , reps = 100 , n.tips = 12 , r = 10^-8 , sim.distance = 0.015 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)#
#
SequenceIBDPlots <- function ( trees ) {#
	#recover()#
	seq.structure <- trees$sequence.structure#
	seq.resort <- do.call(what = order, as.data.frame(seq.structure))#
	seq.structure <- lapply ( seq.structure , function ( x ) x [ seq.resort , ] )#
	rec.points <- trees$rec.events.off.background#
	scaled.rec.points <- list ()#
	scaled.rec.points$right <- c ( 0 , rec.points$rec.right.off.background$sequence.location / trees$sim.distance , 1 )#
	scaled.rec.points$left <- - c ( 0 , rec.points$rec.left.off.background$sequence.location / trees$sim.distance , 1 )#
	#my.cols <- rainbow ( max ( unlist ( seq.structure ) ) + 1 , alpha = 0.7 )#
	my.cols.right <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Paired" )#
	my.cols.left <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Set3" )#
	plot ( NA , bty = "n" , xlim = c ( -1 , 1 ) , ylim = c ( 0 , 12 ) , xaxt = "n" , yaxt = "n" , ylab = "" , xlab = "" )#
#
	### right side#
	for ( row in seq_len ( nrow ( seq.structure$right.seq ) ) ) {#
		my.recs <- unique ( seq.structure$right.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$right.seq[row,] ) , max ( unlist ( seq.structure$right.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.right [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	### left side#
	for ( row in seq_len ( nrow ( seq.structure$left.seq ) ) ) {#
		my.recs <- unique ( seq.structure$left.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$left.seq[row,] ) , max ( unlist ( seq.structure$left.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.left [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	abline ( v = 0 )#
}#
#
if ( FALSE) SequenceIBDPlots ( temp$trees[[1]] )#
par ( mfrow = c ( 3 ,2 ) )#
for ( i in 1 : 6 ) SequenceIBDPlots ( temp$trees[[i]] )#
###########################################
#### Let's think about inference w/ genealogies #####
###########################################
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
for ( i in 1 : length ( coal.times ) ) {#
	log.likes[[i]] <- lapply ( 1:nrow(coal.times[[i]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times[[i]] [ y , ] , x , 20000 ) ) )#
	print ( i )#
}#
#log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(z) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( z [ y , ] , x , 20000 ) ) )  )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = 0.05 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.02 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.05, sim.distance = 0.02)
sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}
ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )
for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		}#
	}
if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }
matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)
col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
Q
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = 0.02 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.02, sim.distance = 0.05)
##install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , display.rep.count = TRUE , time.factor = 1 ) {#
	options ( error = recover )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix , display.rep.count )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- temp [[ 2 ]]#
			# sweep.start.forward <- ncol ( frequencies ) - sweep.start #
			# # if ( nrow ( frequencies ) > 1 ) {#
			# fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			# zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			# entry <- numeric()#
			# for ( i in 1 : length ( zeros ) ){#
				# if ( length ( zeros [[ i ]] ) != 0 ) {#
					# entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				# } else {#
					# entry [ i ] <- 1#
				# }#
			# }#
			# transit.time <- fixation.time - entry#
			new.freqs <- temp [[ 1 ]]#
			# for ( i in 1 : nrow ( frequencies ) ) {#
				# new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			# }#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
		trees [[ i ]] [[ "sweep.start"]] <- sweep.start [ i ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f  )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
		#recover()#
		standing.hap.dist <- StandingHapCountDist ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , standing.hap.dist = standing.hap.dist , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , display.rep.count , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 & display.rep.count) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	sweep.start <- apply ( sweep.freq.matrix , 1 , function ( x ) which.max ( x ) / time.factor )#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
	if ( no.sweep == FALSE ) {#
		freq.traj.list <- mapply ( 	function ( X , Y ) {#
											#recover()#
											fixation <- which.max ( Y )#
											mutation <- sum ( X > 0 )#
											freq <- c ( rev ( Y [ 2 : fixation ] ) , X [ 1 : mutation ] )#
											return ( freq )#
										} ,#
										X = split ( neutral.freq.matrix , 1 : nrow ( neutral.freq.matrix ) ) , #
										Y = split ( sweep.freq.matrix , 1 : nrow ( sweep.freq.matrix ) )#
							)#
		freq.trajectories <- matrix ( 0 , ncol = max ( unlist ( lapply ( freq.traj.list , length ) ) ) , nrow = reps )#
		for ( i in seq_len ( nrow ( freq.trajectories ) ) ) {#
			freq.trajectories [ i , 1 : length ( freq.traj.list [[ i ]] ) ] <- freq.traj.list [[ i ]]#
		}#
		#freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	# temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	# add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	# temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	# freq.trajectories <- do.call ( rbind , temp2 )#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	#library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	no.sing.haps.right <- no.sing.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
			no.sing.haps.right [ , i ] <- no.sing.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.right [ j , i ] <- sum ( table ( my.seqs$right.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
					no.sing.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.left [ j , i ] <- sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
					no.sing.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	no.sing.haps <- rbind ( no.sing.haps.right , no.sing.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	no.sing.hap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , no.sing.hap.count.freqs.by.interval = no.sing.hap.count.freqs.by.interval , n.haps = n.haps , no.sing.haps = no.sing.haps ) )#
}#
StandingHapCountDist <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events#
				my.rec.events.off <- input [[ j ]] $ rec.events.off.background#
				# right side#
				sweep.recs <- my.rec.events$rec.right$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.right$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.right$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- extract.clade ( input [[ j ]]$tree , i )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.right.off.background$sequence.location < k )#
					my.tab <- table ( my.seqs$right.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] )#
					n.haps.right [ j , i ] <- sum ( my.tab > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				sweep.recs <- my.rec.events$rec.left$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.left$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.left$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- GetTips ( i , n.tips , input[[j]]$tree$edge )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.left.off.background$sequence.location < k )#
					my.tab <- table ( my.seqs$left.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] )#
					n.haps.left [ j , i ] <-  sum ( my.tab > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#recover()#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	#stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		# }#
	# }#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
#
GetTips <- function ( branch , n.tips , edges ) {#
	#recover()#
	if ( branch <= n.tips ) {#
		return ( branch )#
	}#
	subtend <- edges [ edges [  , 1 ] == branch , 2 ]#
	if ( all ( subtend <= n.tips ) ) {#
		return ( subtend )#
	} else {#
		sapply ( subtend , function ( x ) GetTips ( x , n.tips , edges ) )#
	}#
}#
#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = FALSE ,  time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
#
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.05 , f = 0.01 , reps = 100 , n.tips = 12 , r = 10^-8 , sim.distance = 0.015 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)#
#
SequenceIBDPlots <- function ( trees ) {#
	#recover()#
	seq.structure <- trees$sequence.structure#
	seq.resort <- do.call(what = order, as.data.frame(seq.structure))#
	seq.structure <- lapply ( seq.structure , function ( x ) x [ seq.resort , ] )#
	rec.points <- trees$rec.events.off.background#
	scaled.rec.points <- list ()#
	scaled.rec.points$right <- c ( 0 , rec.points$rec.right.off.background$sequence.location / trees$sim.distance , 1 )#
	scaled.rec.points$left <- - c ( 0 , rec.points$rec.left.off.background$sequence.location / trees$sim.distance , 1 )#
	#my.cols <- rainbow ( max ( unlist ( seq.structure ) ) + 1 , alpha = 0.7 )#
	my.cols.right <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Paired" )#
	my.cols.left <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Set3" )#
	plot ( NA , bty = "n" , xlim = c ( -1 , 1 ) , ylim = c ( 0 , 12 ) , xaxt = "n" , yaxt = "n" , ylab = "" , xlab = "" )#
#
	### right side#
	for ( row in seq_len ( nrow ( seq.structure$right.seq ) ) ) {#
		my.recs <- unique ( seq.structure$right.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$right.seq[row,] ) , max ( unlist ( seq.structure$right.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.right [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	### left side#
	for ( row in seq_len ( nrow ( seq.structure$left.seq ) ) ) {#
		my.recs <- unique ( seq.structure$left.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$left.seq[row,] ) , max ( unlist ( seq.structure$left.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.left [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	abline ( v = 0 )#
}#
#
if ( FALSE) SequenceIBDPlots ( temp$trees[[1]] )#
par ( mfrow = c ( 3 ,2 ) )#
for ( i in 1 : 6 ) SequenceIBDPlots ( temp$trees[[i]] )#
###########################################
#### Let's think about inference w/ genealogies #####
###########################################
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
for ( i in 1 : length ( coal.times ) ) {#
	log.likes[[i]] <- lapply ( 1:nrow(coal.times[[i]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times[[i]] [ y , ] , x , 20000 ) ) )#
	print ( i )#
}#
#log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(z) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( z [ y , ] , x , 20000 ) ) )  )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.02, sim.distance = 0.05)
names ( temp)
names ( temp$hap.dist)
names ( temp$standing.hap.dist)
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.02, sim.distance = 0.05)
##install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , display.rep.count = TRUE , time.factor = 1 ) {#
	options ( error = recover )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix , display.rep.count )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- temp [[ 2 ]]#
			# sweep.start.forward <- ncol ( frequencies ) - sweep.start #
			# # if ( nrow ( frequencies ) > 1 ) {#
			# fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			# zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			# entry <- numeric()#
			# for ( i in 1 : length ( zeros ) ){#
				# if ( length ( zeros [[ i ]] ) != 0 ) {#
					# entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				# } else {#
					# entry [ i ] <- 1#
				# }#
			# }#
			# transit.time <- fixation.time - entry#
			new.freqs <- temp [[ 1 ]]#
			# for ( i in 1 : nrow ( frequencies ) ) {#
				# new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			# }#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
		trees [[ i ]] [[ "sweep.start"]] <- sweep.start [ i ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f  )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
		#recover()#
		standing.hap.dist <- StandingHapCountDist ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , standing.hap.dist = standing.hap.dist , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , display.rep.count , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 & display.rep.count) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	sweep.start <- apply ( sweep.freq.matrix , 1 , function ( x ) which.max ( x ) / time.factor )#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
	if ( no.sweep == FALSE ) {#
		freq.traj.list <- mapply ( 	function ( X , Y ) {#
											#recover()#
											fixation <- which.max ( Y )#
											mutation <- sum ( X > 0 )#
											freq <- c ( rev ( Y [ 2 : fixation ] ) , X [ 1 : mutation ] )#
											return ( freq )#
										} ,#
										X = split ( neutral.freq.matrix , 1 : nrow ( neutral.freq.matrix ) ) , #
										Y = split ( sweep.freq.matrix , 1 : nrow ( sweep.freq.matrix ) )#
							)#
		freq.trajectories <- matrix ( 0 , ncol = max ( unlist ( lapply ( freq.traj.list , length ) ) ) , nrow = reps )#
		for ( i in seq_len ( nrow ( freq.trajectories ) ) ) {#
			freq.trajectories [ i , 1 : length ( freq.traj.list [[ i ]] ) ] <- freq.traj.list [[ i ]]#
		}#
		#freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	# temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	# add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	# temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	# freq.trajectories <- do.call ( rbind , temp2 )#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	#library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	no.sing.haps.right <- no.sing.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
			no.sing.haps.right [ , i ] <- no.sing.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.right.off.background$sequence.location < k )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.right [ j , i ] <- sum ( table ( my.seqs$right.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
					no.sing.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events$rec.left.off.background$sequence.location < k )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
					no.sing.haps.left [ j , i ] <- sum ( table ( my.seqs$left.seq [ , last.rec.event + 1 ] ) > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
					no.sing.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	no.sing.haps <- rbind ( no.sing.haps.right , no.sing.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	no.sing.hap.counts.by.interval <- apply ( no.sing.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	no.sing.hap.count.freqs.by.interval <- apply ( no.sing.hap.counts.by.interval , 2 , function ( x ) x / nrow ( no.sing.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , no.sing.hap.count.freqs.by.interval = no.sing.hap.count.freqs.by.interval , n.haps = n.haps , no.sing.haps = no.sing.haps ) )#
}#
StandingHapCountDist <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	#recover()#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events#
				my.rec.events.off <- input [[ j ]] $ rec.events.off.background#
				# right side#
				sweep.recs <- my.rec.events$rec.right$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.right$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.right$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- extract.clade ( input [[ j ]]$tree , i )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.right.off.background$sequence.location < k )#
					my.tab <- table ( my.seqs$right.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] )#
					n.haps.right [ j , i ] <- sum ( my.tab > 1 )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				sweep.recs <- my.rec.events$rec.left$rec.depth < input [[ j ]]$sweep.start #
				site.side <- my.rec.events$rec.left$sequence.location < k#
				sweep.killed.branches <- my.rec.events$rec.left$branch [ site.side & sweep.recs ]#
				sweep.killed.branches <- unique ( unlist ( sapply ( unique ( sweep.killed.branches ) , function ( x ) GetTips ( x , n.tips , input [[ j ]]$tree$edge) ) ) )#
				# if ( any ( sweep.killed.branches > n.tips ) ) {#
					# internal.recs <- sweep.killed.branches [ sweep.killed.branches > n.tips ]#
					# for ( i in internal.recs ) {#
						# temp <- GetTips ( i , n.tips , input[[j]]$tree$edge )#
						# my.tips <- as.numeric ( unlist ( lapply ( strsplit ( temp$tip.label , "t" ) , function ( x ) x [ 2 ] ) ) )#
						# sweep.killed.branches <- c ( sweep.killed.branches , my.tips )#
					# }#
					# sweep.killed.branches <- unique ( sweep.killed.branches [ sweep.killed.branches <= n.tips ] )#
				# }#
				if ( sum ( my.rec.events.off$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- sum ( my.rec.events.off$rec.left.off.background$sequence.location < k )#
					my.tab <- table ( my.seqs$left.seq [ unlist ( ifelse ( is.null ( sweep.killed.branches ) , list(seq_len(n.tips)) ,  list(-sweep.killed.branches) ) ) , last.rec.event + 1 ] )#
					n.haps.left [ j , i ] <-  sum ( my.tab > 1 )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 0 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#recover()#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	#stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		# }#
	# }#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 )#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
#
GetTips <- function ( branch , n.tips , edges ) {#
	#recover()#
	if ( branch <= n.tips ) {#
		return ( branch )#
	}#
	subtend <- edges [ edges [  , 1 ] == branch , 2 ]#
	if ( all ( subtend <= n.tips ) ) {#
		return ( subtend )#
	} else {#
		sapply ( subtend , function ( x ) GetTips ( x , n.tips , edges ) )#
	}#
}#
#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = FALSE ,  time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
#
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.05 , f = 0.01 , reps = 100 , n.tips = 12 , r = 10^-8 , sim.distance = 0.015 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05)#
#
SequenceIBDPlots <- function ( trees ) {#
	#recover()#
	seq.structure <- trees$sequence.structure#
	seq.resort <- do.call(what = order, as.data.frame(seq.structure))#
	seq.structure <- lapply ( seq.structure , function ( x ) x [ seq.resort , ] )#
	rec.points <- trees$rec.events.off.background#
	scaled.rec.points <- list ()#
	scaled.rec.points$right <- c ( 0 , rec.points$rec.right.off.background$sequence.location / trees$sim.distance , 1 )#
	scaled.rec.points$left <- - c ( 0 , rec.points$rec.left.off.background$sequence.location / trees$sim.distance , 1 )#
	#my.cols <- rainbow ( max ( unlist ( seq.structure ) ) + 1 , alpha = 0.7 )#
	my.cols.right <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Paired" )#
	my.cols.left <- brewer.pal ( max ( unlist ( seq.structure ) ) + 1 , "Set3" )#
	plot ( NA , bty = "n" , xlim = c ( -1 , 1 ) , ylim = c ( 0 , 12 ) , xaxt = "n" , yaxt = "n" , ylab = "" , xlab = "" )#
#
	### right side#
	for ( row in seq_len ( nrow ( seq.structure$right.seq ) ) ) {#
		my.recs <- unique ( seq.structure$right.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$right.seq[row,] ) , max ( unlist ( seq.structure$right.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$right [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.right [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	### left side#
	for ( row in seq_len ( nrow ( seq.structure$left.seq ) ) ) {#
		my.recs <- unique ( seq.structure$left.seq[row,] )#
		recode.my.recs <-  c ( unique ( seq.structure$left.seq[row,] ) , max ( unlist ( seq.structure$left.seq ) ) + 1 ) + 1#
		for ( i in seq_along ( my.recs ) ) {#
			polygon ( x = c ( scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] , scaled.rec.points$left [ recode.my.recs [ i + 1 ] ] ) , y = c ( row , row - 1 , row - 1 , row  ) , col = my.cols.left [ my.recs [ i ] + 1 ] , lty = 0 )#
		}#
	}#
	abline ( v = 0 )#
}#
#
if ( FALSE) SequenceIBDPlots ( temp$trees[[1]] )#
par ( mfrow = c ( 3 ,2 ) )#
for ( i in 1 : 6 ) SequenceIBDPlots ( temp$trees[[i]] )#
###########################################
#### Let's think about inference w/ genealogies #####
###########################################
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
for ( i in 1 : length ( coal.times ) ) {#
	log.likes[[i]] <- lapply ( 1:nrow(coal.times[[i]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times[[i]] [ y , ] , x , 20000 ) ) )#
	print ( i )#
}#
#log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(z) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( z [ y , ] , x , 20000 ) ) )  )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = 0.03 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 5000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.03, sim.distance = 0.05)
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.03, sim.distance = 0.05 , interval.width = 5000 )
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = 0.04 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 5000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.04, sim.distance = 0.05 , interval.width = 5000 )
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = 0.05 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.02 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$hap.dist$no.sing.hap.count.freqs.by.interval , N = 10000, f = 0.05, sim.distance = 0.05 , interval.width = 5000 )
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.05, sim.distance = 0.05 , interval.width = 5000 )
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = 0.05 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.05, sim.distance = 0.05 , interval.width = 5000 )
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.05, sim.distance = 0.05 , interval.width = 1000 )
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.03 , f = 0.01 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 10000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.05 , interval.width = 10000)
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.03 , f = 0.02 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 10000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.02, sim.distance = 0.05 , interval.width = 10000)
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.03 , f = 0.03 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 10000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.03, sim.distance = 0.05 , interval.width = 10000)
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.03 , f = 0.04 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 10000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.04, sim.distance = 0.05 , interval.width = 10000)
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#recover()#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	#stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		# }#
	# }#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 ) , #
		xaxt = ""#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}
temp <- StructuredCoalescentSweep ( N = 10000 , s = 0.03 , f = 0.04 , reps = 200 , n.tips = 20 , r = 10^-8 , sim.distance = 0.05 , interval.width = 10000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = TRUE ,  time.factor = 1 )#
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.04, sim.distance = 0.05 , interval.width = 10000)
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.04, sim.distance = 0.05 , interval.width = 10000)
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#recover()#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	#stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		# }#
	# }#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 ) , #
		xaxt = "n"#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.04, sim.distance = 0.05 , interval.width = 10000)
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- max ( as.numeric ( rownames(hap.count.freqs.by.interval ) ) )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	#stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		# }#
	# }#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	recover()#
<<<<<<< HEAD
#####
	ts_mean <- (n_pop - 1 ) * ( p_bars * ( 1 - p_bars ) - rowMeans ( new_ps * ( 1 - new_ps ) ) ) / ( Fst * p_bars * ( 1 - p_bars ) )#
	hist ( ts_mean , breaks = 50 , freq = F )#
	curve ( dchisq ( x , n_pop - 1  ) , add = T , col = "red")#
	#####
	var_mean <- rowSums ( ( new_ps- p_bars )^2 ) / ( Fst * p_bars * ( 1 - p_bars ) )#
	hist ( var_mean , breaks = 50 , freq = F )#
	curve ( dchisq ( x , n_pop - 1  ) , add = T , col = "red")#
	#####
	ts_true <- (n_pop ) * ( p * ( 1 - p ) - rowMeans ( new_ps * ( 1 - new_ps ) ) )  / ( Fst * ( p * ( 1 - p ) ) )#
	hist ( ts_true , breaks = 50 , freq = F )#
	curve ( dchisq ( x , n_pop  ) , add = T , col = "red")#
	#####
	var_true <- rowSums ( ( new_ps- p )^2 ) / ( Fst * p * ( 1 - p ) )#
	hist ( var_true , breaks = 50 , freq = F )#
	curve ( dchisq ( x , n_pop  ) , add = T , col = "red")#
	hist ( ts_true , breaks = 50 , freq = F , col = rgb ( 1 , 0 , 0 , 0.4 ) )#
	hist ( ts_true , breaks = 50 , freq = F , col = rgb ( 1 , 0 , 0 , 0.4 ) )#
#
}#
MakeVar ( 0.5 , 10000 , 0.01 , 2 , rand = T , n_loc = 10 )
hist ( my.stat , breaks = 50 , freq = F)
curve ( dnorm ( x , mean ( my.stat ), sd ( my.stat )) , add = T , col = "red")
p=0.45
p <- matrix ( p	, nrow = n_loc , ncol = n_rep )#
		new_ps <- apply ( p , 2 , function ( x ) x + rmvnorm ( 1 , sigma = Fst * x * ( 1 - x ) * diag ( n_loc ) ) )#
		new_ps <- ifelse ( new_ps < 0 , 0 , new_ps)#
		new_ps <- ifelse ( new_ps > 1 , 1 , new_ps)#
		vars_t <- colSums ( new_ps * ( 1 - new_ps ) )#
		vars_start <- colSums ( p * ( 1 - p ) )#
		my.stat <- ( vars_start - vars_t ) / ( Fst * vars_start )
hist ( my.stat , breaks = 50 , freq = F)
curve ( dnorm ( x , mean ( my.stat ), sd ( my.stat )) , add = T , col = "red")
p <- numeric ( n_loc * n_rep )
p
tmp <- runif ( )
tmp <- runif ( 1 )
tmp
blah <- integrate( function ( x ) 1/ x  , 0 , 1 )
blah <- integrate( function ( x ) 1/ x  , 0.00001 , 1 )
blah
integrate( function ( x ) 1/ x  , 0.000001 , 1 )
integrate( function ( x ) 1/ x  , 0.0000001 , 1 )
integrate( function ( x ) 1/ x  , 0.00000001 , 1 )
1/20000
integrate( function ( x ) 1/ x  , 1/20000 , 19999/20000 )
tmp <- runif ( 1 )
tmp
denom <- integrate( function ( x ) 1/ x  , 1/20000 , 19999/20000 )
1/tmp
(1/tmp)/denom
denom
names(denom)
denom$value
(1/tmp)/denom$value
n_rep
tmp
p <- numeric ( n_loc * n_rep )
i = 1 #
		while ( i <= n_loc * n_rep ) {#
			tmp <- runif ( 1 )#
			denom <- integrate( function ( x ) 1/ x  , 1/20000 , 19999/20000 )#
			if ( runif ( 1 ) < (1/tmp)/denom$value ) {#
				p [ i ] <- tmp#
				i <- i + 1#
			} else {#
				next#
			}#
		}
p
hist ( p , breaks = 500 , freq = F)
hist ( p , breaks = 50 , freq = F)
tmp =0.0001
denom
denom <- integrate( function ( x ) 1/ x  , 1/20000 , 19999/20000 )
denom
1/tmp
(1/tmp)/denom$value
tmp
tmp = 0.0000001
tmp < 1/20000
p <- numeric ( n_loc * n_rep )#
		i = 1 #
		while ( i <= n_loc * n_rep ) {#
			tmp <- runif ( 1 )#
			if ( tmp < 1/20000 | tmp > ( 1 - 1/20000 ) ) next#
			denom <- integrate( function ( x ) 1/ x  , 1/20000 , 19999/20000 )#
			if ( runif ( 1 ) < (1/tmp)/denom$value ) {#
				p [ i ] <- tmp#
				i <- i + 1#
			} else {#
				next#
			}#
		}
p
hist ( p , breaks = 50)
denom <- integrate( function ( x ) 1/ x  , 0.00000000000000001 , 1 )
denom
p <- numeric ( n_loc * n_rep )#
		i = 1 #
		denom <- integrate( function ( x ) 1/ x  , 0.00000000000000001 , 1 )#
		while ( i <= n_loc * n_rep ) {#
			tmp <- runif ( 1 )#
			if ( tmp < 1/20000 | tmp > ( 1 - 1/20000 ) ) next#
			if ( runif ( 1 ) < (1/tmp)/denom$value ) {#
				p [ i ] <- tmp#
				i <- i + 1#
			} else {#
				next#
			}#
		}
p
SoftSweepSim <- function ( N_A , N_a , s1 , s2 = NULL , h , switch = 0 , mu , gens , mut.index = 1001 , stop.at.fix = TRUE , reuse.mutant.classes = FALSE , suppress.output = FALSE , suppress.plot = FALSE , sort.mutation.time = FALSE ) {#
	options ( error = recover )#
	###########################
	####### Initialize ########
	##########################	#
	num.A.class <- length ( N_A )#
	num.a.class <- length ( N_a )#
	pA.vect <- matrix ( c ( N_A / sum ( N_A , N_a ), rep ( 0, length ( N_A ) ) ) , nrow = num.A.class , ncol = 1 )	#
	pa.vect <- matrix ( c ( N_a / sum ( N_A , N_a ), rep ( 0, length ( N_a ) ) ) , nrow = num.a.class , ncol = 1 )	#
	A.classes <- 1 : num.A.class#
	a.classes <- mut.index : ( mut.index + num.a.class -1 )#
	if ( switch > 0 ){#
		s <- s1#
	} else {#
		s <- s2#
	}#
	allele.classes.all <- c ( A.classes , mut.index : ( mut.index + ( num.a.class - 1 ) ) )#
	pA.presel <- matrix ( N_A / sum ( N_A , N_a ) )#
	pa.presel <- matrix ( N_a / sum ( N_A , N_a ) )#
	###########################
	####### Simulation ########
	###########################
	i <- 1#
	while ( ( sum ( pa.vect [ , i ] ) < 1 | stop.at.fix == FALSE ) & i < gens ) {#
		if ( mu == 0 & sum ( N_a ) == 0 ) {#
			cat ( "Allele lost from population. \n")#
			return()#
		}#
		################
		## selection ###
		################
		pA.vect <- cbind ( pA.vect , 0 )#
		pa.vect <- cbind ( pa.vect , 0 )#
		pA.temp <- rowSums ( pA.presel %*% t ( pA.presel ) ) + rowSums ( pA.presel %*% t ( pa.presel ) ) * ( 1 + s )#
		pa.temp <- colSums ( pa.presel %*% t ( pa.presel ) ) * ( 1 + 2*s ) + colSums ( pA.presel %*% t ( pa.presel ) ) * ( 1 + s )#
		mean.fitness <- sum( pA.presel %*% t ( pA.presel ) ) + 2*sum ( pA.presel %*% t ( pa.presel ) )*( 1 + s ) + sum( pa.presel %*% t ( pa.presel ) ) * ( 1 + 2*s )#
		pA.postsel <- pA.temp / mean.fitness#
		pa.postsel <- pa.temp / mean.fitness#
		pA.vect [ , i + 1 ] <- pA.postsel#
		pa.vect [ , i + 1 ] <- c ( pa.postsel , rep ( 0 , nrow ( pa.vect ) - length ( pa.postsel ) ) )#
		############
		## drift ###
		############
		next.gen <- sample ( c ( A.classes , a.classes ) , size = sum ( N_A , N_a ) , prob = c ( pA.vect [ , i + 1 ] , pa.vect [ , i + 1 ] ) , replace = TRUE )#
		next.gen <- sort ( next.gen )#
		allele.classes.present <- rle ( next.gen )$values#
		allele.classes.absent <- allele.classes.all [ allele.classes.all %in% allele.classes.present == FALSE ]#
		allele.abundance <- c ( rle ( next.gen )$lengths , rep ( 0 , length ( allele.classes.absent ) ) )#
		allele.classes.all <- c ( allele.classes.present , allele.classes.absent )#
		allele.abundance <- allele.abundance [ order ( allele.classes.all ) ]#
		allele.classes.all <- allele.classes.all [ order ( allele.classes.all ) ]#
		A.classes <- allele.classes.all [ allele.classes.all < mut.index ] #
		a.classes <- allele.classes.all [ allele.classes.all >= mut.index ] #
		N_A <- allele.abundance [ allele.classes.all < mut.index ]#
		N_a <- allele.abundance [ allele.classes.all >= mut.index ]#
		pA.premut <- matrix ( N_A / sum ( N_A , N_a ) )#
		pa.premut <- matrix ( N_a / sum ( N_A , N_a ) )		#
		###############
		## mutation ###
		###############
		if ( mu != 0 ) {#
			## roll N_total uniform random numbers; the number that are less than 	#
			mut.probs <- runif ( n = sum ( N_A , N_a ) )#
			new.mutations <- sum ( mut.probs < mu )#
			if ( new.mutations != 0 ) {#
				# let the mutations pick parents in proportion to their frequency#
				mut.from <- sort ( sample ( c ( rep ( A.classes , times = N_A ) , rep ( a.classes , times = N_a ) ) , size = new.mutations , replace = FALSE ) )#
				mutating.alleles <- rle ( mut.from )$values#
				non.mutating.alleles <- allele.classes.all [ allele.classes.all %in% mutating.alleles == FALSE ]#
				mutation.counts.all.alleles <- c ( rle ( mut.from )$lengths , rep ( 0 , length ( non.mutating.alleles ) ) )#
				mutation.id.all.alleles <- c ( mutating.alleles , non.mutating.alleles )#
				mutation.counts.all.alleles <- mutation.counts.all.alleles [ order ( mutation.id.all.alleles ) ]#
				mutation.id.all.alleles <- mutation.id.all.alleles [ order ( mutation.id.all.alleles ) ]#
				mut.from.A <- mutation.counts.all.alleles [ mutation.id.all.alleles < mut.index ]#
				mut.from.a <- mutation.counts.all.alleles [ mutation.id.all.alleles >= mut.index ]#
				if ( reuse.mutant.classes == TRUE ) {#
					idx <- c( a.classes [ N_a == 0 ] , ( max ( mutation.id.all.alleles ) + 1 ) : ( max ( mutation.id.all.alleles ) + new.mutations ) )#
					new.mut.idx <- idx [ 1 : new.mutations ]#
					new.IDs <- new.mut.idx [ new.mut.idx %in% a.classes == FALSE ]#
				} else if ( reuse.mutant.classes == FALSE ) {#
					new.mut.idx <- new.IDs <- ( max ( mutation.id.all.alleles ) + 1 ) : ( max ( mutation.id.all.alleles ) + new.mutations )#
				}#
				a.classes <- c ( a.classes, new.IDs )#
				N_a <- c ( N_a , rep ( 0 , length ( new.IDs ) ) )#
				pa.vect <- rbind ( pa.vect , matrix ( 0 , nrow = length ( new.IDs ) , ncol = ncol ( pa.vect ) ) )#
				N_a [ a.classes %in% new.mut.idx ] <- 1#
				N_A <- N_A - mut.from.A#
				N_a [ a.classes %in% new.IDs == FALSE ] <- N_a [ a.classes %in% new.IDs == FALSE ] - mut.from.a#
				allele.classes.all <- c ( A.classes , a.classes )#
			}#
		}#
		##################
		## bookkeeping ###
		#################		#
		if ( i == switch & is.null ( s2 ) == FALSE ) {#
			s <-  s2 #
		}#
		i <- i + 1#
		pA.presel <- matrix ( N_A / sum ( N_A , N_a ) )#
		pa.presel <- matrix ( N_a / sum ( N_A , N_a ) )#
		if ( i %% 20 == 0 & suppress.output == FALSE ){#
			cat (  i , "p =" , sum ( pa.vect [ , i ] ) , "\n" )#
		}#
	}#
	if ( switch > 100 ) {#
		pre.switch.freqs <- pa.vect [ , 101:switch ]#
	} else {#
		pre.switch.freqs <- NULL#
		mean.coal.prob.sim.mut.sel.drift <- NULL#
		coal.prob.sim.mut.sel.drift <- NULL#
	}#
	###########################
	##### End Point Data ######
	###########################
	pA.order <- order ( pA.vect [ , ncol ( pA.vect ) ] , decreasing = FALSE ) #
	pa.order <- order ( pa.vect [ , ncol ( pa.vect ) ] , decreasing = FALSE )#
	pa.lost <-  which ( pa.vect [ , ncol ( pa.vect ) ] == 0 )#
	pa.fixed <- which ( pa.vect [ , ncol ( pa.vect ) ] != 0 )#
	all.freqs <- rbind ( pa.vect [ pa.order , ] , pA.vect [ pA.order , ] )#
	all.freqs.unsorted <- rbind ( pa.vect , pA.vect )#
	###########################
	######## Plotting #########
	###########################
	if ( suppress.plot == FALSE ) {#
		if ( reuse.mutant.classes == TRUE ) {	#
			#recover()#
			cum.freqs <- rbind ( 0 , apply ( all.freqs , 2 , cumsum ))#
			green.mat <- matrix ( c ( rep ( 0 , length ( pa.order ) + 1 ) , seq ( from = .3 , to = 1 , length.out = length ( pa.order ) + 1 ) , rep ( 0 , length ( pa.order ) +1 ) ) , nrow = length ( pa.order ) + 1 )#
			blue.mat <- matrix ( c ( rep ( 0 , 2 * length ( pA.order ) ) , seq ( from = .7 , to = 1 , length.out = length ( pA.order ) ) ) , nrow = length ( pA.order ) )#
			col.vect <- rgb ( rbind ( green.mat , blue.mat) , alpha = .65 , maxColorValue = 1 )#
		} else if ( sort.mutation.time == FALSE ) {#
			cum.freqs <- rbind ( 0 , apply ( all.freqs , 2 , cumsum ))#
			if ( length ( pa.lost ) != 0 ) {#
				red.mat <- matrix ( c ( seq ( from = .3 , to = 1 , length.out = length ( pa.lost ) ) [ 1 : length ( pa.lost ) ] , rep ( 0 , 2 * length ( pa.lost ) ) ) , nrow = length ( pa.lost ) )#
			} else {#
				red.mat <- matrix ( nrow = 0 , ncol = 3 )#
			}#
			green.mat <- matrix ( c ( rep ( 0 , length ( pa.fixed ) ) , rev ( seq ( from = 1 , to = .4 , length.out = length ( pa.fixed ) ) ) [ 1 : length ( pa.fixed ) ] , rep ( 0 , length ( pa.fixed ) ) ) , nrow = length ( pa.fixed ) )#
			blue.mat <- matrix ( c ( rep ( 0 , 2 * length ( pA.order ) ) , seq ( from = .7 , to = 1 , length.out = length ( pA.order ) ) ) , nrow = length ( pA.order ) )#
			col.vect <- rgb ( rbind ( red.mat , green.mat , blue.mat) , alpha = .65 , maxColorValue = 1 )#
		} else if ( sort.mutation.time == TRUE ) {#
			cum.freqs <-  apply ( all.freqs.unsorted , 2 , cumsum )#
			if ( length ( pa.lost ) != 0 ) {#
				red.mat <- matrix ( c ( seq ( from = .3 , to = 1 , length.out = length ( pa.lost ) ) [ 1 : length ( pa.lost ) ] , rep ( 0 , 2 * length ( pa.lost ) ) ) , nrow = length ( pa.lost ) )#
			} else {#
				red.mat <- matrix ( nrow = 0 , ncol = 3 )#
			}#
			green.mat <- matrix ( c ( rep ( 0 , length ( pa.fixed ) ) , rev ( seq ( from = 1 , to = .4 , length.out = length ( pa.fixed ) ) ) [ 1 : length ( pa.fixed ) ] , rep ( 0 , length ( pa.fixed ) ) ) , nrow = length ( pa.fixed ) )#
			blue.mat <- matrix ( c ( rep ( 0 , 2 * length ( pA.order ) ) , seq ( from = .7 , to = 1 , length.out = length ( pA.order ) ) ) , nrow = length ( pA.order ) )#
			col.vect <- character ( nrow ( cum.freqs ) )#
			col.vect [ pa.lost ] <- rgb ( red.mat , alpha = .65 , maxColorValue = 1 )#
			col.vect [ pa.fixed ] <- rgb ( green.mat , alpha = .65 , maxColorValue = 1 )#
			col.vect [ ( nrow ( pa.vect ) + 1 ) : nrow ( cum.freqs ) ] <- rgb ( blue.mat , alpha = .65 , maxColorValue = 1 )#
		}#
	#	recover()#
		no.lines <- sum ( cum.freqs [ , ncol ( cum.freqs ) ] < 0.01 )#
		line.vector <- c ( rep ( 0 , no.lines ) , rep ( .35 , nrow ( cum.freqs ) - no.lines ) )#
		matplot ( t ( cum.freqs ) , type = "l" , lty = "solid" , lwd = line.vector , col = "black" , xlab = "Generations" , ylab = "Cumulative Frequency" , bty = "n" )#
		for ( i in 1 : ( nrow ( cum.freqs ) - 1 ) ) {#
			#i = i + 1#
			X.ax <- which ( cum.freqs [ i , ] != cum.freqs [ i + 1 , ] )#
			Y.ax1 <- cum.freqs [ i , X.ax ]#
			Y.ax2 <- cum.freqs [ i + 1 , X.ax ]#
			polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
		}#
		if ( switch > 0 ) {#
			segments (x0 = switch , y0 = 0 , y1 = 1.0 , lty = 2 )#
		}#
	}	#
	#mut.sel.max <- max(cum.freqs [ length (pa.lost ), ])#
	#matplot ( t ( cum.freqs [1: length ( c ( pa.lost , pa.fixed ) ) , ] ) , type = "l" , lty = 1 , lwd = 1 , col = "black" , ylim = c ( 0 , mut.sel.max * 1.1 ) )#
	if ( switch > 100 ) {#
		coal.prob.sim.mut.sel.drift <- numeric ( ncol ( pre.switch.freqs ) )#
		for ( i in 1 : ncol ( pre.switch.freqs ) ) {#
				coal.prob.sim.mut.sel.drift [ i ] <- sum ( ( pre.switch.freqs [ , i ] / sum ( pre.switch.freqs [ , i ] ) )^2 )#
		}#
	mean.coal.prob.sim.mut.sel.drift <- mean ( coal.prob.sim.mut.sel.drift )#
	}#
	coal.prob.sim.fix <- sum( (pa.vect [ , ncol(pa.vect) ])^2 )#
	coal.prob.theory.fix <- 1 / ( 1 + 2 * sum ( N_A , N_a ) * mu )#
	if ( s1 < 0 ) {#
		coal.prob.theory.mut.sel.determin <- 1 / ( 1 + 2 * sum ( N_A , N_a ) * mu / (1 + abs ( s1 ) ) )	#
	} else {#
		coal.prob.theory.mut.sel.determin = NULL#
	}#
	if ( suppress.output == FALSE ) {#
		cat ( "Coalescence probability from simulation for lineages sampled at fixation =" , coal.prob.sim.fix , "\n" )#
		cat ( "Coalescence probability from theory for lineages sampled at fixation =" , coal.prob.theory.fix , "\n" )#
		if ( switch > 100 ) {#
			cat ( "Coalescence probability from simulation for lineages sampled at mut-sel-drift balance =" , mean.coal.prob.sim.mut.sel.drift , "\n" )#
		}#
		cat ( "Coalescence probability from theory for lineages sampled at deterministic mut-sel balance =" , coal.prob.theory.mut.sel.determin , "\n" )#
	}#
	return ( list ( pA = pA.vect , pa = pa.vect , coal.prob.sim.fix = coal.prob.sim.fix , coal.prob.theory.fix = coal.prob.theory.fix , pre.switch.freqs = pre.switch.freqs , mean.coal.prob.sim.mut.sel.drift = mean.coal.prob.sim.mut.sel.drift , coal.prob.sim.mut.sel.drift = coal.prob.sim.mut.sel.drift) )#
}#
#
SweepReplicates <- function ( N_A , N_a , s1 , s2 = NULL , h , switch = 0 , shut.mut.off = FALSE , stop.at.fix = TRUE , reuse.mutant.classes = TRUE , mu , gens , mut.index = 1001 , reps , suppress.output = TRUE , suppress.plot = TRUE ){#
#
	recover()#
	#prob.at.fix <- numeric ( reps )#
	#prob.at.balance <- numeric ( reps * ( switch - 100 ) )#
	for ( r in 1 : reps ) {#
		temp <- SoftSweepSim ( N_A = N_A , N_a = N_a , s1 = s1 , s2 = s2 , switch = switch , stop.at.fix = stop.at.fix , reuse.mutant.classes = reuse.mutant.classes , mu = mu , gens = gens , suppress.output = suppress.output , suppress.plot = suppress.plot )#
		prob.at.fix [ r ] <- temp[[1]]#
		prob.at.balance [ ( ( switch - 100 ) * ( r - 1 ) + 1 ) : ( ( r * ( switch - 100 ) - 1 ) + 1 ) ] <- temp[[2]]#
		cat ( "rep =" , r , "\n" )#
		if ( r %% 20 == 0 ) {	#
			mean.prob.at.balance.only.present <- mean ( prob.at.balance [ 1 : r * ( switch - 100 ) ] , na.rm = TRUE )#
			prob.at.balance.zeros <- prob.at.balance#
			prob.at.balance.zeros [ is.nan ( prob.at.balance.zeros ) ] <- 0#
			mean.prob.at.balance.zeros <- mean ( prob.at.balance.zeros [ 1 : r * ( switch - 100 ) ] )#
			prob.hartl.theory <- 1 / ( 1 + 2 * sum ( N_a , N_A ) * mu * 1 / (1 + abs(s1) ) )#
			prob.fix.herm.penn <- 1 / ( 1 + 2 * sum ( N_a , N_A ) * mu )#
			prob.at.fix.sim <- mean ( prob.at.fix [1 : r ] )#
			cat ( "sim prob at balance =" , mean.prob.at.balance.only.present , "\n")#
			cat ( "hartl prob at balance =" , prob.hartl.theory , "\n")#
			cat ( "sim prob at balance w/ zeros =" , mean.prob.at.balance.zeros , "\n")#
			cat ( "herm penn prob at fix =" , prob.fix.herm.penn , "\n")#
			cat ( "sim prob at fix =" , prob.at.fix.sim , "\n")#
		}#
	}	#
	return ( list ( prob.at.fix = prob.at.fix , prob.at.balance = prob.at.balance ) )#
}#
#
DiversityPlot <- function ( N , mu.b , mu.n , l , r , s , threshold ){#
	diversity.hard <- diversity.soft <- coal.prob.soft <- coal.prob.hard <- numeric ()#
	no.mut.prob <- 1 / ( 1 + N * mu.b ) #
	no.rec.prob <- exp ( -0.5 * ( log ( N * s ) / s ) * ( l - 1 ) * r )			#
	coal.prob.soft <- no.rec.prob * no.mut.prob#
	coal.prob.hard <- no.rec.prob#
	diversity.soft <- ( ( 2 * mu.n ) / ( 1 / ( 2 * N ) ) ) * ( 1 - coal.prob.soft [ l ] )#
	diversity.hard <- ( ( 2 * mu.n ) / ( 1 / ( 2 * N ) ) ) * ( 1 - coal.prob.hard [ l ] )#
	plot ( x = c ( - rev ( l ) , l  ) , y = c ( rev ( diversity.soft ) , diversity.soft ) , type = "l" , ylim = c ( 0 , ( ( 2 * mu.n ) / ( 1 / ( 2 * N ) ) ) * 1.1 ) , xlab = "Position" , ylab = "Diversity" )#
	lines ( x = c ( - rev ( l ) , l  ) , y = c ( rev ( diversity.hard ) , diversity.hard ) , type = "l" , col = "red")#
#
	legend ( "bottomright" , legend = c ( "Soft Sweep" , "Hard Sweep" ) , lty = 1 , col = c ( "black" , "red" ) , bty = "n" )#
#
	recover()#
	neutral.diversity <- 2*mu.n/(1/(2*N))#
	min ( which ( diversity.hard > 0.99*neutral.diversity ) )#
}
temp <- SweepReplicates ( N_A = c ( 200000 ) , N_a = c ( 0 ) , s1 = -0.001 , s2 = 0.01 , switch = 0 , shut.mut.off = FALSE , stop.at.fix = TRUE , reuse.mutant.classes = TRUE , mu = 10^-5 , gens = 100000 , suppress.output = FALSE , suppress.plot = TRUE , reps = 500 )
=======
matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 ) , #
		xaxt = "n"#
	)#
	axis ( 1 , )#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}
MakeHapPlots ( temp$standing.hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.04, sim.distance = 0.05 , interval.width = 10000)
matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 ) , #
		xaxt = "n"#
	)
intervals
intervals/1000
tail ( intervals )
tail ( intervals , 1 )
tail ( intervals , 1 ) / 1000
seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )
tail ( intervals , 1 ) / 1000
tail ( intervals , 1 ) , by = 1000000 )
tail ( intervals , 1 )
seq ( 0 , tail ( intervals , 1 ) , by = 1000000 )
seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )
axis ( 1 , seq ( 0 , tail ( intervals , 1 ) , by = 1000000 ) , seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )  )
axis ( 1 , seq ( 0 , tail ( intervals , 1 ) , by = 1000 ) , seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )  )
axis ( 1 , seq ( 0 , tail ( intervals/1000 , 1 ) , by = 1000 ) , seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )  )
ewens.dist.matrix
10e6
10e6/100000
10e6/interval.width
seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )
axis ( 1 , seq ( 1 , ncol ( ewens.dist.matrix ) , by = 10e6/interval.width ) , seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )  )
seq ( 1 , ncol ( ewens.dist.matrix ) , by = 10e6/interval.width )
10e6/interval.width
seq ( 1 , ncol ( ewens.dist.matrix ) , by = 10e5/interval.width )
axis ( 1 , seq ( 1 , ncol ( ewens.dist.matrix ) , by = 10e5/interval.width ) , seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )  )
matplot ( #
		t ( ewens.dist.matrix ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n" ,#
		ylim = c ( 0 , 1 ) , #
		xaxt = "n"#
	)#
	axis ( 1 , seq ( 1 , ncol ( ewens.dist.matrix ) , by = 10e5/interval.width ) , seq ( 0 , tail ( intervals , 1 ) / 1000 , by = 1000 )  )
col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	#legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}
if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}
Q
>>>>>>> ee36faaf11c8e4cf6c6ceb1f7cb958b3bb08e5a0
real.fs <- c ( 1 / 20000 , 0.001 , 0.01 , 0.05 , 0.1 )
real.fs
real.fs <- c ( 1 / 20000 , 0.001 , 0.01 , 0.05 , 0.1 )
my.runs <- lapply ( real.fs , function ( x ) SweepFromStandingSim ( N = 10000 , s = 0.05 , f = x , reps = 1000 , no.sweep = FALSE , cond.on.loss = TRUE , cond.on.fix = TRUE , time.factor = 1 , display.rep.count = T ) )#
many.sim.freqs <- list ( my.runs , real.fs )#
save ( many.sim.freqs  ,  file = "~/Documents/Academics/StandingSweeps/Sims/freqs.traj.s05.Rdata"  )#
for ( i in 1 : length ( real.fs ) ) {#
	run.ms.f ( runs = my.runs [[ i ]] [[ 1 ]] , n.sam = 2 , f = real.fs [ i ] , s = 0.05 , N = 10000 , path = "~/Documents/Academics/StandingSweeps/" )#
}
source('~/Documents/Academics/StandingSweeps/Scripts/SweepFromStandingSim.R', chdir = TRUE)#
source ( "~/Documents/Academics/StandingSweeps/Scripts/run.ms.functions.R")
source('~/Documents/Academics/CoopLab/Projects/StandingSweeps/Scripts/SweepFromStandingSim.R', chdir = TRUE)#
source ( "~/Documents/Academics/CoopLab/Projects/StandingSweeps/Scripts/run.ms.functions.R")#
#source('~/Documents/Academics/StandingSweeps/Scripts/SweepFromStandingSim.R', chdir = TRUE)#
#source ( "~/Documents/Academics/StandingSweeps/Scripts/run.ms.functions.R")#
real.fs <- c ( 1 / 20000 , 0.001 , 0.01 , 0.05 , 0.1 )#
my.runs <- lapply ( real.fs , function ( x ) SweepFromStandingSim ( N = 10000 , s = 0.05 , f = x , reps = 1000 , no.sweep = FALSE , cond.on.loss = TRUE , cond.on.fix = TRUE , time.factor = 1 , display.rep.count = T ) )#
many.sim.freqs <- list ( my.runs , real.fs )#
save ( many.sim.freqs  ,  file = "~/Documents/Academics/StandingSweeps/Sims/freqs.traj.s05.Rdata"  )#
for ( i in 1 : length ( real.fs ) ) {#
	run.ms.f ( runs = my.runs [[ i ]] [[ 1 ]] , n.sam = 2 , f = real.fs [ i ] , s = 0.05 , N = 10000 , path = "~/Documents/Academics/StandingSweeps/" )#
}
source('~/Documents/Academics/CoopLab/Projects/StandingSweeps/Scripts/SweepFromStandingSim.R', chdir = TRUE)#
source ( "~/Documents/Academics/CoopLab/Projects/StandingSweeps/Scripts/run.ms.functions.R")
source('~/Documents/Academics/StandingSweeps/Scripts/SweepFromStandingSim.R', chdir = TRUE)
library ( randtoolbox)
library ( "randtoolbox")
expected.freq.times.standing.w.sweep<-function(nsam,N,r,distance,f){#
	recover()#
	#my.StirlingNumbers<-StirlingNumbers(n) #
	ESF.prob.k<-EwensDist( n=nsam , N =N, r=r , distance=1 , f=f) # ,stirling.numbers=my.StirlingNumbers)    ### is of form [n,k]#
	ESF.condprob.k<-EwensCondDist( n=nsam , N =N, r=r , distance=1 , f=f) # ,stirling.numbers=my.StirlingNumbers)    ### is of form [n,k]#
	my.StirlingNumbers<-StirlingNumbers(nsam)    ##Usigned Stirling numbers of 1st kind. ma#
	expected.t.l<-rep(NA,nsam-1)#
	p_l_given_k <- array ( 0 , dim = c ( nsam , nsam , nsam , nsam ) )#
	freq.specs <- matrix ( 0 , nrow = nsam , ncol = nsam )#
	for ( i in 2 : nsam ) {		#
		freq.specs [ 1 : ( i - 1 ) , i ] <- ( 1 / ( 1 : ( i - 1 ) ) ) / ( sum ( 1 / ( 1 : ( i - 1  )  ) ) )#
	}#
	freq.specs <- t ( freq.specs )#
	terms.in.sum <- array ( 0 , dim = c ( nsam , nsam , nsam , nsam ) )#
	H <- array ( 0 , dim = c ( nsam , nsam , nsam , nsam ) )#
	jg.tracker <- array ( NA , dim = c ( nsam , nsam , nsam , nsam , nsam ) )#
	kg.tracker <- array ( NA , dim = c ( nsam , nsam , nsam , nsam , nsam ) ) #
	for(l in 1:(nsam-1)){	#
	#	recover()#
	#	terms.in.sum<-rep(0,nsam)#
		for ( i in 0 : nsam ) {	#
			for(k in 1 : i ) {#
				terms.given.j <- matrix ( 0 , ncol = nsam , nrow = nsam )#
				for(j in 1:(k + nsam - i  - 1 )){#
					for ( g in max ( 0 , ( j - k ) ) : min ( l , nsam - i , j ) ) {#
						if ( FALSE ) {#
						if ( k == 1 ) {#
							if ( nsam - i == l ) 					p_l_given_k [ k , j , l ] <- 1#
							if ( l - g  == 0 & j - g == 0 ) 	p_l_given_k [ k , j , l ] <- 1#
						} else if ( k > 1) {#
						#	if ( k - ( j - g ) < 0 ) next#
							if ( nsam - i - ( l - g ) < 0 ) next#
							stirling.bit <- my.StirlingNumbers[ l - g , j - g ] * my.StirlingNumbers[nsam - i - ( l - g ) , k - ( j - g ) ]  / my.StirlingNumbers[ nsam - i ,k - g ]#
							p_l_given_k [ g , j , k , l ] <- stirling.bit * choose ( nsam - i , l - g ) / choose ( k - g , j - g )#
						}#
						#if(!is.finite(p_l_given_k [ l , k , j ])){ stop ("is infinite") }  ##cat("problem",l,k,j," "); ##is this right?#
						H [ g , j , k , nsam - i ] <- choose ( j , g ) / choose ( k + nsam - i , j )#
						terms.given.j [ j , k ] <- p_l_given_k [ k , j , l ]*freq.specs[ k + nsam - i  , j ] * H [ g , j , k , nsam - i ]#
					#	terms.in.sum[k]<-terms.in.sum[k]+ESF.prob.k[nsam,k] *p_l_given_k [ l , k , j ]*freq.specs[k,j]#
						terms.in.sum [ k , j, l , i  ] <- ESF.prob.k [ nsam , k ] * p_l_given_k [ k , j , l ] * freq.specs [ k , j ]			#
						stopifnot( H <= 1 , H >= 0 )#
						}#
						jg.tracker [ k , j , g , i ,  l ]	 <- j - g#
						kg.tracker [ k , j , g , i , l ]	 <- k - ( j - g )#
					}#
				}		#
			}#
		}#
	#	expected.t.l[l]<-sum(terms.in.sum)#
	}#
	return(terms.in.sum)#
}#
#
expected.freq.times.standing.w.sweep ( nsam = 10 , N = 10000 , r = 0.5 , f = 0.05 )
as.c
setwd ( "~/Documents/Academics/StandingSweeps/" )#
source('~/Documents/Academics/StandingSweeps/Scripts/SweepFromStandingSim.R', chdir = TRUE)#
source('~/Documents/Academics/StandingSweeps/Scripts/run.ms.functions.R', chdir = TRUE)#
options ( scipen = 400)
my.N <- 10000#
my.rs <- c ( 0.0001 , 0.001 , 0.01 , 0.05 , 0.1 , 0.5 ) #
my.fs <- c ( 1/(2*my.N) , 0.001 , 0.01 , 0.025 , 0.05 , 0.075 , 0.1 )#
my.s <- my.fs
as.c ( my.rs [ 1 ] )
r=my.rs [ 1 ]
r
as.c ( r )
strsplit ( as.c ( r ) , "." )
strsplit ( as.c ( r ) , "" )
strsplit ( as.c ( r ) , "." )
as.c ( r )
strsplit ( as.c ( r ) , "/." )
strsplit ( as.c ( r ) , "\\." )
strsplit ( as.c ( r ) , "\\." ) [ 2 ]
as.c ( r )
strsplit ( as.c ( r ) , "\\." )
strsplit ( as.c ( r ) , "\\." ) [[ 1 ]] [ 2 ]
paste ( "Sims/freq.spec" , strsplit ( as.c ( r ) , "\\." ) [[ 1 ]] [ 2 ] , ".05.05.10000.nosweep.n12.Robj" )
paste ( "Sims/freq.spec" , strsplit ( as.c ( r ) , "\\." ) [[ 1 ]] [ 2 ] , ".05.05.10000.nosweep.n12.Robj" , sep = "" )
paste ( "Sims/freq.spec." , strsplit ( as.c ( r ) , "\\." ) [[ 1 ]] [ 2 ] , ".05.05.10000.nosweep.n12.Robj" , sep = "" )
r
f
f=0.01
paste ( "Sims/freq.spec." , strsplit ( as.c ( r ) , "\\." ) [[ 1 ]] [ 2 ] ,  strsplit ( as.c ( f ) , "\\." ) [[ 1 ]] [ 2 ] ,  ".10000.nosweep.n12.Robj" , sep = "" )
paste ( "Sims/freq.spec." , strsplit ( as.c ( r ) , "\\." ) [[ 1 ]] [ 2 ] , "." ,  strsplit ( as.c ( f ) , "\\." ) [[ 1 ]] [ 2 ] ,  ".10000.nosweep.n12.Robj" , sep = "" )
paste ( "Sims/freq.spec." , strsplit ( as.c ( r ) , "\\." ) [[ 1 ]] [ 2 ] , "." ,  strsplit ( as.c ( f ) , "\\." ) [[ 1 ]] [ 2 ] ,  "." , my.N , ".nosweep.n12.Robj" , sep = "" )
paste ( "Sims/freq.spec." , strsplit ( as.c ( r ) , "\\." ) [[ 1 ]] [ 2 ] , "." ,  strsplit ( as.c ( f ) , "\\." ) [[ 1 ]] [ 2 ] ,  "." , my.N , ".nosweep.n" , 12 , ".Robj" , sep = "" )
r
message ( r)
message ( r )#
		message ( f )
