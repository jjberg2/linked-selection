margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)
plot ( NA , xlim = c ( 0,0.05),ylim = c ( 0, 0.05),type ="n",bty="n")
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)
s <- c ( 1/20000 , 0.001 , 0.01 , 0.05 )
s
fands <- expand.grid ( fs , ss )
fands
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 1/20000 , 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )
fands
fs
fands <- expand.grid ( fs , ss ,KEEP.OUT.ATTRS = FALSE)
fands
fands <- expand.grid ( fs , ss )
colnames ( fands )
colnames ( fands ) <- c ( "f" , "s")
fands
temp <- lapply ( fs , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )
colnames ( fands ) <- c ( "f" , "s")
install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , time.factor = 1 ) {#
	options ( error = NULL )#
	recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- rep ( temp[[2]] , nrow ( frequencies ) )#
			sweep.start.forward <- ncol ( frequencies ) - sweep.start[1] #
			# if ( nrow ( frequencies ) > 1 ) {#
			fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			entry <- numeric()#
			for ( i in 1 : length ( zeros ) ){#
				if ( length ( zeros [[ i ]] ) != 0 ) {#
					entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				} else {#
					entry [ i ] <- 1#
				}#
			}#
			transit.time <- fixation.time - entry#
			new.freqs <- matrix ( 0 , nrow = reps , ncol = max ( transit.time + 1 ) )#
			for ( i in 1 : nrow ( frequencies ) ) {#
				new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			}#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f , fixation.time = fixation.time )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , fixation.time = fixation.time , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			 cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
if(turn.on.recovers)	recover()#
	# if ( constant.freq == FALSE ) {#
		# # if ( reps == 1 ) {#
			# # freq.trajectories <- c ( neutral.freq.matrix [ length ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ 1 : length ( sweep.freq.matrix ) ] )#
			# # #plot ( freq.trajectories , type = "l" )#
			# # freq.trajectories <- matrix ( freq.trajectories , nrow = 1 )#
			# # if ( freq.trajectories [ , ncol ( freq.trajectories ) ] == 1 ) {#
				# # conditional.freq.trajectories <- freq.trajectories#
				# # #generations <- seq ( 1 , ncol ( conditional.freq.trajectories ) , time.factor )#
				# # #conditional.freq.trajectories <- conditional.freq.trajectories [ , generations ]#
			# # } else {#
				# # cat ( "Allele lost from population.\n")#
				# # return ( )#
			# # }#
		# # } else {#
	if ( no.sweep == FALSE ) {#
		freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	freq.trajectories <- do.call ( rbind , temp2 )#
		# }#
	# } else {#
		# freq.trajectories <- sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ]#
	# }#
	#recover()#
	#keep.these <- freq.trajectories [ , ncol ( freq.trajectories ) ] == 1		#
	#conditional.freq.trajectories <- freq.trajectories [ keep.these , ]#
	sweep.start <- ncol ( sweep.freq.matrix ) #/ time.factor#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
# BuildTrees <- function ( coal.times , n.tips ){#
	# #recover()#
	# library(ape)#
	# trees <- list ( )#
	# for ( j in 1 : nrow ( coal.times ) ) {#
		# edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		# edge.length <- numeric ( 2 * n.tips - 2 )#
		# edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		# nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		# node.depth <- numeric ( 2 * n.tips - 1 )#
		# Nnode <- n.tips - 1#
		# tip.label <- character ( n.tips )#
		# for ( l in 1 : length ( tip.label ) ){#
			# tip.label [ l ] <- paste ( "t" , l , sep = "")#
		# }#
		# k = 1#
		# for ( i in nodes ) {#
			# extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			# coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			# coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			# edge [ coal.index , 1 ] <- i#
			# if ( i != tail ( nodes , 1 ) ) {#
				# edge [ i - 1 , 2 ] <- i#
			# }#
			# node.depth [ i ] <- coal.times [ j , k ] #
			# edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			# k = k + 1#
		# }#
		# a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		# class ( a.tree ) <- "phylo"#
		# my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		# trees [[ j ]] <- my.tree#
	# }#
	# ## note; the frequency path gets added on as trees [[ j ]] [[ 3 ]] in the top level function call immediately after returning from this function; bad writing that I should fix some day.#
	# return ( trees )#
# }#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.right.off.background$sequence.location < k ) )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.left.off.background$sequence.location < k ) )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	# cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )#
# #	par ( mfrow = c ( 2 , 1 ) )#
	# #matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	# ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
	# stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f , stirling.numbers = stirling.numbers )#
		# }#
	# }#
	# #recover()#
	# ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )#
	# matplot ( #
		# t ( ewens.cum.probs ) , #
		# type = "n" , #
		# lty = 1 , #
		# lwd = 0.7 , #
		# col = "black" , #
		# ylab = "Cumulative Probability" , #
		# xlab = "kb" , #
		# #main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		# bty = "n"#
	# )#
	# #recover()#
	# col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	# for ( i in 1 : ( nrow ( cum.probs ) - 1 ) ) {#
			# #i = i + 1#
			# X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
			# Y.ax1 <- cum.probs [ i , X.ax ]#
			# Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			# polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	# }#
	# ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
	# apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	# #recover()#
	# expected.num.haps <- colSums ( apply ( hap.counts.by.interval , 2 , function ( x ) x * 1 : n.tips ) / (2 * length ( input ) ) , 2 )#
	# #plot ( expected.num.haps , type = "l" , lty = 1 , lwd = 1.5 , xlab = "kb" , ylab = "Expected Number of Haplotypes" , bty = "n")#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- nrow ( hap.count.freqs.by.interval )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		}#
	}#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n"#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 1/20000 , 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- lapply ( fs , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
# # #
# # Let's think about inference w/ genealogies#
#
coal.times <- lapply ( 1 : length ( fs ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
log.likes <- lapply ( 1:nrow(coal.times [[ 1 ]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times [[ 1 ]] [ y , ] , x , 20000 ) ) )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
temp <- lapply ( fs , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )
s
f
c
f
x
Q
fands
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )
s
f
Q
install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , time.factor = 1 ) {#
	options ( error = NULL )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- rep ( temp[[2]] , nrow ( frequencies ) )#
			sweep.start.forward <- ncol ( frequencies ) - sweep.start[1] #
			# if ( nrow ( frequencies ) > 1 ) {#
			fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			entry <- numeric()#
			for ( i in 1 : length ( zeros ) ){#
				if ( length ( zeros [[ i ]] ) != 0 ) {#
					entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				} else {#
					entry [ i ] <- 1#
				}#
			}#
			transit.time <- fixation.time - entry#
			new.freqs <- matrix ( 0 , nrow = reps , ncol = max ( transit.time + 1 ) )#
			for ( i in 1 : nrow ( frequencies ) ) {#
				new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			}#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f , fixation.time = fixation.time )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , fixation.time = fixation.time , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			 cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
if(turn.on.recovers)	recover()#
	# if ( constant.freq == FALSE ) {#
		# # if ( reps == 1 ) {#
			# # freq.trajectories <- c ( neutral.freq.matrix [ length ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ 1 : length ( sweep.freq.matrix ) ] )#
			# # #plot ( freq.trajectories , type = "l" )#
			# # freq.trajectories <- matrix ( freq.trajectories , nrow = 1 )#
			# # if ( freq.trajectories [ , ncol ( freq.trajectories ) ] == 1 ) {#
				# # conditional.freq.trajectories <- freq.trajectories#
				# # #generations <- seq ( 1 , ncol ( conditional.freq.trajectories ) , time.factor )#
				# # #conditional.freq.trajectories <- conditional.freq.trajectories [ , generations ]#
			# # } else {#
				# # cat ( "Allele lost from population.\n")#
				# # return ( )#
			# # }#
		# # } else {#
	if ( no.sweep == FALSE ) {#
		freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	freq.trajectories <- do.call ( rbind , temp2 )#
		# }#
	# } else {#
		# freq.trajectories <- sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ]#
	# }#
	#recover()#
	#keep.these <- freq.trajectories [ , ncol ( freq.trajectories ) ] == 1		#
	#conditional.freq.trajectories <- freq.trajectories [ keep.these , ]#
	sweep.start <- ncol ( sweep.freq.matrix ) #/ time.factor#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
# BuildTrees <- function ( coal.times , n.tips ){#
	# #recover()#
	# library(ape)#
	# trees <- list ( )#
	# for ( j in 1 : nrow ( coal.times ) ) {#
		# edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		# edge.length <- numeric ( 2 * n.tips - 2 )#
		# edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		# nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		# node.depth <- numeric ( 2 * n.tips - 1 )#
		# Nnode <- n.tips - 1#
		# tip.label <- character ( n.tips )#
		# for ( l in 1 : length ( tip.label ) ){#
			# tip.label [ l ] <- paste ( "t" , l , sep = "")#
		# }#
		# k = 1#
		# for ( i in nodes ) {#
			# extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			# coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			# coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			# edge [ coal.index , 1 ] <- i#
			# if ( i != tail ( nodes , 1 ) ) {#
				# edge [ i - 1 , 2 ] <- i#
			# }#
			# node.depth [ i ] <- coal.times [ j , k ] #
			# edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			# k = k + 1#
		# }#
		# a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		# class ( a.tree ) <- "phylo"#
		# my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		# trees [[ j ]] <- my.tree#
	# }#
	# ## note; the frequency path gets added on as trees [[ j ]] [[ 3 ]] in the top level function call immediately after returning from this function; bad writing that I should fix some day.#
	# return ( trees )#
# }#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.right.off.background$sequence.location < k ) )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.left.off.background$sequence.location < k ) )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	# cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )#
# #	par ( mfrow = c ( 2 , 1 ) )#
	# #matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	# ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
	# stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f , stirling.numbers = stirling.numbers )#
		# }#
	# }#
	# #recover()#
	# ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )#
	# matplot ( #
		# t ( ewens.cum.probs ) , #
		# type = "n" , #
		# lty = 1 , #
		# lwd = 0.7 , #
		# col = "black" , #
		# ylab = "Cumulative Probability" , #
		# xlab = "kb" , #
		# #main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		# bty = "n"#
	# )#
	# #recover()#
	# col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	# for ( i in 1 : ( nrow ( cum.probs ) - 1 ) ) {#
			# #i = i + 1#
			# X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
			# Y.ax1 <- cum.probs [ i , X.ax ]#
			# Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			# polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	# }#
	# ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
	# apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	# #recover()#
	# expected.num.haps <- colSums ( apply ( hap.counts.by.interval , 2 , function ( x ) x * 1 : n.tips ) / (2 * length ( input ) ) , 2 )#
	# #plot ( expected.num.haps , type = "l" , lty = 1 , lwd = 1.5 , xlab = "kb" , ylab = "Expected Number of Haplotypes" , bty = "n")#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- nrow ( hap.count.freqs.by.interval )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		}#
	}#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n"#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 1/20000 , 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
# # #
# # Let's think about inference w/ genealogies#
#
coal.times <- lapply ( 1 : length ( fs ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
log.likes <- lapply ( 1:nrow(coal.times [[ 1 ]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times [[ 1 ]] [ y , ] , x , 20000 ) ) )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )
install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , time.factor = 1 ) {#
	options ( error = NULL )#
	recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- rep ( temp[[2]] , nrow ( frequencies ) )#
			sweep.start.forward <- ncol ( frequencies ) - sweep.start[1] #
			# if ( nrow ( frequencies ) > 1 ) {#
			fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			entry <- numeric()#
			for ( i in 1 : length ( zeros ) ){#
				if ( length ( zeros [[ i ]] ) != 0 ) {#
					entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				} else {#
					entry [ i ] <- 1#
				}#
			}#
			transit.time <- fixation.time - entry#
			new.freqs <- matrix ( 0 , nrow = reps , ncol = max ( transit.time + 1 ) )#
			for ( i in 1 : nrow ( frequencies ) ) {#
				new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			}#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f , fixation.time = fixation.time )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , fixation.time = fixation.time , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			 cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
if(turn.on.recovers)	recover()#
	# if ( constant.freq == FALSE ) {#
		# # if ( reps == 1 ) {#
			# # freq.trajectories <- c ( neutral.freq.matrix [ length ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ 1 : length ( sweep.freq.matrix ) ] )#
			# # #plot ( freq.trajectories , type = "l" )#
			# # freq.trajectories <- matrix ( freq.trajectories , nrow = 1 )#
			# # if ( freq.trajectories [ , ncol ( freq.trajectories ) ] == 1 ) {#
				# # conditional.freq.trajectories <- freq.trajectories#
				# # #generations <- seq ( 1 , ncol ( conditional.freq.trajectories ) , time.factor )#
				# # #conditional.freq.trajectories <- conditional.freq.trajectories [ , generations ]#
			# # } else {#
				# # cat ( "Allele lost from population.\n")#
				# # return ( )#
			# # }#
		# # } else {#
	if ( no.sweep == FALSE ) {#
		freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	freq.trajectories <- do.call ( rbind , temp2 )#
		# }#
	# } else {#
		# freq.trajectories <- sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ]#
	# }#
	#recover()#
	#keep.these <- freq.trajectories [ , ncol ( freq.trajectories ) ] == 1		#
	#conditional.freq.trajectories <- freq.trajectories [ keep.these , ]#
	sweep.start <- ncol ( sweep.freq.matrix ) #/ time.factor#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
# BuildTrees <- function ( coal.times , n.tips ){#
	# #recover()#
	# library(ape)#
	# trees <- list ( )#
	# for ( j in 1 : nrow ( coal.times ) ) {#
		# edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		# edge.length <- numeric ( 2 * n.tips - 2 )#
		# edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		# nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		# node.depth <- numeric ( 2 * n.tips - 1 )#
		# Nnode <- n.tips - 1#
		# tip.label <- character ( n.tips )#
		# for ( l in 1 : length ( tip.label ) ){#
			# tip.label [ l ] <- paste ( "t" , l , sep = "")#
		# }#
		# k = 1#
		# for ( i in nodes ) {#
			# extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			# coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			# coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			# edge [ coal.index , 1 ] <- i#
			# if ( i != tail ( nodes , 1 ) ) {#
				# edge [ i - 1 , 2 ] <- i#
			# }#
			# node.depth [ i ] <- coal.times [ j , k ] #
			# edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			# k = k + 1#
		# }#
		# a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		# class ( a.tree ) <- "phylo"#
		# my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		# trees [[ j ]] <- my.tree#
	# }#
	# ## note; the frequency path gets added on as trees [[ j ]] [[ 3 ]] in the top level function call immediately after returning from this function; bad writing that I should fix some day.#
	# return ( trees )#
# }#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.right.off.background$sequence.location < k ) )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.left.off.background$sequence.location < k ) )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	# cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )#
# #	par ( mfrow = c ( 2 , 1 ) )#
	# #matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	# ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
	# stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f , stirling.numbers = stirling.numbers )#
		# }#
	# }#
	# #recover()#
	# ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )#
	# matplot ( #
		# t ( ewens.cum.probs ) , #
		# type = "n" , #
		# lty = 1 , #
		# lwd = 0.7 , #
		# col = "black" , #
		# ylab = "Cumulative Probability" , #
		# xlab = "kb" , #
		# #main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		# bty = "n"#
	# )#
	# #recover()#
	# col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	# for ( i in 1 : ( nrow ( cum.probs ) - 1 ) ) {#
			# #i = i + 1#
			# X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
			# Y.ax1 <- cum.probs [ i , X.ax ]#
			# Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			# polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	# }#
	# ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
	# apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	# #recover()#
	# expected.num.haps <- colSums ( apply ( hap.counts.by.interval , 2 , function ( x ) x * 1 : n.tips ) / (2 * length ( input ) ) , 2 )#
	# #plot ( expected.num.haps , type = "l" , lty = 1 , lwd = 1.5 , xlab = "kb" , ylab = "Expected Number of Haplotypes" , bty = "n")#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- nrow ( hap.count.freqs.by.interval )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		}#
	}#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n"#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 1/20000 , 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
# # #
# # Let's think about inference w/ genealogies#
#
coal.times <- lapply ( 1 : length ( fs ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
log.likes <- lapply ( 1:nrow(coal.times [[ 1 ]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times [[ 1 ]] [ y , ] , x , 20000 ) ) )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )
temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix )
Q
install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , time.factor = 1 ) {#
	options ( error = NULL )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- rep ( temp[[2]] , nrow ( frequencies ) )#
			sweep.start.forward <- ncol ( frequencies ) - sweep.start[1] #
			# if ( nrow ( frequencies ) > 1 ) {#
			fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			entry <- numeric()#
			for ( i in 1 : length ( zeros ) ){#
				if ( length ( zeros [[ i ]] ) != 0 ) {#
					entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				} else {#
					entry [ i ] <- 1#
				}#
			}#
			transit.time <- fixation.time - entry#
			new.freqs <- matrix ( 0 , nrow = reps , ncol = max ( transit.time + 1 ) )#
			for ( i in 1 : nrow ( frequencies ) ) {#
				new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			}#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f , fixation.time = fixation.time )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , fixation.time = fixation.time , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			 cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
if(turn.on.recovers)	recover()#
	# if ( constant.freq == FALSE ) {#
		# # if ( reps == 1 ) {#
			# # freq.trajectories <- c ( neutral.freq.matrix [ length ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ 1 : length ( sweep.freq.matrix ) ] )#
			# # #plot ( freq.trajectories , type = "l" )#
			# # freq.trajectories <- matrix ( freq.trajectories , nrow = 1 )#
			# # if ( freq.trajectories [ , ncol ( freq.trajectories ) ] == 1 ) {#
				# # conditional.freq.trajectories <- freq.trajectories#
				# # #generations <- seq ( 1 , ncol ( conditional.freq.trajectories ) , time.factor )#
				# # #conditional.freq.trajectories <- conditional.freq.trajectories [ , generations ]#
			# # } else {#
				# # cat ( "Allele lost from population.\n")#
				# # return ( )#
			# # }#
		# # } else {#
	if ( no.sweep == FALSE ) {#
		freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	freq.trajectories <- do.call ( rbind , temp2 )#
		# }#
	# } else {#
		# freq.trajectories <- sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ]#
	# }#
	#recover()#
	#keep.these <- freq.trajectories [ , ncol ( freq.trajectories ) ] == 1		#
	#conditional.freq.trajectories <- freq.trajectories [ keep.these , ]#
	sweep.start <- ncol ( sweep.freq.matrix ) #/ time.factor#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
# BuildTrees <- function ( coal.times , n.tips ){#
	# #recover()#
	# library(ape)#
	# trees <- list ( )#
	# for ( j in 1 : nrow ( coal.times ) ) {#
		# edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		# edge.length <- numeric ( 2 * n.tips - 2 )#
		# edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		# nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		# node.depth <- numeric ( 2 * n.tips - 1 )#
		# Nnode <- n.tips - 1#
		# tip.label <- character ( n.tips )#
		# for ( l in 1 : length ( tip.label ) ){#
			# tip.label [ l ] <- paste ( "t" , l , sep = "")#
		# }#
		# k = 1#
		# for ( i in nodes ) {#
			# extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			# coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			# coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			# edge [ coal.index , 1 ] <- i#
			# if ( i != tail ( nodes , 1 ) ) {#
				# edge [ i - 1 , 2 ] <- i#
			# }#
			# node.depth [ i ] <- coal.times [ j , k ] #
			# edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			# k = k + 1#
		# }#
		# a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		# class ( a.tree ) <- "phylo"#
		# my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		# trees [[ j ]] <- my.tree#
	# }#
	# ## note; the frequency path gets added on as trees [[ j ]] [[ 3 ]] in the top level function call immediately after returning from this function; bad writing that I should fix some day.#
	# return ( trees )#
# }#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.right.off.background$sequence.location < k ) )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.left.off.background$sequence.location < k ) )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	# cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )#
# #	par ( mfrow = c ( 2 , 1 ) )#
	# #matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	# ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
	# stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f , stirling.numbers = stirling.numbers )#
		# }#
	# }#
	# #recover()#
	# ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )#
	# matplot ( #
		# t ( ewens.cum.probs ) , #
		# type = "n" , #
		# lty = 1 , #
		# lwd = 0.7 , #
		# col = "black" , #
		# ylab = "Cumulative Probability" , #
		# xlab = "kb" , #
		# #main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		# bty = "n"#
	# )#
	# #recover()#
	# col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	# for ( i in 1 : ( nrow ( cum.probs ) - 1 ) ) {#
			# #i = i + 1#
			# X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
			# Y.ax1 <- cum.probs [ i , X.ax ]#
			# Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			# polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	# }#
	# ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
	# apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	# #recover()#
	# expected.num.haps <- colSums ( apply ( hap.counts.by.interval , 2 , function ( x ) x * 1 : n.tips ) / (2 * length ( input ) ) , 2 )#
	# #plot ( expected.num.haps , type = "l" , lty = 1 , lwd = 1.5 , xlab = "kb" , ylab = "Expected Number of Haplotypes" , bty = "n")#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- nrow ( hap.count.freqs.by.interval )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		}#
	}#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n"#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 1/20000 , 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
# # #
# # Let's think about inference w/ genealogies#
#
coal.times <- lapply ( 1 : length ( fs ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
log.likes <- lapply ( 1:nrow(coal.times [[ 1 ]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times [[ 1 ]] [ y , ] , x , 20000 ) ) )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )
i = 1
not.all.sweeps.fixed
update <- rep ( 0 , reps )
sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0
sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0
mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)
mu.S
s
2 * N * s
2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )
sel <- mu.S * delta.T
sel
update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )
update
sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update
sweep.freq.matrix
sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )
sweep.fixed.one
sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1
sweep.freq.matrix
sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )
sweep.fixed.zero
sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )
sweep.freq.matrix
not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )
not.all.sweeps.fixed
update <- rep ( 0 , reps )
neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0
neutral.not.fixed
neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0
neutral.fixed
neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )
cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,
- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,
0)
cond.mean
drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )
drift.neutral
update [ neutral.not.fixed ] <- drift.neutral
update
neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update
neutral.freq.matrix
neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )
neutral.fixed.one
neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1
neutral.freq.matrix
neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )
neutral.fixed.zero
neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0
neutral.freq.matrix
not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )
not.all.neutral.fixed
neutral.freq.matrix
if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1
if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1
if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1
if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1
if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1
if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1
if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1
if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1
if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1
if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1
if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1
if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1
not.all.neutral.fixed
neutral.freq.matrix
Q
options ( error = recover)
install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , time.factor = 1 ) {#
	options ( error = NULL )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- rep ( temp[[2]] , nrow ( frequencies ) )#
			sweep.start.forward <- ncol ( frequencies ) - sweep.start[1] #
			# if ( nrow ( frequencies ) > 1 ) {#
			fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			entry <- numeric()#
			for ( i in 1 : length ( zeros ) ){#
				if ( length ( zeros [[ i ]] ) != 0 ) {#
					entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				} else {#
					entry [ i ] <- 1#
				}#
			}#
			transit.time <- fixation.time - entry#
			new.freqs <- matrix ( 0 , nrow = reps , ncol = max ( transit.time + 1 ) )#
			for ( i in 1 : nrow ( frequencies ) ) {#
				new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			}#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f , fixation.time = fixation.time )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , fixation.time = fixation.time , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
if(turn.on.recovers)	recover()#
	# if ( constant.freq == FALSE ) {#
		# # if ( reps == 1 ) {#
			# # freq.trajectories <- c ( neutral.freq.matrix [ length ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ 1 : length ( sweep.freq.matrix ) ] )#
			# # #plot ( freq.trajectories , type = "l" )#
			# # freq.trajectories <- matrix ( freq.trajectories , nrow = 1 )#
			# # if ( freq.trajectories [ , ncol ( freq.trajectories ) ] == 1 ) {#
				# # conditional.freq.trajectories <- freq.trajectories#
				# # #generations <- seq ( 1 , ncol ( conditional.freq.trajectories ) , time.factor )#
				# # #conditional.freq.trajectories <- conditional.freq.trajectories [ , generations ]#
			# # } else {#
				# # cat ( "Allele lost from population.\n")#
				# # return ( )#
			# # }#
		# # } else {#
	if ( no.sweep == FALSE ) {#
		freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	freq.trajectories <- do.call ( rbind , temp2 )#
		# }#
	# } else {#
		# freq.trajectories <- sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ]#
	# }#
	#recover()#
	#keep.these <- freq.trajectories [ , ncol ( freq.trajectories ) ] == 1		#
	#conditional.freq.trajectories <- freq.trajectories [ keep.these , ]#
	sweep.start <- ncol ( sweep.freq.matrix ) #/ time.factor#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
# BuildTrees <- function ( coal.times , n.tips ){#
	# #recover()#
	# library(ape)#
	# trees <- list ( )#
	# for ( j in 1 : nrow ( coal.times ) ) {#
		# edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		# edge.length <- numeric ( 2 * n.tips - 2 )#
		# edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		# nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		# node.depth <- numeric ( 2 * n.tips - 1 )#
		# Nnode <- n.tips - 1#
		# tip.label <- character ( n.tips )#
		# for ( l in 1 : length ( tip.label ) ){#
			# tip.label [ l ] <- paste ( "t" , l , sep = "")#
		# }#
		# k = 1#
		# for ( i in nodes ) {#
			# extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			# coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			# coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			# edge [ coal.index , 1 ] <- i#
			# if ( i != tail ( nodes , 1 ) ) {#
				# edge [ i - 1 , 2 ] <- i#
			# }#
			# node.depth [ i ] <- coal.times [ j , k ] #
			# edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			# k = k + 1#
		# }#
		# a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		# class ( a.tree ) <- "phylo"#
		# my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		# trees [[ j ]] <- my.tree#
	# }#
	# ## note; the frequency path gets added on as trees [[ j ]] [[ 3 ]] in the top level function call immediately after returning from this function; bad writing that I should fix some day.#
	# return ( trees )#
# }#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.right.off.background$sequence.location < k ) )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.left.off.background$sequence.location < k ) )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	# cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )#
# #	par ( mfrow = c ( 2 , 1 ) )#
	# #matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	# ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
	# stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f , stirling.numbers = stirling.numbers )#
		# }#
	# }#
	# #recover()#
	# ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )#
	# matplot ( #
		# t ( ewens.cum.probs ) , #
		# type = "n" , #
		# lty = 1 , #
		# lwd = 0.7 , #
		# col = "black" , #
		# ylab = "Cumulative Probability" , #
		# xlab = "kb" , #
		# #main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		# bty = "n"#
	# )#
	# #recover()#
	# col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	# for ( i in 1 : ( nrow ( cum.probs ) - 1 ) ) {#
			# #i = i + 1#
			# X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
			# Y.ax1 <- cum.probs [ i , X.ax ]#
			# Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			# polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	# }#
	# ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
	# apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	# #recover()#
	# expected.num.haps <- colSums ( apply ( hap.counts.by.interval , 2 , function ( x ) x * 1 : n.tips ) / (2 * length ( input ) ) , 2 )#
	# #plot ( expected.num.haps , type = "l" , lty = 1 , lwd = 1.5 , xlab = "kb" , ylab = "Expected Number of Haplotypes" , bty = "n")#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- nrow ( hap.count.freqs.by.interval )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		}#
	}#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n"#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 1/20000 , 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
# # #
# # Let's think about inference w/ genealogies#
#
coal.times <- lapply ( 1 : length ( fs ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
log.likes <- lapply ( 1:nrow(coal.times [[ 1 ]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times [[ 1 ]] [ y , ] , x , 20000 ) ) )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )
ss <- c ( 0.001 , 0.01 , 0.05 )
fands <- expand.grid ( fs , ss )
fands
colnames ( fands ) <- c ( "f" , "s")
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )
temp <- apply ( fs , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )
temp <- lapply ( fs , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )
300^2
log ( 20000*0.001)/0.001
log ( 20000*0.01)/0.01
(log ( 20000*0.01)/0.01)^2
(log ( 20000*0.01)/0.01)^2*10^-8
(log ( 200000*0.01)/0.01)^2*10^-8
(log ( 2000000*0.01)/0.01)^2*10^-8
(log ( 2000000*0.001)/0.001)^2*10^-8
(log ( 2000000*0.01)/0.01)^2*10^-8
(log ( 2000000*0.01)/0.01)^2
(log ( 2000000*0.01)/0.01)^2*10^-8
120000000/5
5/120000000
5/120000000/2
(log ( 2000000*0.01)/0.01)^2
(log ( 2000000*0.01)/0.01)^2*10^-8
(log ( 20000000*0.01)/0.01)^2*10^-8
(log ( 20000000*0.001)/0.001)^2*10^-8
(log ( 20000000*0.01)/0.01)^2*10^-8
(log ( 2000000*0.0001)/0.0001)^2*10^-8
(log ( 2000000*0.00001)/0.00001)^2*10^-8
1/((log ( 2000000*0.00001)/0.00001)^2*10^-8)
1/((log ( 2000000*0.000001)/0.000001)^2*10^-8)
2000000*0.000001
1/((log ( 2000000*0.00001)/0.00001)^2*10^-8)
1/((log ( 20000000*0.00001)/0.00001)^2*10^-8)
1/((log ( 20000000*0.000001)/0.00001)^2*10^-8)
1/((log ( 20000000*0.000001)/0.000001)^2*10^-8)
20000000*0.000001
1/((log ( 2000000*0.00001)/0.00001)^2*10^-8)
2000000*0.00001
10^-5
10^-4
0.00001
1/((log ( 20000000*0.00001)/0.00001)^2*10^-8)
1/((log ( 200000000*0.00001)/0.00001)^2*10^-8)
1/((log ( 200000*0.00001)/0.00001)^2*10^-8)
1/((log ( 2000000*0.00001)/0.00001)^2*10^-8)
1/((log ( 2000000*0.001)/0.001)^2*10^-8)
1/((log ( 2000000*0.0001)/0.0001)^2*10^-8)
1/((log ( 20000*0.001)/0.001)^2*10^-8)
1/((log ( 20000*0.0001)/0.0001)^2*10^-8)
rbinom ( 1 , 100 , 0.5)
rbinom ( 10000 , 100 , 0.5)
hist ( rbinom ( 10000 , 100 , 0.5) , breaks = 50 )
hist ( rbinom ( 10000 , 100 , 0.5) , breaks = 50 , xlim = c ( 0 , 1 ))
hist ( rbinom ( 10000 , 100 , 0.5) , breaks = 50)
hist ( rbinom ( 10000 , 100 , 0.5) , breaks = 50 , xlim = c ( 0 , 100 ))
hist ( rbinom ( 10000 , 100 , 0.5)/100 , breaks = 50 , xlim = c ( 0 , 1 ))
hist ( rbinom ( 10000 , 100 , 0.5) , breaks = 50 , xlim = c ( 0 , 100 ))
hist ( rbinom ( 10000 , 10 , 0.5) , breaks = 50 , xlim = c ( 0 , 10 ))
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )
ss <- c ( 0.001 , 0.01 , 0.05 )
fands <- expand.grid ( fs , ss )
fands
colnames ( fands ) <- c ( "f" , "s")
temp <- lapply ( fs , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = 0.01 , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )
coal.times <- lapply ( 1 : length ( fs ) , function ( x ) temp[[x]]$coal.times )
coal.times
coal.times <- lapply ( 1 : length ( fands ) , function ( x ) temp[[x]]$coal.times )
coal.times
fands
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )
coal.times
nrow ( fands )
names(temp)
names(temp[[1]])
length(temp)
fands
fands<-fands[1:2,]
fands
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )
install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , time.factor = 1 ) {#
	options ( error = recover )#
	recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- rep ( temp[[2]] , nrow ( frequencies ) )#
			sweep.start.forward <- ncol ( frequencies ) - sweep.start[1] #
			# if ( nrow ( frequencies ) > 1 ) {#
			fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			entry <- numeric()#
			for ( i in 1 : length ( zeros ) ){#
				if ( length ( zeros [[ i ]] ) != 0 ) {#
					entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				} else {#
					entry [ i ] <- 1#
				}#
			}#
			transit.time <- fixation.time - entry#
			new.freqs <- matrix ( 0 , nrow = reps , ncol = max ( transit.time + 1 ) )#
			for ( i in 1 : nrow ( frequencies ) ) {#
				new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			}#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f , fixation.time = fixation.time )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , fixation.time = fixation.time , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 ) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
if(turn.on.recovers)	recover()#
	# if ( constant.freq == FALSE ) {#
		# # if ( reps == 1 ) {#
			# # freq.trajectories <- c ( neutral.freq.matrix [ length ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ 1 : length ( sweep.freq.matrix ) ] )#
			# # #plot ( freq.trajectories , type = "l" )#
			# # freq.trajectories <- matrix ( freq.trajectories , nrow = 1 )#
			# # if ( freq.trajectories [ , ncol ( freq.trajectories ) ] == 1 ) {#
				# # conditional.freq.trajectories <- freq.trajectories#
				# # #generations <- seq ( 1 , ncol ( conditional.freq.trajectories ) , time.factor )#
				# # #conditional.freq.trajectories <- conditional.freq.trajectories [ , generations ]#
			# # } else {#
				# # cat ( "Allele lost from population.\n")#
				# # return ( )#
			# # }#
		# # } else {#
	if ( no.sweep == FALSE ) {#
		freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	freq.trajectories <- do.call ( rbind , temp2 )#
		# }#
	# } else {#
		# freq.trajectories <- sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ]#
	# }#
	#recover()#
	#keep.these <- freq.trajectories [ , ncol ( freq.trajectories ) ] == 1		#
	#conditional.freq.trajectories <- freq.trajectories [ keep.these , ]#
	sweep.start <- ncol ( sweep.freq.matrix ) #/ time.factor#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
# BuildTrees <- function ( coal.times , n.tips ){#
	# #recover()#
	# library(ape)#
	# trees <- list ( )#
	# for ( j in 1 : nrow ( coal.times ) ) {#
		# edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		# edge.length <- numeric ( 2 * n.tips - 2 )#
		# edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		# nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		# node.depth <- numeric ( 2 * n.tips - 1 )#
		# Nnode <- n.tips - 1#
		# tip.label <- character ( n.tips )#
		# for ( l in 1 : length ( tip.label ) ){#
			# tip.label [ l ] <- paste ( "t" , l , sep = "")#
		# }#
		# k = 1#
		# for ( i in nodes ) {#
			# extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			# coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			# coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			# edge [ coal.index , 1 ] <- i#
			# if ( i != tail ( nodes , 1 ) ) {#
				# edge [ i - 1 , 2 ] <- i#
			# }#
			# node.depth [ i ] <- coal.times [ j , k ] #
			# edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			# k = k + 1#
		# }#
		# a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		# class ( a.tree ) <- "phylo"#
		# my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		# trees [[ j ]] <- my.tree#
	# }#
	# ## note; the frequency path gets added on as trees [[ j ]] [[ 3 ]] in the top level function call immediately after returning from this function; bad writing that I should fix some day.#
	# return ( trees )#
# }#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.right.off.background$sequence.location < k ) )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.left.off.background$sequence.location < k ) )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	# cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )#
# #	par ( mfrow = c ( 2 , 1 ) )#
	# #matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	# ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
	# stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f , stirling.numbers = stirling.numbers )#
		# }#
	# }#
	# #recover()#
	# ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )#
	# matplot ( #
		# t ( ewens.cum.probs ) , #
		# type = "n" , #
		# lty = 1 , #
		# lwd = 0.7 , #
		# col = "black" , #
		# ylab = "Cumulative Probability" , #
		# xlab = "kb" , #
		# #main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		# bty = "n"#
	# )#
	# #recover()#
	# col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	# for ( i in 1 : ( nrow ( cum.probs ) - 1 ) ) {#
			# #i = i + 1#
			# X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
			# Y.ax1 <- cum.probs [ i , X.ax ]#
			# Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			# polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	# }#
	# ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
	# apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	# #recover()#
	# expected.num.haps <- colSums ( apply ( hap.counts.by.interval , 2 , function ( x ) x * 1 : n.tips ) / (2 * length ( input ) ) , 2 )#
	# #plot ( expected.num.haps , type = "l" , lty = 1 , lwd = 1.5 , xlab = "kb" , ylab = "Expected Number of Haplotypes" , bty = "n")#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- nrow ( hap.count.freqs.by.interval )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		}#
	}#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n"#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
# # #
# # Let's think about inference w/ genealogies#
#
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
log.likes <- lapply ( 1:nrow(coal.times [[ 1 ]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times [[ 1 ]] [ y , ] , x , 20000 ) ) )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , time.factor = 1 ) )
f
s
temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix )
i
neutral.freq.matrix
length(sweep.freq.matrix)
not.all.neutral.fixed
sweep.freq.matrix[[5000]]
Q
install.packages("randtoolbox")#
##install.packages("ape")#
library("randtoolbox")#
library("ape")#
turn.on.recovers=FALSE#
#
StructuredCoalescentSweep <- function ( N , s , f , reps , n.tips , r , sim.distance , interval.width , no.sweep = FALSE , constant.freq = FALSE, cond.on.loss = TRUE , cond.on.fix = TRUE , make.plot = FALSE , build.seq = TRUE , display.rep.count = TRUE , time.factor = 1 ) {#
	options ( error = recover )#
	#recover()#
	if ( constant.freq == FALSE ) {#
		temp <- SweepFromStandingSim ( N = N , s = s , f = f , time.factor = time.factor , reps = reps , no.sweep = no.sweep, cond.on.loss=cond.on.loss , cond.on.fix = cond.on.fix , display.rep.count )#
		frequencies <- temp [[ 1 ]]#
		if ( no.sweep == FALSE ) {	#
			sweep.start <- rep ( temp[[2]] , nrow ( frequencies ) )#
			sweep.start.forward <- ncol ( frequencies ) - sweep.start[1] #
			# if ( nrow ( frequencies ) > 1 ) {#
			fixation.time <- apply ( frequencies [ , sweep.start.forward : ncol ( frequencies ) ] , 1 , which.max ) + sweep.start.forward - 1#
			zeros <- apply ( frequencies [ , 1 : sweep.start.forward ] %% 1 == 0 , 1 , which )#
			entry <- numeric()#
			for ( i in 1 : length ( zeros ) ){#
				if ( length ( zeros [[ i ]] ) != 0 ) {#
					entry [ i ] <- tail ( zeros [[ i ]] , 1 )#
				} else {#
					entry [ i ] <- 1#
				}#
			}#
			transit.time <- fixation.time - entry#
			new.freqs <- matrix ( 0 , nrow = reps , ncol = max ( transit.time + 1 ) )#
			for ( i in 1 : nrow ( frequencies ) ) {#
				new.freqs [ i , 1 : ( transit.time [ i ] + 1 ) ] <- frequencies [ i , fixation.time [ i ] : entry [ i ] ]#
			}#
		} else if ( no.sweep == TRUE ){#
			#recover()#
			new.freqs <- frequencies [ , 1 : ncol ( frequencies ) ]#
			fixation.time <- rep ( 0 , reps )#
		}#
	} else if ( constant.freq == TRUE ) {#
		#recover()#
		new.freqs <- matrix ( f , nrow = reps , ncol = 4*N*f *10 )#
		fixation.time <- 0#
	}#
	num.lineages <- rep ( n.tips , reps )#
	coal.times <- matrix ( 0 , nrow = reps , ncol = n.tips - 1 )	#
	num.gens.simulated <- ncol ( new.freqs )#
	i = 1#
	## Coalscense#
	while ( any ( num.lineages > 1 ) ) {#
		no.mrca <- num.lineages != 1#
		coal.probs <- rep ( 0 , reps )#
		coal.probs [ no.mrca ] <- choose ( num.lineages [ no.mrca ] , 2 ) / ( 2 * N * new.freqs [ no.mrca , i ] )#
		r.nums <- runif ( reps )#
		if ( any ( r.nums < coal.probs ) ) {#
			coals <- r.nums < coal.probs#
			num.lineages [ coals ] <- num.lineages [ coals ] - 1#
			coal.rows <- which ( coals )#
			if ( length ( coal.rows ) > 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- apply ( coal.times[coal.rows,] , 1 , which.min )#
			} else if ( length ( coal.rows ) == 1 & ncol ( coal.times ) > 1 ) {#
				coal.cols <- which.min ( coal.times [ coal.rows , ] )#
			} else if ( ncol ( coal.times ) == 1) {#
				coal.cols <- rep ( 1 , length ( coal.rows ) )#
			}#
			coal.times [ (coal.cols-1) * reps + coal.rows ] <- i#
		}#
		i <- i + 1#
	}#
	mean.coalescence.times <- colMeans ( coal.times )#
	sd.coalescence.times <- apply ( coal.times , 2 , sd )#
	se.coalescence.times <- sd.coalescence.times / sqrt ( reps )#
	trees <- BuildTrees ( coal.times = coal.times )#
	for ( i in 1 : reps ) { #
		trees [[ i ]] [[ "freqs" ]] <- new.freqs[i,new.freqs[i,] != 0 ]#
	}#
#
	if ( build.seq == TRUE ) {#
	#recover()#
		temp <- RecombinationEvents ( trees = trees , coal.times = coal.times , r = r , sim.distance = sim.distance , n.tips = n.tips )#
		trees <- temp [[ 1 ]]#
		T.total <- temp [[ 2 ]]#
		#recover()#
		trees <- BuildOnOffHaps ( trees = trees , freqs = new.freqs , sim.distance = sim.distance , r = r , n.tips = n.tips , f = f , fixation.time = fixation.time )#
		hap.dist <- HapCountDistribution ( input = trees , r = r , sim.distance = sim.distance , interval.width = interval.width , f = f , N = N , make.plot )#
	}#
	return ( list ( coal.times = coal.times , new.freqs = new.freqs , mean.coalescence.times = mean.coalescence.times , sd.coalescence.times = sd.coalescence.times , trees = trees , hap.dist = hap.dist , fixation.time = fixation.time , T.total = T.total , sim.distance.bp = sim.distance/r) )#
}#
#
SweepFromStandingSim <- function ( N , s , f , reps , no.sweep, cond.on.loss , cond.on.fix , display.rep.count , time.factor = 1  ) {#
	delta.T <- 1 / ( time.factor * 2 * N )#
	sweep.freq.matrix <- list ( rep ( f , reps ) )#
	neutral.freq.matrix <- list ( rep ( f , reps ) )#
	not.all.sweeps.fixed <- TRUE#
	not.all.neutral.fixed <- TRUE#
	#recover()#
	i = 1#
	while ( not.all.sweeps.fixed  | not.all.neutral.fixed ) {#
		if ( not.all.sweeps.fixed ) {#
			update <- rep ( 0 , reps )#
			sweep.not.fixed <- sweep.freq.matrix [[ i ]] %% 1 != 0#
			sweep.fixed <- sweep.freq.matrix [[ i ]] %% 1 == 0#
			mu.S <- ifelse ( rep ( cond.on.fix , reps ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) / tanh ( 2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) ,#
									2 * N * s * sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] )#
									)#
			sel <- mu.S * delta.T#
			update [ sweep.not.fixed ] <- rnorm ( sum ( sweep.not.fixed ) , sel , sd = sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T ) )#
		#	sweep.drift.mag <- sqrt ( sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] * ( 1 - sweep.freq.matrix [[ i ]] [ sweep.not.fixed ] ) * delta.T)#
		#	plus.minus <- sample ( c ( 0 , 1 ) , sum ( sweep.not.fixed ) , replace = TRUE )#
		#	drift.sweep <- ifelse ( plus.minus == 1 , sweep.drift.mag , -1 * sweep.drift.mag )#
		#	update [ sweep.not.fixed ] <- sel + drift.sweep			#
			sweep.freq.matrix [[ i + 1 ]] <- sweep.freq.matrix [[ i ]] + update#
			sweep.fixed.one <- sweep.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.one ] <- 1#
			sweep.fixed.zero <- sweep.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			sweep.freq.matrix [[ i + 1 ]] [ sweep.fixed.zero ] <- 1 / ( 2 * N )#
			not.all.sweeps.fixed <- any ( sweep.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
		}#
		if ( not.all.neutral.fixed ) {	#
			update <- rep ( 0 , reps )#
			neutral.not.fixed <- neutral.freq.matrix [[ i ]] %% 1 != 0#
			neutral.fixed <- neutral.freq.matrix [[ i ]] %% 1 == 0#
			#neutral.drift.mag <- sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T )#
			#plus.minus <- sample ( c ( 0 , 1 ) , sum ( neutral.not.fixed ) , replace = TRUE )	#
			#drift.neutral <- ifelse ( plus.minus == 1 , neutral.drift.mag , -1 * neutral.drift.mag )#
			cond.mean <- ifelse ( rep ( cond.on.loss , reps ) ,#
			 				- neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * delta.T ,#
			 				0)#
			drift.neutral <- rnorm ( sum ( neutral.not.fixed ) , cond.mean , sd = sqrt ( neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] * ( 1 - neutral.freq.matrix [[ i ]] [ neutral.not.fixed ] ) * delta.T ) )#
			update [ neutral.not.fixed ] <- drift.neutral#
			neutral.freq.matrix [[ i + 1 ]] <- neutral.freq.matrix [[ i ]] + update#
			neutral.fixed.one <- neutral.freq.matrix [[ i + 1 ]] > ( 1 - ( 1 / ( 2 * N ) ) )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.one ] <- 1#
			neutral.fixed.zero <- neutral.freq.matrix [[ i + 1 ]] < 1 / ( 2 * N )#
			neutral.freq.matrix [[ i + 1 ]] [ neutral.fixed.zero ] <- 0	#
			not.all.neutral.fixed <- any ( neutral.freq.matrix [[ i ]] %% 1 != 0 )#
		}#
		if ( i %% 5000 == 0 & display.rep.count) {#
				lineages.remaining <- sum ( neutral.freq.matrix [[ i + 1 ]] %% 1 != 0 )#
				my.freq <- max ( neutral.freq.matrix [[ i + 1 ]] [ neutral.freq.matrix [[ i + 1 ]] < 1 ] )#
				cat ( "p = " , my.freq , ",  " , sep = "" )#
				cat ( lineages.remaining , "not fixed \n")#
		}		#
		if ( i == time.factor * 16 * N ){#
			break#
		}#
		i = i + 1#
	}#
	sweep.freq.matrix <- matrix ( unlist ( sweep.freq.matrix ) , nrow = reps )#
	sweep.keep <- seq ( 1 , ncol ( sweep.freq.matrix ) , by = time.factor )#
	if ( ncol ( sweep.freq.matrix ) %in% sweep.keep ) {#
 		sweep.freq.matrix <- sweep.freq.matrix [ , sweep.keep ]#
 	} else {#
	 	sweep.freq.matrix <- cbind ( sweep.freq.matrix [ , sweep.keep ] , 1 ) 		#
 	}#
	neutral.freq.matrix <- matrix ( unlist ( neutral.freq.matrix ) , nrow = reps )#
	neutral.keep <- seq ( 1 , ncol ( neutral.freq.matrix ) , by = time.factor )#
	if ( ncol ( neutral.freq.matrix ) %in% neutral.keep ) {#
		neutral.freq.matrix <- neutral.freq.matrix [ , neutral.keep ]#
	} else {#
		neutral.freq.matrix <- cbind ( neutral.freq.matrix [ , neutral.keep ] , 0 )#
	}#
if(turn.on.recovers)	recover()#
	# if ( constant.freq == FALSE ) {#
		# # if ( reps == 1 ) {#
			# # freq.trajectories <- c ( neutral.freq.matrix [ length ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ 1 : length ( sweep.freq.matrix ) ] )#
			# # #plot ( freq.trajectories , type = "l" )#
			# # freq.trajectories <- matrix ( freq.trajectories , nrow = 1 )#
			# # if ( freq.trajectories [ , ncol ( freq.trajectories ) ] == 1 ) {#
				# # conditional.freq.trajectories <- freq.trajectories#
				# # #generations <- seq ( 1 , ncol ( conditional.freq.trajectories ) , time.factor )#
				# # #conditional.freq.trajectories <- conditional.freq.trajectories [ , generations ]#
			# # } else {#
				# # cat ( "Allele lost from population.\n")#
				# # return ( )#
			# # }#
		# # } else {#
	if ( no.sweep == FALSE ) {#
		freq.trajectories <- cbind ( neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 2 ] , sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ] )#
	} else {#
		freq.trajectories <- neutral.freq.matrix [ , ncol ( neutral.freq.matrix ) : 1 ]#
		return ( list ( freq.trajectories , 0 ) )#
	}#
	temp1 <- apply ( freq.trajectories , 1 , function ( x ) rev ( x[x !=1] ) )#
	add.zeros <- max ( unlist ( lapply ( temp1 , length) ) ) - unlist ( lapply ( temp1 , length) )#
	temp2 <- mapply ( function ( x , y ) c ( rev ( c ( x , rep ( 0 , y ) ) ) , 1 ) , x = temp1 , y = add.zeros , SIMPLIFY = FALSE )#
	freq.trajectories <- do.call ( rbind , temp2 )#
		# }#
	# } else {#
		# freq.trajectories <- sweep.freq.matrix [ , 1 : ncol ( sweep.freq.matrix ) ]#
	# }#
	#recover()#
	#keep.these <- freq.trajectories [ , ncol ( freq.trajectories ) ] == 1		#
	#conditional.freq.trajectories <- freq.trajectories [ keep.these , ]#
	sweep.start <- ncol ( sweep.freq.matrix ) #/ time.factor#
	return ( list ( freq.trajectories , sweep.start ) )	#
}#
BuildTrees <- function ( coal.times ){#
	#recover()#
	library ( ape )#
	if ( is.matrix ( coal.times ) == FALSE ) {#
		n.trees <- 1#
		n.tips <- length ( coal.times ) + 1#
		coal.times <- matrix ( coal.times , nrow = 1 )#
	} else {#
		n.trees <- nrow ( coal.times )#
		n.tips <- ncol ( coal.times ) + 1#
	}#
	trees <- list ( )#
	for ( j in 1 : n.trees ) {#
		edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		edge.length <- numeric ( 2 * n.tips - 2 )#
		edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		node.depth <- numeric ( 2 * n.tips - 1 )#
		Nnode <- n.tips - 1#
		tip.label <- character ( n.tips )#
		for ( l in 1 : length ( tip.label ) ){#
			tip.label [ l ] <- paste ( "t" , l , sep = "")#
		}#
		k = 1#
		for ( i in nodes ) {#
			extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			edge [ coal.index , 1 ] <- i#
			if ( i != tail ( nodes , 1 ) ) {#
				edge [ i - 1 , 2 ] <- i#
			}#
			node.depth [ i ] <- coal.times [ j , k ] #
			edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			k = k + 1#
		}#
		a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		class ( a.tree ) <- "phylo"#
		my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		trees [[ j ]] <- my.tree#
	}#
	return ( trees )#
}#
# BuildTrees <- function ( coal.times , n.tips ){#
	# #recover()#
	# library(ape)#
	# trees <- list ( )#
	# for ( j in 1 : nrow ( coal.times ) ) {#
		# edge <- matrix ( 0 , nrow = 2 * n.tips - 2 , ncol = 2 )#
		# edge.length <- numeric ( 2 * n.tips - 2 )#
		# edge [ 1 : n.tips , 2 ] <- 1 : n.tips#
		# nodes <- ( 2 * n.tips - 1 ) : ( n.tips + 1 )#
		# node.depth <- numeric ( 2 * n.tips - 1 )#
		# Nnode <- n.tips - 1#
		# tip.label <- character ( n.tips )#
		# for ( l in 1 : length ( tip.label ) ){#
			# tip.label [ l ] <- paste ( "t" , l , sep = "")#
		# }#
		# k = 1#
		# for ( i in nodes ) {#
			# extant.lineages <- edge [ edge [ , 2] != 0 & edge [ , 1 ] == 0 , 2 ]#
			# coalescing.lineages <- sort ( sample ( extant.lineages , 2 , replace = FALSE ) )#
			# coal.index <- which ( edge [ , 2 ] %in% coalescing.lineages )#
			# edge [ coal.index , 1 ] <- i#
			# if ( i != tail ( nodes , 1 ) ) {#
				# edge [ i - 1 , 2 ] <- i#
			# }#
			# node.depth [ i ] <- coal.times [ j , k ] #
			# edge.length [ coal.index ] <- coal.times [ j , k ] - node.depth [ coalescing.lineages ]#
			# k = k + 1#
		# }#
		# a.tree <- list ( edge = edge , edge.length = edge.length , tip.label = tip.label , Nnode = Nnode )#
		# class ( a.tree ) <- "phylo"#
		# my.tree <- list ( tree = a.tree , node.depth = node.depth )#
		# trees [[ j ]] <- my.tree#
	# }#
	# ## note; the frequency path gets added on as trees [[ j ]] [[ 3 ]] in the top level function call immediately after returning from this function; bad writing that I should fix some day.#
	# return ( trees )#
# }#
#
RecombinationEvents <- function ( trees , coal.times , r , sim.distance , n.tips ) {#
if(turn.on.recovers)	recover()#
	if ( n.tips > 2 ) {#
		internodes <- matrix ( nrow = nrow ( coal.times ) , ncol = n.tips - 1 )#
		internodes [ , 1 ] <- coal.times [ , 1 ]#
		for ( i in 2 : ( n.tips - 1 ) ) {#
			internodes [ , i ] <- coal.times [ , i ] - coal.times [ , i - 1 ]#
		}#
	} else if ( n.tips == 2 ) {#
		internodes <- coal.times#
	}	#
	T.total <- numeric ( length ( trees ) )#
	#recover()#
	cat ( "Laying down recombination events. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		T.total [ j ] <- sum ( ( n.tips : 2 ) * internodes [ j , ] )#
		sim.distance.bp <- sim.distance/r#
		rec.right.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		rec.left.temp <- data.frame ( sequence.location = 0 , branch = 0 , rec.depth = 0 )#
		edges <- 1 : tail ( trees [[ j ]] [[ 1 ]] [[ 1 ]] [ , 2 ] , 1 )#
		if ( ncol ( coal.times ) > 1 ) {#
			edge.lengths <- c ( trees [[ j ]] [[ 1 ]] [[ 2 ]] [  1 : ( ( length ( edges ) + 1 ) / 2 ) ] , 0 , trees [[ j ]] [[ 1 ]] [[ 2 ]] [ ( ( ( length ( edges ) + 1 ) / 2 ) + 1 ) : ( length ( edges ) - 1 ) ] )#
		} else {#
			edge.lengths <- trees [[ j ]] [[ 1 ]] [[ 2 ]]#
		}#
		i = 1#
		while ( rec.right.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.right.temp [ i + 1 , 1 ] <- rec.right.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.right.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.right.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.right.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.right.temp [ i + 1 , 2 ] ] - 1) , 1 )#
			i = i + 1#
		}#
		i = 1#
		while ( rec.left.temp [ i , 1 ] < sim.distance.bp ) {#
			rec.left.temp [ i + 1 , 1 ] <- rec.left.temp$sequence.location [ i ] + round ( rexp ( 1 , r * T.total [ j ] ) )#
			rec.left.temp [ i + 1 , 2 ] <- sample ( edges , 1 , prob = edge.lengths )#
			rec.left.temp [ i + 1 , 3 ] <- trees [[ j ]] [[2]] [ rec.left.temp [ i + 1 , 2 ] ] + sample ( seq ( 1 , edge.lengths [ rec.left.temp [ i + 1 , 2 ] ] - 1 ) , 1 )#
			i = i + 1#
		}#
		#recover()#
		trees [[ j ]] [[ "T.total" ]] <- T.total [ j ]#
		trees [[ j ]] [[ "rec.events" ]] <- recombination <-  list ( rec.right = rec.right.temp [ -c ( 1 , nrow ( rec.right.temp ) ), ] , rec.left = rec.left.temp [ -c ( 1 , nrow ( rec.left.temp ) ) , ] )#
		setTxtProgressBar ( pb, j )#
	}#
	close ( pb )	#
	return ( list ( trees, T.total ) )#
#
}#
#
BuildOnOffHaps <- function ( trees , freqs , r , sim.distance , n.tips , f , fixation.time ) {#
	sim.distance.bp <- sim.distance / r#
	#recover()#
	cat ( "Building Haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( trees ) , style = 3 )#
	for ( j in 1 : length ( trees ) ) {#
		rec.right <- trees [[ j ]]$rec.events$rec.right#
		rec.left <- trees[[ j ]]$rec.events$rec.left#
		## build right side haplotype ###
		event.order <- order ( rec.right [ , 3 ] , decreasing = TRUE )#
		right.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.right ) + 1 )#
		sub.trees <- prop.part ( trees [[ j ]]$tree )#
		to.remove <- numeric ( )#
		h = 1#
		l = 2#
		if ( nrow ( rec.right ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.right [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						right.sequence.temp [ tips , ( i + 1 ) : ncol ( right.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						right.sequence.temp [ tip , ( i + 1 )  : ncol ( right.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			for ( i in 2 : ncol ( right.sequence.temp ) ) {#
				if ( length ( unique ( right.sequence.temp [ , i ] ) ) == length ( unique ( right.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ){			#
			right.sequence <- right.sequence.temp [ , -to.remove ]#
			right.sequence <- MakeHapsPretty ( right.sequence )#
			rec.right.off.background <- rec.right [ - ( to.remove - 1 ) , ]#
		} else {#
			right.sequence <- right.sequence.temp#
			right.sequence <- MakeHapsPretty ( right.sequence )			#
			rec.right.off.background <- rec.right#
		}#
		## build left side haplotype ## #
		event.order <- order ( rec.left [ , 3 ] , decreasing = TRUE )#
		left.sequence.temp <- matrix ( 0 , nrow = n.tips , ncol = nrow ( rec.left ) + 1 )#
		sub.trees <- prop.part( trees [[ j ]] [[ 1 ]] )#
		to.remove <- numeric ( )#
		l = 2#
		if ( nrow ( rec.left ) != 0 ) {#
			for ( i in event.order ) {#
				this.event <- data.frame ( rec.left [ i , ] , hap.ID = h )#
				if ( this.event$rec.depth == 0 ) {#
					break#
				} else {#
					my.freq <- trees [[ j ]] [[ 3 ]] [ this.event$rec.depth ]#
				}#
				rec.roll <- runif ( 1 )#
				if ( rec.roll < ( 1 - my.freq ) ) {#
					if ( this.event$branch > n.tips ) {#
						tips <- unlist ( sub.trees [ this.event$branch - n.tips ] )#
						left.sequence.temp [ tips , ( i + 1 ) : ncol ( left.sequence.temp ) ] <- h#
					} else {#
						tip <- this.event$branch#
						left.sequence.temp [ tip , ( i + 1 )  : ncol ( left.sequence.temp ) ] <- h#
					}#
				l = l + 1#
				h = h + 1	#
				}#
			}#
			#recover()#
			for ( i in 2 : ncol ( left.sequence.temp ) ) {#
				if ( length ( unique ( left.sequence.temp [ , i ] ) ) == length ( unique ( left.sequence.temp [ , i - 1 ] ) ) ) {#
					to.remove [ length ( to.remove ) + 1 ] <- i#
				}#
			}#
		} #
		if ( length ( to.remove ) != 0 ) {#
			left.sequence <- left.sequence.temp [ , -to.remove ]#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left [ - ( to.remove - 1 ) , ]#
		} else {#
			left.sequence <- left.sequence.temp#
			left.sequence <- MakeHapsPretty ( left.sequence )#
			rec.left.off.background <- rec.left#
		}#
#
		setTxtProgressBar ( pb, j )#
		trees [[ j ]] [[ "sequence.structure" ]] <- list ( right.seq = right.sequence , left.seq = left.sequence )#
		trees [[ j ]] [[ "rec.events.off.background" ]] <- list ( rec.right.off.background = rec.right.off.background , rec.left.off.background = rec.left.off.background )#
		trees [[ j ]] [[ "sim.distance.bp" ]] <- sim.distance.bp#
	}#
	close ( pb )#
	return ( trees )#
}#
HapCountDistribution <- function ( input , r = 10^-8 , sim.distance , interval.width = 1000 , f , N , make.plot ) {#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- length ( input [[ 1 ]]$tree$tip.label )#
	reps <- length ( input )#
	# number of rows in "sequence" matrix = number of samples#
	if ( turn.on.recovers ) {#
		recover()#
	}#
	n.haps.right <- n.haps.left <- matrix ( nrow = length ( input ) , ncol = length ( intervals ) )#
	#recover()#
	cat ( "Counting up haplotypes. \n \n")#
	pb <- txtProgressBar ( min = 0 , max = length ( intervals ) , style = 3 )#
	for ( i in 1 : length ( intervals ) ) {#
		k <- intervals [ i ]#
#
		if ( k == 0 ) {#
			# there is only one haplotype at the selected sight		#
			n.haps.right [ , i ] <- n.haps.left [ , i ] <- 1#
		} else {#
			# now we loop through the simulated data to work out the number of haplotypes at various intervals away from the selected sight#
			#recover ( )#
			for ( j in 1 : length ( input ) ) {#
				my.seqs <- input [[ j ]] $ sequence.structure#
				my.rec.events <- input [[ j ]] $ rec.events.off.background#
				# right side#
				if ( sum ( my.rec.events$rec.right.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.right.off.background$sequence.location < k ) )#
					n.haps.right [ j , i ] <-  length ( unique ( my.seqs$right.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.right [ j , i ] <- 1#
				}#
				# left.side#
				if ( sum ( my.rec.events$rec.left.off.background$sequence.location < k ) != 0 ) {#
					last.rec.event <- max ( which ( my.rec.events$rec.left.off.background$sequence.location < k ) )#
					n.haps.left [ j , i ] <-  length ( unique ( my.seqs$left.seq [ , last.rec.event + 1 ] ) )#
				} else {#
					n.haps.left [ j , i ] <- 1#
				}#
			}	#
		}	#
		setTxtProgressBar(pb, i)#
	}#
	close(pb)#
#
	#recover()#
	n.haps <- rbind ( n.haps.right , n.haps.left )#
	hap.counts.by.interval <- apply ( n.haps , 2 , function ( x ) table ( factor ( x , 1 : n.tips ) ) )#
	hap.count.freqs.by.interval <- apply ( hap.counts.by.interval , 2 , function ( x ) x / nrow ( n.haps ) )#
	if ( make.plot ) {#
		MakeHapPlots ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000 )#
	}#
	# cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )#
# #	par ( mfrow = c ( 2 , 1 ) )#
	# #matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	# ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
	# stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	# for ( i in 1 : length ( intervals ) ) {#
		# if ( i == 1 & intervals [ 1 ] == 0 ) {#
			# ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		# } else { #
			# ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f , stirling.numbers = stirling.numbers )#
		# }#
	# }#
	# #recover()#
	# ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )#
	# matplot ( #
		# t ( ewens.cum.probs ) , #
		# type = "n" , #
		# lty = 1 , #
		# lwd = 0.7 , #
		# col = "black" , #
		# ylab = "Cumulative Probability" , #
		# xlab = "kb" , #
		# #main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		# bty = "n"#
	# )#
	# #recover()#
	# col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
	# for ( i in 1 : ( nrow ( cum.probs ) - 1 ) ) {#
			# #i = i + 1#
			# X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
			# Y.ax1 <- cum.probs [ i , X.ax ]#
			# Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			# polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	# }#
	# ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
	# apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	# #recover()#
	# expected.num.haps <- colSums ( apply ( hap.counts.by.interval , 2 , function ( x ) x * 1 : n.tips ) / (2 * length ( input ) ) , 2 )#
	# #plot ( expected.num.haps , type = "l" , lty = 1 , lwd = 1.5 , xlab = "kb" , ylab = "Expected Number of Haplotypes" , bty = "n")#
	return ( list ( hap.count.freqs.by.interval = hap.count.freqs.by.interval , n.haps = n.haps ) )#
}#
MakeHapPlots <- function ( hap.count.freqs.by.interval , N , f , sim.distance , r = 10^-8 , interval.width = 1000,plot.cumulative=TRUE) {#
	#par ( mfrow = c ( 2 , 1 ) )#
	#matplot ( t ( cum.probs ) , type = "l" , lty = 1 , lwd = 0.7 , col = "black" , ylab = "Cumulative Probability" , xlab = "kb" , main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , bty = "n")#
	sim.distance.bp <- sim.distance / r #
	intervals <- seq ( 0 , sim.distance.bp , interval.width )#
	n.tips <- nrow ( hap.count.freqs.by.interval )#
	if(plot.cumulative){	cum.probs <- rbind ( 0 , apply ( hap.count.freqs.by.interval , 2 , cumsum ) )}#
	if(!plot.cumulative){ cum.probs <- rbind ( 0 ,hap.count.freqs.by.interval)}#
#
	ewens.dist.matrix <- matrix ( nrow = n.tips , ncol = length ( intervals ) )#
#
	stirling.numbers <- StirlingNumbers ( n = n.tips ) [ n.tips , ]#
	for ( i in 1 : length ( intervals ) ) {#
		if ( i == 1 & intervals [ 1 ] == 0 ) {#
			ewens.dist.matrix [ , i ] <- c ( 1 , rep ( 0 , n.tips - 1 ) )#
		} else { #
			ewens.dist.matrix [ , i ] <- EwensDist ( n = n.tips , N = N , r = r , distance = intervals [ i ] , f = f  ) [ n.tips , ]#
		}#
	}#
	#recover()#
#recover()#
	if(plot.cumulative){ ewens.cum.probs <-  apply ( ewens.dist.matrix , 2 , cumsum )}#
	if(!plot.cumulative){ewens.cum.probs <-ewens.dist.matrix; }#
	matplot ( #
		t ( ewens.cum.probs ) , #
		type = "n" , #
		lty = 1 , #
		lwd = 0.7 , #
		col = "black" , #
		ylab = "Cumulative Probability" , #
		xlab = "kb" , #
		#main = paste ( n.tips , "Lineages in a Sweep from f =" , f , "at s =" , s , "," , reps , "Reps" ) , #
		bty = "n"#
	)#
	#recover()#
	col.vect <- rainbow ( n.tips , s = 0.8  , v = 1 , start = 1/40 , end = 4/6  )#
legend("topright", legend=paste("j=",1:n.tips), lty=1,col= col.vect,lwd=2)#
#
	for ( i in  ( nrow ( cum.probs ) - 1 ):1 ) {#
			#i = i + 1#
			X.ax <- 1:ncol ( cum.probs ) #which ( cum.probs [ i , ] != cum.probs [ i + 1 , ] )#
	if(plot.cumulative){	Y.ax1 <- cum.probs [ i , X.ax ]}#
	if(!plot.cumulative){ Y.ax1 <- rep(0,ncol ( cum.probs ) )	}#
			if(!plot.cumulative){ #
				lines(X.ax,cum.probs [ i + 1 , X.ax ], col = col.vect [ i ],lwd=2 )#
				lines (ewens.cum.probs[i,], col = col.vect [ i ],lwd=2,lty=2 ) #
				}#
			Y.ax2 <- cum.probs [ i + 1 , X.ax ]#
			if(plot.cumulative) polygon ( x = c ( X.ax , rev ( X.ax ) ) , y = c ( Y.ax1 , rev ( Y.ax2 ) ) , lty = 0 , col = col.vect [ i ] )					#
	}#
	if(plot.cumulative){ #
		ewens.cum.probs <- ewens.cum.probs [ - nrow ( ewens.cum.probs ) , ]#
		apply ( ewens.cum.probs , 1 , function ( x ) lines ( x , lty = 1 , lwd = 0.8 ) )#
	}#
}#
StirlingNumbers <- function ( n ) {#
	library ( randtoolbox )#
	second.kind <- lapply ( 1 : n , stirling )#
	second.kind.matrix <- matrix ( nrow = n , ncol = n )#
	for ( i in 1 : n ) {#
		if ( i < n ) {#
			second.kind.matrix [ i , ] <- c ( second.kind [[ i ]] [ -1 ], rep ( 0 , n - length ( second.kind [[ i ]] ) + 1 ) )#
		} else if ( i == n ) {#
			second.kind.matrix [ i , ] <- second.kind [[ i ]] [ -1 ]#
		}#
	}#
	#recover()#
	first.kind.matrix <- abs ( solve ( second.kind.matrix ) )#
	first.kind.matrix [ first.kind.matrix < 0.99 ] <- 0#
	return ( first.kind.matrix )#
}#
#
EwensDist <- function ( n , N , r , distance , f ) {#
	#recover()	#
	param <- 4 * N * r * distance * f * ( 1- f )#
	denom  <- cumprod ( param + 0 : ( n - 1 ) )#
	stirling.numbers <- StirlingNumbers ( n )#
	ewens.dist <- t ( param^(1:n) * t ( stirling.numbers / denom ) )#
	return ( ewens.dist ) #
#
}#
MakeHapsPretty <- function ( seqs ) {#
	if ( !is.numeric ( nrow ( seqs ) ) | !is.numeric ( ncol ( seqs ) ) ) recover()#
	new.seqs <- matrix ( 0 , nrow = nrow ( seqs ) , ncol = ncol ( seqs ) )#
	for ( i in 2 : ncol ( seqs ) ) {	#
		j <- i - 1#
		new.ids <- unique ( seqs [ seqs [ , i ] %in% seqs [ , i - 1 ] == FALSE , i ])#
		for ( x in new.ids ){#
			last.hap <- unique ( seqs [ seqs [ , i ] == x , i - 1 ] )#
			if ( sum ( seqs [ , i ] == x ) != sum ( seqs [ , i - 1 ] == last.hap ) ) {#
				new.hap <- x#
				break #
			}	#
		}#
		new.seqs [ seqs [ , i ] == new.hap , i : ncol ( new.seqs ) ] <- j#
	}#
	return ( new.seqs )#
}#
if(FALSE){#
fs <- c ( 1/20000  , 0.01 , 0.05 , 0.1 )#
ss <- c ( 0.001 , 0.01 , 0.05 )#
fands <- expand.grid ( fs , ss )#
colnames ( fands ) <- c ( "f" , "s")#
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = FALSE ,  time.factor = 1 ) )#
#
#function to get haplotype distribution plots from function output#
MakeHapPlots ( temp$hap.dist$hap.count.freqs.by.interval , N = 10000, f = 0.01, sim.distance = 0.02)#
# # #
# # Let's think about inference w/ genealogies#
#
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )#
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}#
#
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )#
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )#
fs.grid <- expand.grid ( s.vect , f.vect )#
log.likes <- lapply ( 1:nrow(coal.times [[ 1 ]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times [[ 1 ]] [ y , ] , x , 20000 ) ) )#
temp <- lapply ( log.likes , function ( x ) x [ 1:2 , which.max ( x [3,] ) ] )#
max.like <- do.call ( rbind , temp )#
my.means <- colMeans ( max.like )#
margin.s <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,1],mean))#
margin.f <- lapply ( log.likes , function ( x )  tapply ( exp(t ( x ) [,3]), t ( x ) [,2],mean))#
hist ( f.vect [unlist ( lapply ( margin.f , which.max)) ],breaks = 50)#
hist ( s.vect [unlist ( lapply ( margin.s , which.max)) ],breaks = 50)#
LikelihoodFunction ( my.times , c ( 0.05, 0.05) , 20000 )#
plot ( NA , xlim = c ( 0,0.2),ylim = c ( 0, 0.05),type ="n",bty="n")#
lapply ( 1:200 , function ( x ) points ( temp[[x]][1] , temp[[x]][2] , cex=0.7,pch=20))#
points (my.means[1] , my.means[2] , pch = 3 , col = "red" )#
#
InferenceFunction <- function ( coal.times ) {#
	recover()	#
}#
}#
# InferenceFunction ( seqs = my.seqs )#
#
# i = 1#
# par(mfrow=c(2,1))#
# plot ( temp$trees[[i]]$freqs , type = "l" , xlim = c ( length ( temp$trees[[i]][[3]] ) - max ( temp$trees[[i]][[2]] ) , length ( temp$trees[[i]][[3]] ) ) )#
# plot ( temp$trees[[i]][[1]] , x.lim = c ( 0 , max ( temp$trees[[i]][[2]] ) ) )#
# temp$trees[[i]][[5]]; i = i + 1#
#
# }
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = FALSE ,  time.factor = 1 ) )
length(temp)
names(temp[[1]])
fands <- expand.grid ( fs , ss )
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )
coal.times <- lapply ( 1 : 2 , function ( x ) temp[[x]]$coal.times )
coal.times
fands <- expand.grid ( fs , ss )
fands
colnames ( fands ) <- c ( "f" , "s")
fands
temp <- apply ( fands , 1 , function ( x ) StructuredCoalescentSweep ( N = 10000 , s = x[2] , f = x[1] , reps = 200 , n.tips = 12 , r = 10^-8 , sim.distance = 0.01 , interval.width = 1000 , no.sweep = FALSE , constant.freq = FALSE , cond.on.loss = TRUE , build.seq = TRUE , display.rep.count = FALSE ,  time.factor = 1 ) )
coal.times <- lapply ( 1 : nrow ( fands ) , function ( x ) temp[[x]]$coal.times )
length(coal.times)
coal.times[[1]]
coal.times[[12]]
fands
LikelihoodFunction <- function ( my.times , s.f , N ) {#
	s <- as.numeric ( s.f [ 1 ] )#
	f <- as.numeric ( s.f [ 2 ] )#
	#recover()	#
	tau_s <- log ( ( N * (1-f) + ( 1 - f ) ) / f ) / s#
	n.sam <- length ( my.times ) + 1#
	# likelihood for sweep portion #
	coals.in.sweep <-  my.times [ my.times<tau_s ]#
	n.sam.end.sweep <- n.sam - length ( coals.in.sweep )#
	sweep.event.times <- c ( 0 , coals.in.sweep , tau_s )#
	inv.Nt.Int <- exp (s*sweep.event.times) / ((N - 1)*N*s ) + sweep.event.times/N#
	exponents <- diff ( inv.Nt.Int )#
	sweep.log.likelihood.prohibit.coals = -choose ( n.sam:n.sam.end.sweep , 2 )*exponents#
	sweep.log.likelihood.coals = log ( 1 / (N - (N*exp ( s * coals.in.sweep)/(N-1+exp(s*coals.in.sweep)))) )#
	sweep.log.likelihood = sum ( sweep.log.likelihood.prohibit.coals , sweep.log.likelihood.coals )#
	#likelihood for neutral portion#
	lin.remaining <- n.sam - which ( my.times>=tau_s ) + 1#
	coals.in.neutral <- my.times [ my.times>=tau_s ]#
	neutral.event.times <- c ( tau_s , coals.in.neutral )#
	neutral.wait.times <- diff ( neutral.event.times )#
	neutral.log.likelihood.prohibit.coals =  - choose ( lin.remaining , 2 ) * neutral.wait.times / ( N*f )#
	neutral.log.likelihood.coals = length ( lin.remaining ) * log ( 1 / (N*f) )#
	neutral.log.likelihood = sum ( neutral.log.likelihood.coals , neutral.log.likelihood.prohibit.coals )#
	log.like <- sum ( sweep.log.likelihood , neutral.log.likelihood )#
	return ( c ( s.f , log.like ) )#
}
s.vect <- c ( 0.0001 , 0.001 , seq ( 0.01 , 0.2 , by = 0.003 ) )
f.vect <- seq ( 1/20000 , 0.05 , 1e-4 )
fs.grid <- expand.grid ( s.vect , f.vect )
log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(coal.times [[ z ]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times [[ 1 ]] [ y , ] , x , 20000 ) ) ) )
coal.times
log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(coal.times [[ z ]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times [[ z ]] [ y , ] , x , 20000 ) ) ) )
log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(z) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( z [ y , ] , x , 20000 ) ) ) )
log.likes <- lapply ( 1:nrow(coal.times[[1]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times[[1]] [ y , ] , x , 20000 ) ) )
length(log.likes)
log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(z) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( z [ y , ] , x , 20000 ) ) ) ; print(Sys.time()))
log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(z) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( z [ y , ] , x , 20000 ) ) ))
log.likes <- lapply ( coal.times , function ( z ) lapply ( 1:nrow(z) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( z [ y , ] , x , 20000 ) ) ) ; Sys.time() )
for ( i in 1 : length ( coal.times ) ) {#
	log.likes <- lapply ( 1:nrow(coal.times[[i]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times[[i]] [ y , ] , x , 20000 ) ) )#
	print ( i )#
}
log.likes
log.likes <- list()
for ( i in 1 : length ( coal.times ) ) {#
	log.likes[[i]] <- lapply ( 1:nrow(coal.times[[i]]) , function ( y ) apply ( fs.grid , 1 , function ( x ) LikelihoodFunction ( coal.times[[i]] [ y , ] , x , 20000 ) ) )#
	print ( i )#
}
length(log.likes)
getwd()
save ( log.likes, file = "log.likes.Robj")
choose(4,2)
length(log.likes[[1]])
dim(log.likes[[1]])
(log.likes[[1]])
